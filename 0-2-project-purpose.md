# Reml プロジェクトの目的と指針

## 1. プロジェクトが解決したい課題

- パーサーコンビネーターを核にした言語処理系を、構想から実行まで最短距離で組み立てられるようにする。
- DSL やコンパイラを何度も試作・改良する際のサイクルを縮め、実務での試行錯誤を支える環境を整える。
- 実サービスやツールとして利用できる現実的な性能・FFI・JIT/IR 連携を最優先で備え、結果的に学習にも使えることを目指す。

## 2. プロジェクトの最上位ゴール（実用性優先）

1. **実用性能と安全性の両立**: 末尾最適化・トランポリン・Packrat/左再帰の切り替え、ゼロコピー志向の設計で、大規模入力やリアルタイム用途にも耐える基盤を確保すること。
2. **自力完結できるエコシステム**: OCamlブートストラップを経てReml 自身でセルフホストし、LLVM/FFI と接続して現実のアプリケーションへ落とし込めるまでの道筋を示すこと。
3. **書きやすく読みやすい言語体験**: 宣言的な優先度設定、左から右へ流れるパイプ、強力な型推論によって短い記述で意図が伝わること（実用性の範囲で）。
4. **エラー品質の徹底**: 位置・期待集合・コミット境界・復旧・トレースを揃え、何が欲しかったのかを即座に伝える診断を標準で提供すること。
5. **Unicode ファーストな実装**: `byte/char/grapheme` の三層モデルを前提に、現実の多言語・絵文字・結合記号を安全に扱えること。

## 3. 設計を貫く基本哲学

- **小さく強いコア**: 言語も標準パーサ API も 12-15個の本質的プリミティブに凝縮し、残りは合成で表現する。Chapter 3 の標準ライブラリ章では、この哲学を Core.* モジュールへ拡張し、再利用しやすい API 群として体系化する。
- **宣言で終わらせる操作性**: 演算子優先度・空白処理・字句規則を宣言的に与えることで、記述者が「何をしたいか」に集中できるようにする。
- **効果の制御と安全なバックトラック**: `cut`, `label`, `recover`, `trace` などの効果を明示し、失敗の伝播や復旧をプログラマが設計できるようにする。
- **ツールフレンドリーな情報保持**: `SpanTrace` や期待集合を保持し、IDE・可視化・インクリメンタル解析への連携を想定してデータを捨てない。
- **段階的な最適化パイプライン**: 構文解析 → 型推論 → 降格 → MIR → LLVM IR の工程を明文化し、MVP から本格実装まで拡張しやすい構造にする。

## 3.1 横断テーマと仕様配置

フェーズ別に洗い出した横断テーマは、上記哲学を運用へ落とし込むための橋渡しとして配置される。

- **型安全な設定**: `Core.Config`（[2-7](2-7-config.md)）、`Core.Data`（[2-8](2-8-data.md)）、`設定 CLI ワークフロー`（[guides/config-cli.md](guides/config-cli.md)）で、宣言 DSL → 差分 → 実行 → 監査を一貫管理する。
- **ツール連携**: 実行戦略の LSP 出力（[2-6](2-6-execution-strategy.md)）、`LSP / IDE 連携ガイド`（[guides/lsp-integration.md](guides/lsp-integration.md)）、ランタイム橋渡し（[guides/runtime-bridges.md](guides/runtime-bridges.md)）で、IDE・CI・監査ログを共通メタデータで束ねる。
- **プラグイン拡張**: プラグイン API（[2-1](2-1-parser-type.md):I）、`DSL プラグイン & Capability ガイド`（[guides/DSL-plugin.md](guides/DSL-plugin.md)）で、外部 DSL の署名・互換・配布フローを定義する。

これらのテーマは各仕様章とガイドの更新履歴で進捗を追跡し、利用シナリオからのフィードバックと照合して順次クローズする。

## 3.2 Chapter 3 への展開計画

標準ライブラリ（`Core.*`）は Reml の非機能要件と横断テーマを支えるための共通 API 群として整理中である。フェーズ1の範囲定義では失敗処理・可変構造・Unicode・監査・プラグインなど、Core.Parse 以外で補完すべき領域と採否基準を洗い出した。【F:notes/core-library-scope.md†L1-L48】

フェーズ2の骨子では Prelude、Collections、Text/Unicode、Numeric/Time、IO/Path、Diagnostics/Audit、Config/Data、Runtime/Capability Registry、Async/FFI/Unsafe といった章立てを仮配置し、各テーマごとの参照関係を整理している。【F:notes/core-library-outline.md†L1-L31】Chapter 3 ではこれらの仕様をドラフトとして公開しており、Chapter 2 の既存文書から段階的に移行する計画である。

この計画を通じて、横断テーマで掲げた型安全な設定、ツール連携、プラグイン拡張を Chapter 3 各節の API として公式化し、運用ガイドとの往復参照を確立することを目標とする。【F:notes/core-library-outline.md†L20-L31】

## 4. 想定利用シナリオ（実用性優先順）

- **実運用を視野に入れたツール開発**: LLVM 連携や FFI を前提に、JIT 実行・実行形式生成・ホスト言語との橋渡しを行うアプリケーションを最優先で想定する。
- **多数の DSL を抱えるプロジェクト**: ゲームエンジンなど複数ジャンルで異なる記法が必要な現場で、Core.Parse を中心に高速に DSL を組み立てられるよう支援する。
- **コンパイラ開発への応用**: HM 型推論や効果システムを含むフルスタックな処理系設計を、結果的に学習・参考にできるようにする（二次的）。

## 5. 成功の判断基準

- Reml と Core.Parse だけで「読みやすく診断が良い」パーサを組み立て、Packrat/左再帰の切り替えやエラー整形が宣言的に制御できる。
- OCamlブートストラップを経て、最終的に自身のコンパイラが Reml で記述され、LLVM IR 生成パイプラインを通じて JIT/バイナリを実行できる状態まで持っていける。
- Unicode を含む複雑な入力や大規模データに対しても、設計思想どおりに安定した性能・エラー品質・可観測性が確認できる。
- 実務で再利用しやすいガイド（本仕様群）として、関係ドキュメント間で理念・目的が一貫して説明されており、結果的に教材としても利用できる。

## 6. 今後の対話で検証すべき観点

- ここに挙げたゴールを満たすうえで、各仕様書が具体的にどこを支えているか（欠落や重複がないか）。
- Packrat/左再帰やエラー回復など、オプション機能のトレードオフと既定値が目的に沿っているか。
- OCamlブートストラップ・LLVM 連携・セルフホスト達成までのロードマップが、ドキュメント間で矛盾なく説明されているか。
- 実務用途を最優先に、サンプル・リファレンス・ユースケースが十分で、結果的に学習にも使えるか。
