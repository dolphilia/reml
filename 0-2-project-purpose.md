# Reml プロジェクトの目的と設計指針

この文書は、Reml の仕様を検討・決定する際の判断基準を提供します。設計で迷った時や、複数の選択肢がある時に、何を優先すべきかの指針として活用してください。

## 1. Reml が大切にする価値観

Reml の設計では、以下の価値観を重視します。優先度順に整理されており、上位の原則ほど妥協できません。

### 絶対に守るべき原則（最優先）

#### 1.1 実用に耐える性能

- **何を目指すか**: 学習・試作用途だけでなく、実世界の商用システムで安心して使える性能を確保する
- **具体的な基準**:
  - 解析速度: 10MBのソースファイルを線形時間（O(n)）で処理
  - メモリ使用量: 入力サイズの2倍以下でピークメモリを抑制
  - スケーラビリティ: 1KBから50MBまで安定した性能特性

#### 1.2 安全性の確保

- **何を目指すか**: プログラムが予想外の動作をしたり、実行中にクラッシュする可能性を最小化する
- **具体的な基準**:
  - 型安全性: コンパイル時に型エラーを100%検出
  - メモリ安全性: バッファオーバーフロー、メモリリーク、ダングリングポインタの防止
  - 例外機構: 未キャッチ例外によるクラッシュを防ぐため、`Result`型でのエラーハンドリングを採用

### 強く推奨する原則（高優先）

#### 2.1 書きやすく覚えやすい言語

- **何を目指すか**: 一般的なプログラマーが直感的に理解でき、記憶負荷が少ない言語設計
- **具体的な基準**:
  - 構文簡結性: 核となる構文要素は15種類以下（変数宣言、関数定義、条件分岐等）
  - ネスト深度: ブロックのネストは3階層までを推奨
  - 命名一貫性: snake_case、camelCase等の一貫した規則を全ライブラリで適用

#### 2.2 分かりやすいエラーメッセージ

- **何を目指すか**: エラーが発生した際、開発者が素早く問題を特定して修正できる診断情報を提供
- **具体的な基準**:
  - エラー位置: 行番号、列番号、問題のあるトークンを明示
  - 期待値情報: 「`{` が期待されましたが、`;` が見つかりました」のような具体的な説明
  - 修正候補: タイポの可能性がある場合は「もしかして: `length` ではなく `lenght`?」のような提案

### 目指すべき原則（中優先）

#### 3.1 Unicode対応の充実

- **何を目指すか**: 世界中の文字・言語で書かれたテキストを正しく処理できる国際化対応
- **具体的な基準**:
  - 文字モデル: UTF-8バイト列、Unicodeコードポイント、書記素クラスターの3層構造で処理
  - 正規化: Unicode正規化形式（NFC、NFD、NFKC、NFKD）に対応
  - 絵文字サポート: 絵文字シーケンス（👨‍💻等）を一つの文字として扱う

#### 3.2 開発ツールとの連携

- **何を目指すか**: 開発者が既存のワークフローやツールチェーンに簡単に組み込める環境
- **具体的な基準**:
  - エディタ連携: Language Server Protocol (LSP) 実装で自動補完、シンタックスハイライト、リアルタイムエラー表示を提供
  - ビルドシステム: JSON形式の構造化ログでCI/CDツールと連携
  - 拡張性: プラグインAPIでカスタムリントルールやコードジェネレータの組み込みをサポート

## 2. 設計で迷った時の考え方

仕様の選択肢が複数ある場合は、以下の質問に順番に答えて判断してください。

### ステップ1: 安全性・性能への影響

**主質問**: この選択は以下のリスクを引き起こすか？

- 実行時エラー（ヌルポインタ参照、配列越境、型キャスト失敗等）
- 性能劣化（線形から二乗の計算量増加、メモリリーク等）
- セキュリティホール（バッファオーバーフロー、コードインジェクション等）

**判断**:

- **リスクあり**: 安全性を最優先とし、リスクのない選択肢を採用
- **リスクなし**: ステップ2へ進む

### ステップ2: 学習・使用コストの比較

**主質問**: 以下の視点でどちらが優れているか？

**学習コストの比較**:

- 既存のプログラミング言語で似たような機能があるか？
- 概念を理解するために必要な予備知識はどの程度か？
- コード例を見ただけで動作を推測できるか？

**使用コストの比較**:

- 同じ処理を実現するためのコード量はどちらが少ないか？
- エラーを起こしやすい落とし穴があるか？
- IDEの支援（自動補完、リファクタリング）を実装しやすいか？

**判断基準**: 3年以上のプログラミング経験を持つ人が30分以内に理解できる

**迷う場合**: より単純で一貫性のある選択肢を採用

### ステップ3: 将来性・拡張性の検討

**主質問**: 長期的な観点でどちらが適切か？

**拡張性の評価**:

- 新しい機能を追加する際、修正が必要な範囲はどの程度か？
- サードパーティライブラリやツールとの統合は容易か？
- 仕様変更が既存コードに与える影響はどの程度か？

**互換性の評価**:

- メジャーバージョンアップ時の移行コストはどの程度か？
- 言語仕様の安定化後にも変更が必要になる可能性はあるか？
- 一度採用したら後から変更するのが困難な設計か？

**判断基準**: 5年後でも使い続けられる設計か

**それでも迷う場合**: プログラミング言語理論で実績のある選択肢を採用

### 特別な判断が必要な場合

以下の状況では、通常の優先度を一時的に変更して判断します：

- **セキュリティ関連**: 安全性を最優先とし、性能や利便性を犠牲にしてでも安全な選択肢を採用
- **標準仕様適合**: Unicode、RFC、ISO等の業界標準に合わせ、独自仕様による利便性向上よりも互換性を重視
- **エコシステム連携**: 既存ツールチェーンとの連携を重視し、単体での最適化よりもエコシステム全体の利益を考慮

## 3. 仕様の良し悪しを測る方法

新しい仕様や変更を評価する際の基準です。

### 3.1 性能面での評価

- **測定項目**: 解析速度（行/秒）、メモリ使用量（ピーク・平均）、スケーラビリティ（ファイルサイズ対応性）
- **合格基準**: 一般的なパーサジェネレータ（ANTLR、PEG.js等）と同等以上の性能
- **評価方法**: 実際のソースコード（1KB〜10MB）での測定、100回実行での平均値

### 3.2 使いやすさの評価

- **測定項目**: 学習時間（基本概念習得まで）、コード記述量（同じパーサを実装する場合）、エラー頻度（初学者の躓きポイント）
- **合格基準**: プログラミング経験者が基本的なパーサを1日で実装できる
- **評価方法**: 5名以上での実装タスク測定、エラーログ分析

### 3.3 保守性の評価

- **測定項目**: 仕様の一貫性（命名規則・概念モデル）、実装の複雑度（循環複雑度）、テストの容易さ（カバレッジ達成率）
- **合格基準**: 仕様変更時に影響を受けるファイル数が全体の30%以下
- **評価方法**: 静的解析ツールでの複雑度測定、変更影響分析

## 4. 成功の姿

Reml プロジェクトが目指す具体的な成功像です。

### 4.1 開発者体験での成功

- **短期目標（1年以内）**: 標準的なDSL（JSON、CSV、設定ファイル）のパーサ実装時間が他ツール比50%短縮
- **中期目標（2-3年）**: Reml言語仕様の全機能を使ったセルフホストコンパイラの完成
- **長期目標（5年以内）**: 商用プロダクトまたはOSSプロジェクトでの本格採用事例10件以上

### 4.2 技術面での成功

- **性能**: 10万行のソースコード解析が標準的ハードウェア（8GB RAM、4コアCPU）で1秒以内
- **安定性**: 型チェック通過後の実行時エラー発生率0.01%以下
- **互換性**: Unicode 15.0以降への準拠、UTF-8/UTF-16エンコーディング対応

### 4.3 エコシステムでの成功

- **ツール連携**: VS Code、IntelliJ、Vim/Neovim向けの言語サーバー提供
- **コミュニティ**: 月100投稿以上のフォーラム活動、年4回以上のコミュニティイベント開催
- **教育**: 大学・専門学校での言語処理系講義での採用3校以上

## 5. 想定する利用シナリオ

設計判断時に念頭に置くべき、典型的な利用場面です。

### 5.1 主要シナリオ（最重視）

- **実用ツール開発**: コンパイラ、インタープリター、コード解析ツール
- **DSL構築**: ドメイン固有言語の迅速な開発と運用
- **プロトタイピング**: 言語設計のアイデア検証と実験

### 5.2 副次シナリオ（配慮対象）

- **教育用途**: プログラミング言語論の学習教材
- **研究用途**: 新しい言語機能や最適化手法の実験
- **趣味開発**: 個人プロジェクトでの言語処理

## 6. この指針の使い方

### 6.1 日常的な仕様検討で

- 新機能追加時: 1. の価値観に照らして必要性を判断
- 設計選択時: 2. の判断フレームワークを適用
- 品質確認時: 3. の評価基準でチェック

### 6.2 重要な決定で

- 大きな仕様変更: 4. の成功像への影響を評価
- 方針転換: 5. のシナリオへの適合性を確認
- 優先度変更: この指針自体の見直しが必要か検討

### 6.3 指針の更新

この指針も プロジェクトの成熟に合わせて更新していきます：

- **四半期ごと**: 価値観の優先度と実際の判断実績の整合性確認
- **年1回**: 成功指標の達成状況評価と次年度目標の設定
- **重要な転換点**（仕様凍結、メジャーリリース等）: 指針全体の見直しと改定

---

*この文書は Reml プロジェクトの北極星として、一貫した設計判断を支援します。迷った時は、この指針に立ち返って方向性を確認してください。*
