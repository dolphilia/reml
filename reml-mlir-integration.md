# RemlにおけるMLIR導入検討メモ

## 背景
- Remlは現在、Core IRから独自MIRを経てLLVM IRを生成し、既存のJIT実行器へ渡している。
- MIR段階の最適化やSSA化をより体系化し、将来的なバックエンド拡張性を確保するためMLIR導入の可否を検討した。

## 導入メリット
- LLVMエコシステムとの親和性が高く、MLIRダイアレクトをLLVMダイアレクトへLowerすれば既存JITフローを維持できる。
- SSA構築やCFG変換など、既存MIRで独自実装している処理をMLIR標準パスへ委譲でき、最適化資産を再利用しやすい。
- パターンリライティングや属性管理が標準化され、将来のGPU／SIMD／専用ハード向け後端にも拡張しやすい。

## 主な影響領域
- **型表現**: HM型推論や効果注釈をMLIR型／属性で保持する設計が必要。TypeAttrやカスタムダイアレクト型で対応する案が現実的。
- **Core→IR変換**: 既存CoreノードをReml専用MLIRダイアレクトのOpsに対応づける。`match`やADTはカスタムOps化または事前Lowerが必要。
- **最適化パス**: モノモルフィゼーションやクロージャ環境解析など、言語依存ロジックは残るが、DCEやCSE等CFG系はMLIR Pass Managerで統一可能。
- **実行統合**: MLIR ExecutionEngine利用も可能だが、当面はLLVMダイアレクトへLowerし既存のLLVM IR実行器へ接続するのが移行の摩擦が小さい。

## 移行ステップ案
1. **PoC設計**: Coreの基本構成要素（let/if/call/alloc/ret）に対応するReml DialectをTableGenで定義し、型・属性の表現方針を固める。
2. **Lowering MVP**: OCaml版コンパイラでMIR生成前にMLIRへ直接Lowerし、LLVMダイアレクトへ変換したうえで`mlir-translate`経由でLLVM IRを生成、既存ランタイムで動作確認する。
3. **最適化移植**: 現行MIR最適化のうちCFGベースのものをMLIRパスとして再実装し、効果・型情報を属性で伝搬させる仕組みを検証する。
4. **機能拡張**: パターンマッチ、代数的データ型、クロージャ環境など複雑機能を順次ダイアレクトへ取り込み、必要に応じ複数ダイアレクトに分割する。
5. **Self-host準備**: Reml実装からMLIR C APIを呼び出すFFI層を整備し、Self-hostコンパイラ移行時にも同一フローを利用できるようにする。

## リスク・課題
- MLIR C API／FFIを介したOCaml連携の実装コストが高く、PoC段階で工数と性能の見積もりが必要。
- MLIR更新と同期するためにLLVMバージョン固定やCIでの`mlir-opt/translate`実行が必須になり、ビルドパイプラインが複雑化する。
- 効果システムや型クラス辞書渡しなどReml固有のメタ情報をMLIR内で完結させにくい可能性があり、設計次第では従来のメタデータを併用する必要がある。
- チーム内のMLIR知見が乏しい場合、立ち上げ期間の生産性低下を前提にスケジュールを組む必要がある。

## 推奨アクション
- Coreのサブセットを対象とするPoCを短期間で実施し、LLVM IR互換性と最適化効果を定量的に評価する。
- PoC結果を踏まえて、MIRを完全置き換えるロードマップと、ハイブリッド（部分導入）案の比較検討を行う。
- PoCで得られた知見を元に、MLIR導入による開発体制やCIの変更点、必要なトレーニングを明文化する。
