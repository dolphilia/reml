# Reml プロジェクトの目的と設計指針

この文書は、Reml の仕様を検討・決定する際の判断基準を提供します。設計で迷った時や、複数の選択肢がある時に、何を優先すべきかの指針として活用してください。

## 1. Reml が大切にする価値観

Reml の設計では、以下の価値観を重視します。優先度順に整理されており、上位の原則ほど妥協できません。

### 絶対に守るべき原則（最優先）

#### 1.1 実用に耐える性能

- **何を目指すか**: 学習・試作用途だけでなく、実世界の商用システムで安心して使える性能を確保する
- **具体的な基準**:
  - 解析速度: 10MBのソースファイルを線形時間（O(n)）で処理
  - メモリ使用量: 入力サイズの2倍以下でピークメモリを抑制
  - スケーラビリティ: 1KBから50MBまで安定した性能特性

#### 1.2 安全性の確保

- **何を目指すか**: プログラムが予想外の動作をしたり、実行中にクラッシュする可能性を最小化する
- **具体的な基準**:
  - 型安全性: コンパイル時に型エラーを100%検出
  - メモリ安全性: バッファオーバーフロー、メモリリーク、ダングリングポインタの防止
  - 例外機構: 未キャッチ例外によるクラッシュを防ぐため、`Result`型でのエラーハンドリングを採用

### 強く推奨する原則（高優先）

#### 2.1 書きやすく覚えやすい言語

- **何を目指すか**: 一般的なプログラマーが直感的に理解でき、記憶負荷が少ない言語設計（段階的習得による複雑性管理）
- **具体的な基準**:
  - 構文簡結性: 核となる構文要素は15種類以下（変数宣言、関数定義、条件分岐等）
  - ネスト深度: ブロックのネストは3階層までを推奨
  - 命名一貫性: snake_case、camelCase等の一貫した規則を全ライブラリで適用
  - 段階的習得: 基本利用（30分以内）→ 簡単なDSL作成（1日以内）→ 実践的DSL設計（段階的拡張、DSL設計スキルの段階的習得を含む）

#### 2.2 分かりやすいエラーメッセージ

- **何を目指すか**: エラーが発生した際、開発者が素早く問題を特定して修正できる診断情報を提供
- **具体的な基準**:
  - エラー位置: 行番号、列番号、問題のあるトークンを明示
  - 期待値情報: 「`{` が期待されましたが、`;` が見つかりました」のような具体的な説明
  - 修正候補: タイポの可能性がある場合は「もしかして: `length` ではなく `lenght`?」のような提案

#### 2.3 段階的な抽象化拡張（代数的効果など）

- **何を目指すか**: Reml らしい可読性と安全性を保ちながら、代数的効果のような高度な抽象化を段階的に採用できるようにする。
- **具体的な基準**:
  - 基本利用者が「純粋関数 + 効果タグ」の理解で Reml を使い続けられること。高度な抽象化は opt-in で提供し、既存コードは変更なしに動作する。
  - 新しい概念は段階的習得モデル（入門 30 分 → DSL プロトタイプ 1 日 → 上級機能）を保ちながら、必要時に掘り下げられる導線を整備する。
  - 仕様書とランタイムは実験段階→正式統合までのプロセス（実験フラグ、PoC、安定版）を明示し、互換性とロールバックの方針を合わせて記載する。
- 代数的効果を導入しても `@pure` や `@dsl_export` など既存契約が破綻しないよう、残余効果判定と Capability Registry の整合ルールを同時に定義する。

#### 2.4 Capability Stage とブリッジ整合

- **何を目指すか**: Capability Registry・Runtime Bridge・DSL プラグインが同じ Stage/監査ポリシーで統合され、機能昇格やロールバックの判断が一貫して行える状態を維持する。
- **具体的な基準**:
  - Stage の厳密性: `StageRequirement::{Exact, AtLeast}` に基づき、`verify_capability_stage` と `RuntimeBridgeRegistry` の検証結果が [3-6 診断と監査](3-6-core-diagnostics-audit.md) の `effects.contract.stage_mismatch` / `bridge.stage.*` 診断へ即時反映されること。
  - 監査ログの整合: `AuditEnvelope.metadata` に `effect.stage.required`・`bridge.reload` など共通キーを記録し、`RuntimeBridgeAuditSpec`（[3-8-core-runtime-capability.md](3-8-core-runtime-capability.md) §10）と同一のエビデンスでレビューできること。
  - DSL プラグイン連携: [4-7-core-parse-plugin.md](4-7-core-parse-plugin.md) の署名検証・Bundle 契約が `Capability Stage` 下限と衝突しないよう `../notes/dsl-plugin-roadmap.md` のチェックリストで昇格条件を共有する。
  - 実行ストリームとの同居: `DemandHint` や `FlowController` を利用するストリーミング実行（[2-7-core-parse-streaming.md](2-7-core-parse-streaming.md)）でも同一 Stage ポリシーを適用し、バックプレッシャー制御と Capability 監査が競合しないこと。

### 目指すべき原則（中優先）

#### 3.1 Unicode対応の充実

- **何を目指すか**: 世界中の文字・言語で書かれたテキストを正しく処理できる国際化対応
- **具体的な基準**:
  - 文字モデル: UTF-8バイト列、Unicodeコードポイント、書記素クラスターの3層構造で処理
  - 正規化: Unicode正規化形式（NFC、NFD、NFKC、NFKD）に対応
  - 絵文字サポート: 絵文字シーケンス（👨‍💻等）を一つの文字として扱う

#### 3.2 エコシステム統合とDSLファーストアプローチ

- **何を目指すか**: 開発者が既存のワークフローに組み込めるとともに、Core.Parseを活用したドメイン特化言語による開発パラダイムを実現する
- **具体的な基準**:
  - エディタ連携: Language Server Protocol (LSP) 実装で自動補完、シンタックスハイライト、リアルタイムエラー表示を提供
  - ビルドシステム: JSON形式の構造化ログでCI/CDツールと連携
  - DSLファーストアプローチ: Core.Parse、Core.Ffi、Core.Asyncを活用したドメイン特化言語による開発フロー支援
  - 拡張性: プラグインAPIでカスタムリントルールやコードジェネレータの組み込みをサポート

## 2. 設計で迷った時の考え方

仕様の選択肢が複数ある場合は、以下の質問に順番に答えて判断してください。

### ステップ1: 安全性・性能への影響

**主質問**: この選択は以下のリスクを引き起こすか？

- 実行時エラー（ヌルポインタ参照、配列越境、型キャスト失敗等）
- 性能劣化（線形から二乗の計算量増加、メモリリーク等）
- セキュリティホール（バッファオーバーフロー、コードインジェクション等）

**判断**:

- **リスクあり**: 安全性を最優先とし、リスクのない選択肢を採用
  - プラットフォーム固有の最適化（例: SIMD / WASM 切替）を導入する場合は、`RunConfig` と `@cfg` の分岐が常に安全なフォールバックを持つか確認する。`../guides/portability.md` のチェックリストで未対応ターゲットへの影響を点検する。
- **リスクなし**: ステップ2へ進む

### ステップ2: 学習コストと段階的導入

**主質問**: この選択肢は Reml の段階的習得モデルを壊さないか？ 新機能を無効化した場合でも既存利用者が迷わないか？

**判断**:

- **段階的習得を維持**: 実験フラグや opt-in API を前提に導入し、ドキュメントには基礎 → 応用への導線を明示する。LSP や診断の挙動も段階に合わせて切り替え可能にする。
- **維持できない**: 仕様を分割して段階的に公開する、または基盤仕様から切り離した補遺・ガイドで提供する。両立が難しい場合は導入優先度を下げる。

### ステップ3: 学習・使用コストの比較

**主質問**: 以下の視点でどちらが優れているか？

**学習コストの比較**:

- 既存のプログラミング言語で似たような機能があるか？
- 概念を理解するために必要な予備知識はどの程度か？
- コード例を見ただけで動作を推測できるか？

**使用コストの比較**:

- 同じ処理を実現するためのコード量はどちらが少ないか？
- エラーを起こしやすい落とし穴があるか？
- IDEの支援（自動補完、リファクタリング）を実装しやすいか？

**判断基準**: 3年以上のプログラミング経験を持つ人が30分以内に理解できる

**迷う場合**: より単純で一貫性のある選択肢を採用

### ステップ4: 将来性・拡張性の検討

**主質問**: 長期的な観点でどちらが適切か？

**拡張性の評価**:

- 新しい機能を追加する際、修正が必要な範囲はどの程度か？
- サードパーティライブラリやツールとの統合は容易か？
- 仕様変更が既存コードに与える影響はどの程度か？

**互換性の評価**:

- メジャーバージョンアップ時の移行コストはどの程度か？
- 言語仕様の安定化後にも変更が必要になる可能性はあるか？
- 一度採用したら後から変更するのが困難な設計か？

**判断基準**: 5年後でも使い続けられる設計か

**それでも迷う場合**: プログラミング言語理論で実績のある選択肢を採用

### 特別な判断が必要な場合

以下の状況では、通常の優先度を一時的に変更して判断します：

- **セキュリティ関連**: 安全性を最優先とし、性能や利便性を犠牲にしてでも安全な選択肢を採用
- **標準仕様適合**: Unicode、RFC、ISO等の業界標準に合わせ、独自仕様による利便性向上よりも互換性を重視
- **エコシステム連携**: 既存ツールチェーンとの連携を重視し、単体での最適化よりもエコシステム全体の利益を考慮
- **DSLファーストアプローチ採用時**: 学習コストと長期利益のバランスを重視し、小規模プロジェクトでは直接実装も考慮

## 3. 仕様の良し悪しを測る方法

新しい仕様や変更を評価する際の基準です。

### 3.1 性能面での評価

- **測定項目**: 解析速度（行/秒）、メモリ使用量（ピーク・平均）、スケーラビリティ（ファイルサイズ対応性）
- **合格基準**: 一般的なパーサジェネレータ（ANTLR、PEG.js等）と同等以上の性能
- **評価方法**: 実際のソースコード（1KB〜10MB）での測定、100回実行での平均値

### 3.2 使いやすさの評価

- **測定項目**: 学習時間（基本概念習得まで）、コード記述量（同じパーサを実装する場合）、エラー頻度（初学者の躓きポイント）
- **合格基準**: プログラミング経験者が基本的なパーサを1日で実装できる
- **評価方法**: 5名以上での実装タスク測定、エラーログ分析

### 3.3 保守性の評価

- **測定項目**: 仕様の一貫性（命名規則・概念モデル）、実装の複雑度（循環複雑度）、テストの容易さ（カバレッジ達成率）
- **合格基準**: 仕様変更時に影響を受けるファイル数が全体の30%以下
- **評価方法**: 静的解析ツールでの複雑度測定、変更影響分析

## 4. 成功の姿

Reml プロジェクトが目指す具体的な成功像です。

### 4.1 開発者体験での成功

- **短期目標（1-2年以内）**: 標準的なDSL（JSON、CSV、設定ファイル）のパーサ実装時間が他ツール比50%短縮、DSLファーストアプローチによるプロトタイプ作成が数日以内
- **中期目標（3-5年）**: Reml言語仕様の全機能を使ったセルフホストコンパイラの完成、Core.Ffi・Core.Asyncを活用した複合DSLシステムの実現
- **長期目標（5年以内）**: 商用プロダクトまたはOSSプロジェクトでの本格採用事例10件以上

### 4.2 技術面での成功

- **性能**: 10万行のソースコード解析が標準的ハードウェア（8GB RAM、4コアCPU）で1秒以内、DSL実行時のオーバーヘッドは直接実装比20%以内
- **安定性**: 型チェック通過後の実行時エラー発生率0.01%以下
- **互換性**: Unicode 15.0以降への準拠、UTF-8/UTF-16エンコーディング対応

### 4.3 エコシステムでの成功

- **ツール連携**: VS Code、IntelliJ、Vim/Neovim向けの言語サーバー提供
- **コミュニティ**: 月100投稿以上のフォーラム活動、年4回以上のコミュニティイベント開催
- **教育**: 大学・専門学校での言語処理系講義での採用3校以上

## 5. 想定する利用シナリオ

設計判断時に念頭に置くべき、典型的な利用場面です。

### 5.1 主要シナリオ（最重視）

- **実用ツール開発**: コンパイラ、インタープリター、コード解析ツール
- **DSL構築・統合**: Core.Parseによるドメイン特化言語の迅速な開発と外部システム連携
- **プロトタイピング**: 言語設計のアイデア検証と実験

### 5.2 副次シナリオ（配慮対象）

- **教育用途**: プログラミング言語論の学習教材
- **研究用途**: 新しい言語機能や最適化手法の実験
- **趣味開発**: 個人プロジェクトでの言語処理

## 6. この指針の使い方

### 6.1 日常的な仕様検討で

- 新機能追加時: 1. の価値観に照らして必要性を判断
- 設計選択時: 2. の判断フレームワークを適用
- 品質確認時: 3. の評価基準でチェック

### 6.2 重要な決定で

- 大きな仕様変更: 4. の成功像への影響を評価
- 方針転換: 5. のシナリオへの適合性を確認
- 優先度変更: この指針自体の見直しが必要か検討

### 6.3 指針の更新

この指針も プロジェクトの成熟に合わせて更新していきます：

- **四半期ごと**: 価値観の優先度と実際の判断実績の整合性確認
- **年1回**: 成功指標の達成状況評価と次年度目標の設定
- **重要な転換点**（仕様凍結、メジャーリリース等）: 指針全体の見直しと改定

---

*この文書は Reml プロジェクトの北極星として、一貫した設計判断を支援します。迷った時は、この指針に立ち返って方向性を確認してください。*
