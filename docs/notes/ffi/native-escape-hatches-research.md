# リサーチ: Reml 実装のためのネイティブエスケープハッチ

## 1. 概要

本文書では、Reml の「エスケープハッチ（escape hatches）」、すなわち開発者がコア言語の抽象化を迂回して基盤となるハードウェアやオペレーティングシステムにアクセスするための仕組みについて探求します。これらは、`0-1-project-purpose.md` で定義された「実用に耐える性能 (1.1)」および「エコシステム統合 (3.2)」という目標を達成するために極めて重要です。

`Core.Ffi` と `Core.Async` は堅牢な相互運用性を提供しますが、低レベルのパフォーマンスチューニング（SIMD、カスタマイズされたアセンブリ）や深いシステム統合（システムコール、埋め込み）に関してはギャップが残っています。

## 2. エスケープハッチの現状

### 2.1 外部関数インターフェース (`Core.Ffi`)
- **ステータス**: Stable/Beta (仕様: [3-9](../../spec/3-9-core-async-ffi-unsafe.md))
- **機能**: C-ABI 互換の動的ライブラリを呼び出す。
- **安全性**: `effect {ffi, unsafe}`、`CapabilityRegistry` によるチェック、および必須の監査ログ（Audit Logging）を通じて管理される。
- **制約**: 関数呼び出しのオーバーヘッド（トランポリン/マーシャリング）が発生する。特定の CPU 命令をインラインで生成できない。外部の `.so`/`.dll` ファイルに依存する。

### 2.2 コンパイラプラグイン (`Core.Parse.Plugin`)
- **ステータス**: Draft (仕様: [5-7](../../spec/5-7-core-parse-plugin.md))
- **機能**: パーサおよび診断システムを拡張する。
- **安全性**: `PluginRegistrar` と制限された `EffectScope` によってサンドボックス化されている。
- **制約**: 主にコンパイル時の構文拡張を目的としており、実行時のネイティブ実行の変更には向かない。

### 2.3 ランタイム統合
- **ステータス**: Phase 1 Minimal (計画: [1-5](../plans/bootstrap-roadmap/1-5-runtime-integration.md))
- **機能**: 基本的な `libc` ラッパー（`malloc`, `free`）および RC（参照カウント）ヘルパ。
- **制約**: ホスト C++ アプリケーション（例: スクリプティングレイヤとして）に Reml ランタイムを埋め込むための公開 API が存在しない。

## 3. 欠けているネイティブ機能（"ギャップ"）

「実世界の商用システムでの利用」という目標を満たすためには、以下のメカニズムが必要と思われますが、現在の仕様には欠けています。

### 3.1 インラインアセンブリ (`asm!`)
- **ユースケース**: SIMD 最適化（プリミティブでカバーされない場合）、特定の CPU 命令（例: `cpuid`, `rdtsc`）、または OS カーネル開発。
- **コンセプト**:
  ```reml
  unsafe {
      asm!("mov rax, 1", "syscall", outputs(...), inputs(...));
  }
  ```
- **リスク**: 移植性が完全に損なわれる。安全性の検証が困難。
- **緩和策**: `effect {unsafe, native}` を要求する。`@cfg(target_arch = "...")` でガードする必要がある。
- **Phase 4 方針**: Phase 4 では設計 + ガード付き PoC に限定し、`feature = "native-unstable"` と `@cfg(target_arch/target_os)` の併用を必須にする。フロントエンドは解析のみ、バックエンドはビルドガードが無効のままでは実行不可とし、`native.unstable.disabled` を返す。

### 3.2 コンパイラ組み込み関数 (`Core.Native`)
- **ユースケース**: LLVM Intrinsics（例: `llvm.memcpy`, `llvm.ctpop`, `llvm.x86.avx.*`）を Reml 関数として公開する。
- **コンセプト**:
  ```reml
  @intrinsic("llvm.sqrt.f64")
  fn sqrt(x: f64) -> f64
  ```
- **メリット**: インラインアセンブリよりも安全で移植性が高い。コンパイラが意味論（読み取り/書き込み効果）を理解できる。
- **優先度**: **高**。完全なインライン ASM よりも実装が容易で、最適化ニーズの 90% をカバーできる。

### 3.3 直接的 OS システムコール
- **ユースケース**: 静的バイナリ（libc 依存なし）、高性能 I/O (io_uring)、名前空間コンテナ。
- **コンセプト**:
  ```reml
  syscall(SYS_write, fd, buf, len);
  ```
- **代替案**: 通常は `libc` への FFI 経由で処理されるが、「直接システムコール」はシステムプログラミングのニッチな領域で価値がある。

### 3.4 ランタイム埋め込み API (Hosting)
- **ユースケース**: Unity ゲームや C++ エンジン内部で、構成/ロジック DSL として Reml を使用する。
- **コンセプト**:
  ```c
  // ホスト C コード
  reml_ctx_t* ctx = reml_create_context();
  reml_load_source(ctx, "...");
  reml_call_function(ctx, "update", delta_time);
  ```
- **優先度**: **高** ("DSL First" アプローチの採用に向けて)。

### 3.5 LLVM IR 直接埋め込みと属性制御
- **ユースケース**: インラインアセンブリの「移植性欠如」を回避しつつ、Reml コンパイラが生成するコードよりも効率的な IR パターンを手書きしたい場合。あるいは、`musttail` (末尾呼び出し最適化強制) や `cold` (分岐予測ヒント) など、Reml 言語仕様として昇格していない LLVM 機能を即座に利用したい場合。
- **コンセプト**:
  ```reml
  unsafe {
      // 仮想的な構文: LLVM IR を直接記述して値を返す
      let result = llvm_ir!(i32) {
          "%1 = add nsw i32 $0, $1",
          inputs(a, b)
      };
  }
  
  // LLVM 属性の直接指定
  @llvm_attr("alwaysinline") 
  fn critical_path() { ... }
  ```
- **メリット**: CPU アーキテクチャ（x86, ARM, RISC-V）に依存しないため、インラインアセンブリよりも移植性を維持しやすい。
- **リスク**: LLVM の内部表現（opaque pointers 等）の変更に影響を受ける可能性があるが、アセンブリよりは抽象度が高い。
- **Phase 4 方針**: LLVM IR 直書きは `feature = "native-unstable"` の背後に置き、Phase 4 ではビルドガードにより無効化する（解析のみ）。`@cfg(target)` でターゲット限定の明示が必須。

## 4. 提案と分析

### 4.1 提案する "Native" レイヤ
これらの機能を収容するために、`Core.Native` モジュール（または `Core.Intrinsics`）を導入すべきです。

| 機能 | 効果タグ | 監査要件 | 移植性戦略 |
| :--- | :--- | :--- | :--- |
| **Intrinsics** | `effect {native}` | 中 | サポートされていないターゲット向けのポリフィル |
| **Inline ASM** | `effect {native, unsafe}` | 高 (厳密なログ) | `@cfg` 必須 |
| **LLVM IR** | `effect {native, unsafe}` | 中 | アーキテクチャ非依存だが LLVM 依存 |
| **Syscall** | `effect {native, os}` | 高 | `@cfg` 必須 |

### 4.2 セキュリティと監査
- **効果システム**: 新しい `effect {native}`。これはハードウェア依存の *内部* 処理として、`ffi`（外部呼び出し）とは区別される。
- **監査ログ**: `asm` ブロックはその使用をログに記録しなければならない。「なぜここでアセンブリが必要だったのか？」という問いは、レビューポリシーとして有効に機能する。

#### TODO
- Phase 4 の PoC では `native.intrinsic.unstable_used` を暫定キーとして出力する前提で、`docs/spec/3-6-core-diagnostics-audit.md` に正式反映するか再検討する。

### 4.3 リスク対メリット
- **リスク**: インライン ASM は「巧妙」で可読性の低いコードを助長する。コードの移植性がなくなる。
- **メリット**: 「エスケープハッチ」により、エキスパートはホットループのために C/Rust へ降りることなく、Reml に留まることができる。

## 5. ロードマップへの推奨事項

1.  **Phase 3 (セルフホスト)**: まず **コンパイラ Intrinsics** を導入する。これにより、標準ライブラリのパフォーマンスプリミティブ（memcpy, math）を効率的に実装できる。
2.  **Phase 4**: **インラインアセンブリ** の構文を設計するが、機能フラグの背後で厳密にゲートする。
3.  **Phase 4/5**: Reml を「ゲスト」言語として機能させるための **埋め込み API** (`libreml` 共有ライブラリ) を定式化する。

## 6. 結論

「実用性」という目標を満たすために、Reml は型システムでは表現できないハードウェア機能へアクセスする方法を提供しなければなりません。
- **直近のアクション**: `Core.Native` に向けた LLVM intrinsic マッピングの調査、および LLVM IR 埋め込みの実現性評価。
- **将来のアクション**: 商用統合シナリオに向けた "Embedding API" 仕様のドラフト作成。
