# Reml Versioning Strategy Research

## 1. はじめに

本ドキュメントは、Reml 言語におけるバージョニング戦略の調査と提案をまとめたものです。
Reml は「言語仕様」「コンパイラ実装」「標準ライブラリ」「ABI/ランタイム」「エコシステム」という複数のレイヤーを持つため、単一のバージョン番号だけでは管理しきれません。
本提案では、Rust の Editions や Go の互換性保証、および Reml 独自の「Capability Stages」を考慮した、現実的かつ将来性のあるバージョニング戦略を模索します。

## 2. バージョニングのレイヤー構造

言語処理系のバージョン管理は、以下の異なるレイヤーの同期問題として捉える必要があります。

1.  **Language Specification (言語記法・セマンティクス)**
    *   ユーザーが書くソースコードの解釈。
    *   **課題**: 後方互換性を保ちつつ、古い設計ミスを修正したい。
2.  **Compiler Implementation (ツールとしての Reml)**
    *   CLI ツール、コンパイル速度、エラーメッセージの改善。
    *   **課題**: バグ修正や内部リファクタリングを頻繁に行いたい。
3.  **Standard Library (Core)**
    *   基本的なデータ構造や API。
    *   **課題**: コンパイラバージョンと強く結合するか、独立して更新するか。
4.  **Runtime / ABI (Binary Interface)**
    *   コンパイルされたバイナリ間の互換性。
    *   **課題**: 安全性を保証しつつ、再コンパイルの頻度を下げたい。
5.  **Ecosystem (Package Registry)**
    *   ライブラリ間の依存関係解決。
    *   **課題**: 「Reml v1.0 で書かれたライブラリ」を「Reml v2.0 プロジェクト」で使えるか？

## 3. 推奨される戦略：ハイブリッド・バージョニング

Rust の成功事例（Editions + SemVer）をベースに、Reml 固有の要件（DSL重視、Capability Stages）を加味したハイブリッド戦略を提案します。

### 3.1. コンパイラ：Semantic Versioning (SemVer)

コンパイラ単体（`reml` コマンド）は **Semantic Versioning 2.0.0** に従います。

*   **Major (X.y.z)**: 互換性のない変更（CLI オプションの削除、コンパイル済みバイナリの互換性破壊など）。
    *   *注: 言語仕様の破壊的変更はここには含めず、後述の Edition で管理することを推奨。*
*   **Minor (x.Y.z)**: 後方互換性のある機能追加、パフォーマンス改善、新しいターゲットのサポート。
*   **Patch (x.y.Z)**: バグ修正。

### 3.2. 言語仕様：Editions (エディション制)

ソースコードの互換性を長期的に維持しつつ、時にはブレーキを踏んで仕様を刷新するために「**Editions**」制を採用・拡張します。

*   **仕組み**:
    *   `reml.json` (または `reml.toml`) で `edition: "2025"` のように指定する。
    *   新しい Edition は数年（例：3年）ごとにリリースされる。
    *   コンパイラは**全ての過去の Edition をサポートする**。
    *   異なる Edition のクレート（パッケージ）同士は**相互にリンク可能**である（これを保証するために ABI レイヤーでの工夫が必要）。
*   **メリット**:
    *   エコシステムを分断せず、古いコードを維持したまま新しい書き方を導入できる。
    *   `keyword` の追加など、通常なら破壊的変更になるものを安全に導入できる。

### 3.3. 機能ステータス：Capability Stages

Reml の特徴である「Capability Stages」(`Experimental` -> `Preview` -> `Stable`) は、**バージョン番号とは直交する軸**として管理します。

*   **Experimental**: フラグ必須。破壊的変更が予告なく行われる。SemVer の保証外。
*   **Preview**: デフォルトでは警告が出る、あるいは特定の設定が必要。次の Minor/Major での Stable 化を目指す。
*   **Stable**: Edition の期間中は破壊的変更を行わない。

**提案**: 各機能は「どのバージョンでどの Stage に昇格したか」の履歴を持つべきです（例: `since = "1.2.0"`）。

### 3.4. 標準ライブラリ (Core)

初期のブートストラップおよび安定化フェーズ（Phase 1-3）では、**標準ライブラリはコンパイラとバージョンを同期（同梱）させる**のが最も安全です。

*   コンパイラ `1.5.0` には `Core 1.5.0` が組み込まれる。
*   将来的にエコシステムが成熟し、コンパイラとは独立したライフサイクルが必要になった場合、「Core の分離」を検討するが、複雑さを避けるため初期は避けるべき。

### 3.5. ABI / Runtime

ABI の安定性は最も困難な課題です。

*   **当面の方針**: 同じ Major バージョンのコンパイラ間では ABI 互換を目指すが、保証はしない（Rust方式）。
    *   または、ハッシュベースの厳密なチェックを行い、少しでも異なればリンクエラーにする（安全策）。
*   **将来の方針**: Stable ABI の定義。C API を経由するインターフェースを「Stable」とし、Reml 内部表現は自由に変更できるようにする。

## 4. エコシステムとの同期

パッケージマネージャーは、以下の情報を理解する必要があります。

Allow:
```toml
[package]
name = "my-dsl"
version = "0.1.0"
edition = "2025"       # 言語仕様のバージョン
requires-reml = "^1.2" # コンパイラのバージョン要求
```

*   **edition**: パーサの挙動を決定する。
*   **requires-reml**: 使用しているコンパイラ固有の機能（バグ修正や最適化含む）への依存。

## 5. リスクと課題

### 5.1. 「言語」と「ライブラリ」の境界
ユーザー定義 DSL が活発な Reml では、「言語機能の追加」が「標準ライブラリへの DSL 追加」で済む場合があります。
*   **リスク**: 何を言語本体（Edition管理）とし、何をライブラリ（SemVer管理）とするかの線引きが曖昧になる。
*   **対策**: `Core.Parse` などの言語拡張API自体を「言語仕様」の一部として厳格に定義し、そこに乗る DSL はライブラリとして扱う。

### 5.2. 学習コストの増大
Edition が増えると、入門者が「どの Edition を学べばいいか」混乱する可能性があります。
*   **対策**: ドキュメントは常に最新 Edition をデフォルトとし、過去 Edition との差異は明確な移行ガイドとして分離する。

## 6. 結論と次のステップ

1.  **Editions 制の採用を決定する**: エコシステムの分断を防ぐ唯一の現実解であるため。
2.  **Capability Stages と SemVer のマッピング定義**: `Stable` になった機能は SemVer の保護対象となることを明文化する。
3.  **Reml コンパイラのバージョン番号規則の策定**: `0.x.y` の間の破壊的変更ポリシー（Rust のように 0.x でも SemVer に準拠するか、自由にするか）を決める。

この戦略により、Reml は「実用性」と「進化」の両立を目指すことができます。
