# 調査メモ: 関数型プログラミング言語の辛さ

## 0. 調査サマリ
- 対象: 他パラダイム経験者の関数型初学者と、関数型に熟達した開発者の双方が感じる「辛さ／大変さ」を整理。
- 方法: コミュニティで共有される経験談、既存の言語導入失敗事例、社内ベテランのヒアリング要点を統合し、Reml 仕様策定に関係する観点へ集約。[^1]
- 概観: 初学者は思考様式・型エラーとの向き合い方に苦戦し、熟練者は生産性と組織的な採用・運用コストに課題を感じる傾向が強い。
- 仕様示唆: エラー診断、命名・抽象化戦略、データ構造のコスト把握ガイドが Reml 採用障壁を下げる鍵になる。

## 1. 他パラダイム経験者の初学段階での辛さ
### 1.1 思考モデルの転換
- 破壊的更新を避けるためのイミュータビリティ指向が、手続き型から来た開発者には直感的でない。
- ループより再帰・高階関数を使う設計が、処理フローの可視化を難しく感じさせる。
- データ構造の永続性（Persistent Data Structure）がパフォーマンスの不安を招き、早期に命令的最適化を試みて破綻するケースが多い。

### 1.2 型システムとエラー理解
- 高階型（`Result<Option<T>>` など）がネストすると、どこで失敗が起きたかを把握しづらい。
- 型推論エラーが長文メッセージになり、エラー箇所より型推論の経緯を説明される点に精神的負荷がかかる。
- モナド・アプリカティブなど抽象概念の説明が圏論的用語に依拠する場合、概念理解より記号の意味解読に時間を費やす。

### 1.3 副作用と状態管理
- IO／状態操作が `Effect` や `IO` 型に閉じ込められるため、「簡単なログ出力」にも特別な構文やラッピングが必要。
- 実行順序を自分で制御する必要があり、Promise/Future 系の命令的非同期モデルと行き来する際に混乱を生む。

### 1.4 ツールとデバッグ体験
- 遅延評価やシングルステップの困難さで、ブレークポイントやウォッチ変数に頼れない。
- 学習資料が抽象度の高い表現に終始し、具体的なアンチパターンや失敗例を見つけづらい。

## 2. 経験豊富な関数型開発者が挙げる継続的な課題
### 2.1 性能・最適化
- 永続データ構造やボクシングによる GC プレッシャーを抑えるため、低レベルチューニングと高レベル設計の両立が難しい。
- 並列化は便利だが、評価戦略（遅延／正格）の不一致でホットスポットが読みにくい。

### 2.2 抽象のコストと可読性
- 型クラス、モジュールファンクタ、トレイトオブジェクトの設計が行き過ぎると、後から参加したメンバーが追従できない。
- 抽象の再利用性が高い一方で、業務要件が変わると抽象レイヤ全体を張り替える必要が生じ、改修工数が極端に増える。

### 2.3 エコシステム・相互運用
- 命令的なライブラリを直接利用するには FFI やラッパーを書く必要があり、保守コストが高い。
- ビルドツールやデプロイ基盤がマイナーである場合、CI/CD への統合でワークアラウンドが増える。

### 2.4 組織導入・教育
- 採用市場で関数型経験者が少なく、チーム内教育に多くの時間を要する。
- 仕様変更や障害対応で関数型特有の概念（モナド変換子、エンコーディングなど）を説明する負担が継続する。

### 2.5 デバッグと運用監視
- 例外ではなく `Result` 連鎖に失敗情報が埋まるため、ログに十分な文脈を残さないと分析が困難。
- プロファイラやトレーサが命令型言語に比べ成熟しておらず、遅延評価や効果ハンドラと組み合わせた分析ツールが不足している。

## 3. Reml 仕様検討への含意
- エラー診断で「意図してほしい修正」を提示できるかが初学者支援の要。型エラーの最小差分・候補関数提案を仕様で規定する価値が高い。
- 持続的な性能観測の仕組み（例: `AuditSink` ベースのプロファイル収集）を標準化することで、熟練者の運用課題を緩和できる。
- 副作用処理・IO を伴うパターンをガイドライン化し、`Effect` / `Capability` 設計をサンプルとともに提供することで学習コストを下げる。
- 永続データ構造の計測ベンチやアンチパターン集を `docs/notes/` で共有し、抽象のコストを早期に可視化する必要がある。

## 付記: 今後の追加調査候補
- Haskell / OCaml / F# / Elixir の導入障壁と成功要因の比較表を作成し、Reml の API 設計へフィードバックする。
- 関数型と命令型を併用するチームへのヒアリングテンプレートを整備し、運用上の課題を定量化する。
- 初学者向けに「よくある失敗例とリカバリ手順」を収集し、`docs/guides/` 配下に導入ガイドを拡充する。

[^1]: 関連資料: [Reml 言語の影響分析](reml-language-influences-analysis.md)、[標準ライブラリ章 骨子](core-library-outline.md) に記録された要件抽出ノート。

## 4. Reml仕様改善プラン

### 4.1 言語仕様（Chapter 1/2）
- **命令スタイルから宣言スタイルへの橋渡しを明文化**: `1-0-language-core-overview.md` に習得フェーズ表、`1-1-syntax.md` C.4 を基に `for`/`Iter` 相互変換の比較表とベストプラクティス節を追加し、初学者がイミュータブル設計へ移行する際の思考手順を示す。[^2]
- **型エラー診断チュートリアルの追記**: `1-2-types-Inference.md` に `Result<Option<T>>` の失敗経路を解く手順を追加し、`2-5-error.md` で `ExpectationSummary` と FixIt を活用した実例を掲載して LSP/CLI 表示の読み解き方を明文化する。[^3][^4]
- **効果ハンドリングのクックブック化**: `1-3-effects-safety.md` に `IO`・`audit`・`mut` 組み合わせ別の設計テンプレートと、`@handles`/`@requires_capability` の適用判断チェックリストを追加し、初学者の副作用設計負荷を下げる。[^3]
- **学習導線の概観節を追加**: `1-0-language-core-overview.md` に「最初の 30 日ロードマップ」節を追加し、関連ガイドやサンプルへのリンクを整理する。[^2]

### 4.2 標準ライブラリ（Chapter 3）
- **`Result`/`Option` の観測補助を標準化**: `3-1-core-prelude-iteration.md` に `tap_diag`/`ensure` の組み合わせ事例やログ整形ユーティリティを追記し、エラー連鎖のトレースを容易にする。[^5][^7]
- **永続コレクションのコスト可視化**: `3-2-core-collections.md` に Big-O とメモリ挙動の早見表、`Vec` への脱線時の注意喚起、および `CollectError` → `Diagnostic` 変換の規約を追加する。[^6]
- **診断と監査のセットアップ手順を文書化**: `3-6-core-diagnostics-audit.md` に CLI/LSP/監査ログの三点セット構築手順と推奨 `AuditPolicy` プリセットを追加し、熟練者の運用コストを削減する。[^7]
- **Capability ベースの計測テンプレート**: `3-8-core-runtime-capability.md` に `MetricsCapability`/`AuditCapability` を組み合わせたプロファイル収集フローと `Stage` 運用のサンプルマニフェストを追加する。[^8]

### 4.3 プラグイン仕様（Chapter 4）
- **効果診断拡張の必須実装チェックリスト**: `4-1-system-plugin.md` を起点に、公式プラグインは `Diagnostic.extensions["effects"]` と `audited_syscall` を必ず実装する旨を記載し、`CapabilitySecurity` との整合チェック手順を追補する。[^8][^10]
- **ラッパーAPIの宣言的パターン提示**: プロセス・メモリ等の各プラグイン章に `Result` ベースのラッパー例と `Effect` 宣言の雛形を追加し、命令的ライブラリを扱う際の共通テンプレートを提供する。[^10]
- **テスト/監査テンプレートを付録化**: 監査のモックと `AuditSink` 連携方法を共有付録へまとめ、プラグイン開発者が同一の検証セットを利用できるようにする。[^7]

### 4.4 エコシステムとガイド（Chapter 5 / guides）
- **IDE/LSP での「型エラー読み解き」体験を強化**: `5-3-developer-toolchain.md` に LSP ダイアログ例と `PublishDiagnostics` のガイド付きスクリーンショットを追記し、初学者が UI で確認すべきポイントを明示する。[^9]
- **新規ガイド `docs/guides/fp-transition.md`（仮）を追加**: 既存の `docs/guides/dsl-first-guide.md` と連携し、命令的思考→関数的思考へのステップ、`Iter` チェーンのリファクタ例、`Effect` 設計の FAQ を掲載する。本文完成後は README のガイド一覧にリンクを追記する。[^2][^5]
- **学習リファレンスの索引整備**: README と `0-2-glossary.md` に新規用語（例: 「評価戦略デバッグ」「効果ステージ」）を追加し、関連章ヘの相互参照を更新する。[^2][^3][^7]

### 4.5 実行順序の提案
1. `1-1`/`1-3` の追加節ドラフトを作成し、初学者視点のレビューを受ける。
2. `3-1`/`3-6`/`3-8` の改善を行い、エラー・監査の観測パイプラインを例示。
3. プラグイン章と新ガイドを並行更新し、`CapabilityRegistry` 連携の共通テンプレートを確立。
4. README・用語集・索引を更新し、学習導線を一本化。

[^2]: 1-0-language-core-overview.md:1-13、1-1-syntax.md:382-412。
[^3]: 1-3-effects-safety.md:1-153。
[^4]: 2-5-error.md:1-200。
[^5]: 3-1-core-prelude-iteration.md:1-189。
[^6]: 3-2-core-collections.md:1-160。
[^7]: 3-6-core-diagnostics-audit.md:1-160。
[^8]: 3-8-core-runtime-capability.md:1-180。
[^9]: 5-3-developer-toolchain.md:1-160。
[^10]: 4-1-system-plugin.md:1-160。
