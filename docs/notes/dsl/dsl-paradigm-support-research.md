# Reml における DSL パラダイムサポートに関する調査

本ドキュメントでは、Reml ベースの言語において、特定のプログラミングパラダイム（オブジェクト指向、プロトタイプベース、アクターモデル）や機能（ガベージコレクション）の実装を容易にするための新しいライブラリと機能群（「パラダイムキット」）を提案します。

## 1. 背景と目的

Reml は「Language Workbench（言語開発プラットフォーム）」を目指しています。`Core.Parse` が構文を、`Core.Lsp` がツーリングを担う一方で、動的ディスパッチやメモリ管理といった複雑な「意味論（Semantics）」の実装は、依然として DSL 作者にとって大きな負担となっています。
本提案の目的は、これらの複雑さを抽象化する**標準ライブラリとランタイムブリッジ**を提供し、DSL 作者が独自の言語設計に集中できるようにすることです。

## 2. 提案するパラダイムキット

`Core.Dsl.*` や類似の名前空間に配置される「キット」のセットを提案します。

### 2.1 Core.Dsl.Object (オブジェクト指向 & プロトタイプ)

動的ディスパッチ、継承、または委譲を必要とする言語をサポートします。

**主な機能:**
*   **`DispatchTable`**: メソッドルックアップのための標準構造。
    *   クラスベース（クラスごとの固定テーブル）とプロトタイプベース（委譲チェーン）の両モデルをサポートします。
*   **`ObjectHandle`**: DSL ランタイム内の「オブジェクト」を表す不透明なハンドル（Opaque Handle）。
    *   `DispatchTable` へのポインタとインスタンスデータを保持する構造体にマッピングされます。
*   **`MethodCache`**: 繰り返されるルックアップを高速化するための汎用インラインキャッシュ機構（動的 DSL のパフォーマンスにおける鍵となります）。

**使用例（概念イメージ）:**
```reml
// DSL ランタイムでのクラス定義
let animal_class = ClassBuilder.new("Animal")
  .method("speak", |this, args| { ... })
  .build()

// インスタンス化
let dog = animal_class.instantiate()
dog.call("speak", [])
```

### 2.2 Core.Dsl.Gc (ガベージコレクション・サポート)

Reml 自体が GC を採用するわけではなく、DSL ランタイム内での自動メモリ管理を必要とする言語をサポートします。

**主な機能:**
*   **`GcHeap`**: プラグ可能なヒープアロケータ。
    *   タイプ: `MarkAndSweep`（マーク＆スイープ）、`RefCount`（参照カウント）、`Arena`（アリーナ）。DSL の制約に応じて選択可能です。
*   **`GcRef<T>`**: `GcHeap` によって監視されるスマートポインタ。
*   **`RootScope`**: ローカル実行中にスタック値を GC ルートとして登録するためのブロックベース API。

**戦略:**
*   これらのヒープはライブラリとして実装されます（`shread` のような Rust ベースのコレクタや、シンプルなカスタム実装をラップする可能性があります）。
*   `Core.Ffi` またはネイティブ Rust 相互運用を通じて、安全な API を公開します。

**使用例（概念イメージ）:**
```reml
use Core.Dsl.Gc

// DSL のインタプリタ・ループ内
Gc.with_scope(|scope| {
  let val1 = sub_eval(expr1, scope)
  let val2 = sub_eval(expr2, scope)
  // ここで安全にガベージコレクションを実行可能
  Gc.collect_if_needed()
})
```

### 2.3 Core.Dsl.Actor (アクターモデル)

Spec 3.9 で定義されている堅牢な `Core.Async` のアクターシステムを活用し、「アクター DSL」のためのプリミティブを提供します。

**主な機能:**
*   **`ActorDefinition`**: DSL の AST（例: `actor { ... }`）を `Core.Async` の `spawn_actor` に直接マッピングするためのヘルパー。
*   **`MailboxBridge`**: `MailboxHandle` を DSL ランタイムに公開し、DSL スクリプトからの `send` や `receive` を可能にします。
*   **`SupervisionBridge`**: DSL レベルのエラーハンドリングを `SupervisorSpec` にマッピングします。

**統合:**
*   `Core.Async` は既に `ActorSystem` を持っているため、このキットは主にそれらの機能をインタプリタコードから容易に利用できるようにするための **ブリッジ（Bridge）** となります。

### 2.4 Core.Dsl.Vm (VM 構築キット)

AST インタプリタ（Tree-walker）よりも高速な実行速度を求める DSL 向けに、バイトコードインタプリタ（仮想マシン）の実装基盤を提供します。

**主な機能:**
*   **`BytecodeBuilder`**: 命令セット（Instruction Set）を定義し、AST から効率的なバイトコード列を生成するためのビルダー。オペランドのエンコーディングやラベル解決を自動化します。
*   **`VMCore`**: 「Fetch-Decode-Execute」ループの標準実装。
    *   投機的実行や JIT コンパイルへの将来的な拡張を見据えた、最適化されたディスパッチループを提供します。
    *   スタックベースおよびレジスタベースの両アーキテクチャをサポートする抽象化を含みます。
*   **`OperandStack` / `CallFrame`**: スタックマシン実装で頻出する、オペランドスタックとコールフレーム管理のための最適化されたデータ構造。

**使用例（概念イメージ）:**
```reml
// 命令セットの定義
enum Op { Push(Int), Add, Print }

// コンパイラ（AST -> Bytecode）
let code = BytecodeBuilder.new()
  .emit(Op.Push(1))
  .emit(Op.Push(2))
  .emit(Op.Add)
  .emit(Op.Print)
  .build()

// VM での実行
let vm = Vm.new(stack_size=1024)
vm.run(code)
```

## 3. 実装パス

1.  **Phase 4 拡張**:
    *   `Core.Dsl.Object`、`Core.Dsl.Gc`、`Core.Dsl.Vm` の仕様ドラフトを作成。
    *   既存の `Core.Async` インターフェースを使用して `Core.Dsl.Actor` のプロトタイプを作成。
2.  **Rust ミドルウェア**:
    *   Rust コンパイラのランタイムライブラリ内に、これらのキットのバックエンドランタイムを実装します。
3.  **検証**:
    *   キットの動作を証明するために、「リファレンス DSL」（例: OOP 向けの "Mini-Ruby"、アクター向けの "Mini-Erlang"）を作成します。

## 4. リスクと課題

*   **パフォーマンス**: ユーザー空間（または重い FFI 経由）で実装された「ライブラリ GC」は低速になる可能性があります。
    *   *緩和策*: 短命な DSL スクリプト（設定やツール系 DSL で一般的）向けに `Arena` アロケータを提供します。
*   **複雑性**: DSL 作者に GC ルート API を公開することはエラーの原因となりやすいです。
    *   *緩和策*: `Core.Diagnostics` による広範なデバッグチェックと「GC サニタイザー」モードを提供します。
*   **抽象化の漏洩**: DSL 作者が `Core.Dsl.Object` を使用することで、特定のオブジェクトモデルにロックインされないか？
    *   *緩和策*: `DispatchTable` を柔軟に保ちます（カスタムストラテジーパターン）。

## 5. まとめ

これらの「バッテリー同梱（Batteries-included）」ランタイムキットを提供することで、Reml は開発者がメモリ管理、ディスパッチ、並行処理、そして**仮想マシンによる高速な実行**のために車輪の再発明をすることなく、リッチでパラダイム特化型の言語を構築できるようにします。
