# 解説書作成の具体的プロセス

概要ドキュメント (`0-0-overview.md`) で定義された方針に基づき、調査から執筆までの具体的なフェーズとアクションプランを定めます。

## 1. 準備フェーズ (Environment & Tools)

執筆作業を効率化し、正確性を担保するための環境を構築します。

1. **対象バージョンの確定**:
    - 解説対象のコミット ID（またはタグ）を決め、冒頭に明記する。
    - 仕様は `docs/spec` の同時点に揃える。
2. **ビルド・テスト環境の確立**:
    - ルートには `Cargo.toml.ws` のみがあるため、`--manifest-path` で対象クレートを指定する。
    - 例: `cargo build --manifest-path compiler/frontend/Cargo.toml` / `cargo test --manifest-path compiler/runtime/Cargo.toml`。
    - macOS でリンクが不安定な場合は `RUSTFLAGS="-C link-arg=-fuse-ld=lld"` を利用する。
    - adapter のネットワーク試験は権限が必要なため、必要に応じて `REML_ADAPTER_SKIP_NETWORK_TESTS=1` を使う。
3. **トレーシング環境の整備**:
    - 実行時の挙動を追うために、ログ出力 (`env_logger` / `tracing`) の有効化方法を確認する（例: `RUST_LOG=trace`）。
    - 必要に応じて `dbg!` や `eprintln!` を挿入して内部構造をダンプするための「調査用パッチ」を作成する（コミットしない）。
4. **調査支援ツールの準備**:
    - 高速検索のため `rg` の利用を前提にする（ない場合は `grep`）。
    - モジュール依存可視化は `cargo tree` などを必要に応じて利用する（環境にない場合は省略）。
5. **ドキュメントツールの準備**:
    - Mermaid.js をプレビューできるエディタ環境（VS Code + Markdown Preview Mermaid Support など）。
    - ソースコードへのパーマリンクを生成するための Git 操作フローの確認。

## 2. 調査フェーズ (Investigation)

調査は「全体像（森）」から「詳細（木）」へ、そして再び「全体（森）」へと戻るサイクルで行います。

### Step 2.1: アーキテクチャ・マッピング (Macro Analysis)

- **目的**: コンポーネント間の境界線、依存関係、主要なデータフローを把握する。
- **アクション**:
  - `compiler/README.md` と各 `compiler/*/README.md` を読み、責務境界を把握する。
  - `docs/plans/source-code-commentary/1-2-module-spec-mapping.md` を確認し、章の候補と spec 対応を整理する。
  - 入口（`compiler/frontend/src/bin` など）から初期化フローを追跡する。
  - 主要フェーズ（Parse, Check, Lower, Codegen）をつなぐ共有データ構造がある場合は特定する。

### Step 2.2: コンポーネント詳細調査 (Micro Analysis)

- **単位**: 主要クレート (例: `reml_frontend`) またはモジュール単位。
- **サイクル**:
    1. **Interface Review**: `lib.rs` / `mod.rs` と公開 (`pub`) 項目を確認し、外部に対する「契約 (Contract)」を理解する。
    2. **Data Structure Analysis**:
        - 主要なデータ構造（例：AST, Type Arena, Symbol Table）の定義を読む。
        - データの所有権（Ownership）と寿命（Lifetime）のモデルを理解する（参照カウント？ アリーナ？ コピー？）。
    3. **Algorithm Tracing**:
        - 入力を受け取り、データ構造をどう変換して出力しているか、ロジックを追う。
        - 複雑なロジックについては、手元のメモ帳または `scratch.rs` で小さな再現コードを書いて動作検証する。
    4. **Verification**:
        - ソースコードの挙動が `docs/spec` の仕様と一致しているか確認する。乖離がある場合は「未実装」か「仕様変更」かを確認し、注記する。

### Step 2.3: エンドツーエンド・トレーシング (E2E Tracing)

- **目的**: 各コンポーネントが連携して一つのプログラムをコンパイルする過程を時系列で記録する。
- **アクション**:
  - **最小サンプルコード** (例: `fn main() -> Int { 0 }`) を用意する。
  - `reml_frontend` で解析し、JSON 出力や診断ログを採取する。
  - ソーステキストからバイナリになるまでの全工程でのデータ変換（AST dump, IR dump など）を記録する。
  - これを解説書の「第1章：ツアー」や各章の冒頭・末尾の実例として使用する。

## 3. 執筆フェーズ (Writing)

調査メモを体系的なドキュメントへ変換します。

### Step 3.1: 構成案の策定 (Skeleton)

- 章ごとの詳細な目次（節レベルまで）を作成する。
- 各節で解説・参照すべき具体的なファイルパス、構造体名、関数名をリストアップし、抜け漏れを防ぐ。

### Step 3.2: ドラフト作成 (Drafting)

- **Code First**: 文章を書く前に、解説対象のコードブロックやファイルへのリンクを配置する。「コードこそが真実」の原則に従う。
- **Why over What**: コードを日本語訳するのではなく、「なぜこの設計なのか」「ここでは何の問題を解決しようとしているのか」に焦点を当てる。Rust特有のイディオムが使われている場合はその意図も解説する。
- **Visualization**: 複雑なコールグラフやデータ構造の関係性は、文章で説明するよりも Mermaid 図解を作成する。
- **Spec Sync**: 章末に対応する `docs/spec` 節を明記し、差分や未実装は注記する。

### Step 3.3: レビュー (Review)

- 以下の観点でセルフチェックを行う：
  - **Traceability**: すべての主張がソースコードによって裏付けられているか？
  - **Accessibility**: Rust中級者が理解できるレベルか？（専門用語の解説はあるか？）
  - **Accuracy**: 執筆時点の最新コードと矛盾していないか？

## 4. 運用ルール

- **バージョン固定**: 解説は特定の Git Commit ID (タグ作成推奨) に基づいて記述し、冒頭にその ID を明記する。コードが更新された場合は、改訂版として別途作成するか、差分のみを追記する方針とする。
- **用語集**: 全体を通して用語の揺らぎがないよう、定義集 (`docs/spec/0-2-glossary.md`) をメンテナンスする。
- **調査用パッチ**: 解析用の変更はコミットしない。必要に応じてローカルで適用・破棄する。
