# 2.0 Phase 2 — 言語仕様の安定化

Phase 2 は OCaml 実装を用いて Reml 言語仕様の全体を検証し、MVP から正式仕様へ昇格させる工程である。型クラス・効果システム・診断メタデータなど `1-2`〜`1-3` および `3-6` に記述された要素を段階的に有効化し、パーサ/タイパ/ランタイムの仕様差異を解消する。

## 2.0.1 目的
- `1-2-types-Inference.md` に定義された型クラス制約・辞書渡し・局所型推論を OCaml 実装に反映し、セルフホスト移行前に挙動を固める。
- `1-3-effects-safety.md` の効果タグと `3-8-core-runtime-capability.md` の Stage 契約をパーサとタイプチェッカで検証し、`effect` 注釈と Capability Stage の相互整合を確立する。
- `3-6-core-diagnostics-audit.md` で定義された監査ログフォーマットを実装し、診断・監査パイプラインを安定化する。

## 2.0.2 スコープ境界
- **含む**: 型クラス/辞書渡し、代数的効果タグの静的検証、`RuntimeBridge` との Stage 整合、FFI 所有権契約の正式化、診断メタデータの出力。
- **含まない**: セルフホスト化、Reml 実装での再構築、JIT ターゲット・クロスコンパイル最適化。これらは Phase 3 以降で実施。
- **前提条件**: Phase 1 の成果物、`docs/guides/llvm-integration-notes.md` の Phase 2 要件、`docs/notes/llvm-spec-status-survey.md` で列挙された未決領域リスト。

## 2.0.3 成果物とマイルストーン
| マイルストーン | 内容 | 検証方法 | 期限目安 |
|----------------|------|----------|----------|
| M1: 型クラスサポート | 多相辞書の生成と渡しを実装し、`1-2` のサンプルを全通過 | 型推論テスト + LLVM IR での辞書引数検証 | Phase 2 開始後 6 週 |
| M2: 効果タグ検証 | `effect` アノテーションと `RuntimeCapability` の整合チェックを導入 | スタティックアナライザ + 実行時 Stage 検証テスト | 開始後 10 週 |
| M3: 診断監査基盤 | `Diagnostic` + `AuditEnvelope` 出力を仕様と同一形式で実装 | JSON スナップショットテスト + `3-6` のキー照合 | 開始後 14 週 |
| M4: 仕様レビュー完了 | Chapter 1〜3 の仕様サンプルを実行検証し、ギャップを解消 | 仕様レビュー記録（`0-3-audit-and-metrics.md`） | 開始後 18 週 |

## 2.0.4 実装タスク

> **ターゲット方針継続**: Phase 2 も Phase 1 と同様に **x86_64 Linux (System V ABI)** を主ターゲットとする。Phase 2 では **Windows x64 (MSVC ABI) 対応を必須タスクとして追加**し、マルチターゲット対応の基盤を整備する。ARM64 macOS は Phase 3 のクロスコンパイル機能で対応予定。

1. **型クラス実装戦略の評価（辞書渡しを主軸に PoC 比較）**
   - コンパイラ IR に辞書引数を追加し、`1-2` の制約解決アルゴリズムを OCaml で実装して主ラインとする。
   - 代表的なホットパス（例: `Eq`, `Ord`, `Collector`）で性能計測用の治具を用意し、辞書渡し方式のオーバーヘッドを `0-3-audit-and-metrics.md` に記録。
   - モノモルフィゼーションは完全実装ではなく PoC モジュール（限定的な型クラス 2〜3 件）を別ラインで用意し、コードサイズ・ビルド時間・デバッグ容易性を比較する。
   - 評価結果をもとに Phase 2 終了時に採用方式を決定し、決定理由と却下理由を `0-4-risk-handling.md` に記録。
2. **効果システム統合**
   - `effect` 注釈を AST/TAST に保持し、Stage 要求 (`StageRequirement::{Exact, AtLeast}`) を型チェック時に検証。
   - x86_64 Linux の Capability 構成を `3-8` の Stage テーブルと照合し、CI テストで検証。
3. **FFI 契約の拡張**
   - `3-9-core-async-ffi-unsafe.md` の ABI/所有権表を OCaml 実装に反映し、x86_64 Linux (System V) と Windows x64 (MSVC) の両方でビルドしたブリッジコードを検証。
   - FFI 呼び出しの追跡ログを `AuditEnvelope.metadata` に記録し、標準的な C ライブラリ呼び出しをサンプルに含める。
4. **診断・監査パイプライン**
   - `Diagnostic` に `extensions` フィールドを追加し、`effect.stage.*` や `bridge.stage.*` を出力。
   - 監査ログを JSON で出力し、`3-6` のキーセットに照合する自動テストを実装。
5. **仕様差分の補正**
   - 仕様書の表記ゆれや不足項目をレビューし、必要に応じて Chapter 1〜3 を更新。
   - 更新した仕様には計画書から脚注リンクを追加し、`0-3-audit-and-metrics.md` に差分概要を記録。
6. **Windows x64 (MSVC ABI) 対応**
   - **`-target x86_64-pc-windows-msvc`** でのビルドパイプラインを確立し、呼出規約・名前マングリングの差異を検証。
   - `llc -mtriple=x86_64-pc-windows-msvc` で生成した PE バイナリを Windows 環境で実行（CI: GitHub Actions windows-latest）。
   - DataLayout・ABI の差異を `docs/guides/llvm-integration-notes.md` §5.0 の表に従って実装。

## 2.0.5 測定と検証
- **性能トレンド**: Phase 1 と同じベンチマークを継続し、型クラス導入によるオーバーヘッドを定量化。辞書渡しとモノモルフィゼーションの比較結果を記録。
- **安全性**: 効果タグと Capability Stage のミスマッチが 0 件であることを CI で確認。
- **診断品質**: 代表的な型クラス失敗・Stage ミスマッチ・FFI 契約違反の診断をレビューし、仕様通りのメッセージが得られるかチェック。
- **マルチターゲット適合性**: x86_64 Linux と Windows x64 の両方で生成した LLVM IR が `opt -verify` を通過し、各プラットフォームで実行可能なバイナリが生成されることを確認。

## 2.0.6 リスクとフォローアップ
- **型クラス実装方式の決定遅延**: 辞書渡しとモノモルフィゼーションの評価が Phase 2 終了までに完了しない場合、Phase 3 への影響大。M1 マイルストーンで中間評価を実施し、早期に方針を固める。
- **効果タグと Capability のずれ**: 仕様更新と実装の差異が発生した場合、`0-4-risk-handling.md` に TODO を登録し、Phase 3 の着手条件に設定。
- **FFI 所有権**: 参照カウントのデバッグ支援ツールが不足しているため、Phase 3 でツール化タスクを追加予定。
- **マルチターゲット対応の負荷**: Windows x64 対応により Phase 2 の工数が増加する可能性。Linux 優先で進め、Windows は並行開発とすることでリスク軽減。

---

Phase 2 の完了により、Reml 言語の正式仕様が OCaml 実装で追証され、セルフホスト化に向けた要件（型クラス、効果、診断）が安定化する。
