# 1.2 実装ギャップ影響確認と Backend/Runtime 対応計画（2025-12-26）

`docs/spec/2-4-op-builder.md` のギャップ対応で追加した構文受理（`Type.method` / `rec expr` / `(...)->`）が、Frontend 以外（Backend/Runtime）に与える影響を整理し、必要な対応計画を定義する。

## 目的
- Frontend 側の構文拡張が Backend/Runtime に影響するかを明確化する。
- 影響がある場合の最小対応と、将来の実装方針を整理する。

## 対象範囲
- Rust Frontend: `compiler/frontend/`
- Rust Backend (LLVM): `compiler/backend/llvm/`
- Rust Runtime: `compiler/runtime/` / `runtime/`

## 調査結果（要約）
1) `Type.method` の宣言
- Frontend では `ImplDecl` に落とすが、`TypedModule.functions` へは追加されない。
- MIR (`compiler/frontend/src/semantics/mir.rs`) は `TypedModule.functions` のみを対象にするため、Backend には到達しない。
- したがって「実行可能な関数定義」としては未対応のまま。

2) `rec expr`
- Typecheck で `TypedExprKindDraft::Unknown` に落とされ、Typed AST/MIR に `rec` が残らない。
- Backend の MIR 変換/コード生成に `rec` の扱いは存在しない。

3) `(...)->` ラムダ
- 既存の `ExprKind::Lambda` と同様に Typecheck で `TypedExprKindDraft::Unknown` に落とされる。
- MIR/Backend はラムダ式のコード生成に対応していない。

## 結論
- **Backend/Runtime への影響は「未実装機能が増える」方向で残る**。
- docs/examples の診断 0 件化だけなら Frontend で完結するが、実行系の整合を取るには追加実装が必要。

---

## 対応計画（Backend/Runtime）

### フェーズ 1: 仕様・実装方針の確定
1) `Type.method` の実行モデルを決める
- `impl` を実体化するか、`Type.method` をトップレベル関数へデシュガーするかを決定。
- 名前解決（`Type.method` 呼び出し）と一致するメタデータ形式を決める。
- 既存の関数命名規則（`Type__method` など）候補を洗い出し、衝突回避ルールを定義。
- `impl` の可視性/公開範囲が MIR/Backend でどこまで必要かを整理。
- 仕様書（`docs/spec/2-4-op-builder.md`）に実行モデルの要約と、制限事項を追記候補として列挙。
 - 決定:
   - `Type.method` 宣言は Frontend でトップレベル関数へデシュガーし、受け手は第1引数として表現する（`Type.method(x, y)` → `Type__method(x, y)`）。
   - 実行系は静的ディスパッチのみを想定し、`impl` ブロック自体は持たない（糖衣としてのみ保持）。
   - 命名は `Type__method` を基本とし、モジュール境界がある場合は `Module__Type__method` を採用する。
   - 可視性はトップレベル関数と同等に扱い、`pub` 相当の公開範囲規則を流用する。
 - 仕様追記候補:
   - `Type.method` はトップレベル関数糖衣であること、受け手が第1引数に展開されること。
   - 現状は静的ディスパッチのみで、動的ディスパッチ/トレイト連携は対象外であること。
   - 名前衝突時は通常の関数重複定義エラーとして扱うこと。

2) `rec expr` の意味づけを整理する
- 再帰参照マーカーとして静的解決に使うのか、実行系へ残すのかを決定。
- 実行系へ残さない場合は Frontend での除去規則を明文化する。
- `rec` が許可される位置（式/定義/パターン）の範囲を再確認し、Backend の期待値を整合。
- `rec` が残る場合の実行時エラー条件（未初期化参照など）を洗い出す。
 - 決定:
   - `rec` は再帰参照の静的マーカーとして扱い、Typed AST/MIR には残さない（Backend/Runtime には到達しない）。
   - 許可位置は「式中の識別子参照」に限定し、`rec <ident>` 以外はフロントエンド診断で拒否する。
   - 未解決参照や循環参照は Frontend で診断し、実行時エラー条件は持たない。
 - 仕様追記候補:
   - `rec` はコンパイル時の参照マーカーであり、実行時意味を持たないこと。
   - `rec <ident>` のみを受理し、その他の式に対する `rec` は不正とすること。
 - Frontend 診断ルール（案）:
   - `parser.rec.invalid_form`: `rec` の直後が識別子以外の式だった場合にエラー。
   - `parser.rec.unsupported_position`: `rec` が識別子参照以外の位置で出現した場合にエラー。
   - `typeck.rec.unresolved_ident`: `rec <ident>` が解決できない場合にエラー（未束縛参照）。

3) ラムダ式の実行モデルを決める
- クロージャとして MIR/Backend/Runtime で扱うか、別途制限をかけるかを決定。
- キャプチャ無しラムダの扱い（通常関数への降格可否）を先に判断。
- キャプチャありラムダの最小実装案（環境オブジェクト生成/所有権）を整理。
- 現状の診断方針（未実装扱いでエラー）を維持するか、段階導入（機能フラグ）を検討。
 - 決定:
   - フェーズ 1 ではキャプチャ無しラムダのみを対象とし、トップレベル関数へデシュガーする。
   - キャプチャありラムダは Frontend で診断エラーとし、Backend/Runtime には導入しない。
   - ラムダの実行モデルは「関数値（関数ポインタ相当）」として扱い、クロージャ環境は後続フェーズで検討する。
 - 仕様追記候補:
   - 当面はキャプチャ無しラムダのみを許可し、キャプチャを伴うラムダは未実装であること。
   - ラムダはトップレベル関数へ降格されること（関数値として扱うこと）。
 - Frontend 診断ルール（案）:
   - `typeck.lambda.capture_unsupported`: 自由変数を含むラムダ（キャプチャあり）を検出した場合にエラー。
   - `typeck.lambda.capture_mut_unsupported`: 可変参照/可変借用を要求するキャプチャが必要な場合は別コードでエラー。
   - `parser.lambda.param_missing`: `| |` や `|,|` など不正なパラメータ形式を検出した場合にエラー。

### フェーズ 2: Typed AST/MIR の拡張
1) Typed AST の拡張
- `compiler/frontend/src/semantics/typed.rs` に `TypedExprKind::Lambda` / `TypedExprKind::Rec` を追加。
- Typecheck で `TypedExprKindDraft::Unknown` ではなく対応種別を生成する。
- `TypedExpr` へ必要なフィールド（パラメータ、キャプチャ情報、再帰束縛対象）を確定。
- 既存 `Unknown` の出力先（診断/ログ）を確認し、後方互換方針を決める。

2) MIR の拡張
- `compiler/frontend/src/semantics/mir.rs` に対応する `MirExprKind` を追加。
- MIR スキーマのバージョン更新（`frontend-mir/0.1` → `0.1+` など）と変換パスを明示する。
- MIR でのクロージャ表現（環境値/関数本体）を最小構成で定義。
- `rec` の表現を MIR に残す場合のノード形状と、消し込みの場合の変換ルールを記載。

3) JSON 連携の更新
- Backend の `compiler/backend/llvm/src/integration.rs` に新しい MIR JSON を追加。
- 既存の `MirExprKind::Unknown` との互換方針を決める。
- JSON のバージョン識別子と互換性ガード（受理/拒否条件）を明記。
- 既存ツール（`tooling/` や `reports/`）での JSON 解析影響をチェックする。

### フェーズ 3: Backend のコード生成
1) `Type.method` の実体化
- `impl` の関数を MIR 上の関数として生成する。
- メソッド呼び出しと一致する関数シグネチャへ変換する。
- メソッド呼び出し箇所の解決ルール（静的ディスパッチ/将来の動的拡張）を整理。
- 既存の関数呼び出し生成パスとの合流点を決める。

2) `rec expr` の実行モデル反映
- 実行系へ残す場合は MIR/LLVM で表現する。
- 残さない場合は Frontend の段階で消し込み、Backend には影響しない形にする。
- 既存の初期化順序（let/const など）と衝突しない実装順序を確認。
- ランタイムで必要な安全性チェック（自己参照/循環参照）を洗い出す。

3) ラムダ式のコード生成
- クロージャ実装が必要なら、環境キャプチャ表現と呼び出し規約を定義する。
- 当面は制限/診断で抑止する方針も検討する。
- キャプチャ無しラムダは通常関数へ降格するルールを先に実装。
- キャプチャありラムダは最小機能で PoC し、MIR/LLVM の仕様化を段階導入。

### フェーズ 4: Runtime の補完
1) クロージャ/関数値を扱うためのランタイム API を整備する。
2) `rec` のランタイム表現が必要なら、再帰参照の安全性チェックを追加する。
- ランタイムの ABI 仕様（環境ポインタ/関数ポインタの並び）を明文化。
- 将来の GC/所有権モデル変更に耐えるよう、環境ライフタイムの契約を定義。

## 進捗管理
- 本計画書作成日: 2025-12-26
- 進捗欄（運用用）:
  - [x] フェーズ 1 完了
  - [x] フェーズ 2 完了
  - [x] フェーズ 3 完了
  - [x] フェーズ 4 完了

## 関連リンク
- `docs/plans/docs-examples-audit/1-2-impl-gap-plan-20251226-3.md`
- `docs/spec/2-4-op-builder.md`
