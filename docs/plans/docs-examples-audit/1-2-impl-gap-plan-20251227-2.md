# 1.2 実装ギャップ対応計画（Rust Frontend / 2025-12-27）

`docs/spec/3-1-core-prelude-iteration.md` のサンプル修正で判明した **仕様と実装のギャップ** を整理し、Rust Frontend 側で追随するための対応計画を定義する。

## 目的
- 仕様例をフォールバックではなく正準表記で通せるようにする。
- `pub` / trait / 修飾子付き関数定義など、仕様にある構文を Rust Frontend が受理できるようにする。

## 対象範囲
- 仕様章: `docs/spec/3-1-core-prelude-iteration.md`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_2_1.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_3_2.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_3_4.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_3_5.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_4_1.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_4_2.reml`
- サンプル: `examples/docs-examples/spec/3-1-core-prelude-iteration/sec_6_2.reml`

## ギャップ一覧（フォールバックで回避済み）

### 1. `pub` 付き宣言の未対応
- 影響: `pub type` / `pub struct` が `parser.syntax.expected_tokens` で失敗する。
- 回避: `pub` を除去してコンパイル通過。

### 2. 宣言シグネチャのみの関数定義
- 影響: `fn foo(...) -> T` 形式が受理されず、`=` またはブロックが必須。
- 回避: すべて `= todo` へ置換。

### 3. trait のジェネリクス / 複数メンバ / associated type
- 影響: `trait Collector<T, C, E> { ... }` などが構文エラーになる。
- 回避: `type Collector<T, C, E> = ()` へ簡略化し、メンバ一覧は削除。

### 4. 修飾子付き関数名 (`Type.method` / `Type::method`) の未対応
- 影響: `fn Iter.from_list` / `fn Diagnostic::invalid_value` などが構文エラーになる。
- 回避: `iter_from_list` / `diagnostic_invalid_value` など平坦名に置換。

### 5. 組み込み型/別名の不足 (`Float` / `f64` / `u32` / `usize` / `Char`)
- 影響: 型参照が未解決となり診断が発生する。
- 回避: サンプル内に `type` エイリアスを追加。

### 6. 循環型エイリアス (`type Never = Result<Never, Never>`) の未対応
- 影響: `type.alias.cycle` が発生する。
- 回避: `type Never = ()` に簡略化。

## 実装修正計画（Rust Frontend）

### フェーズ 1: 構文受理の拡張
1) `pub` 宣言のパーサ追加
- 対象: トップレベルの `type` / `struct` / `enum` / `trait` / `fn`
- 目的: 可視性が付いた宣言を AST で保持し、診断の期待トークンが破綻しないようにする。
- 詳細ステップ:
  - 仕様サンプルから `pub` の出現位置（宣言先頭のみ）を再確認し、許容トークン列を確定する。
  - `compiler/frontend/src/parser/ast.rs` の宣言ノードに `Visibility` を持たせ、`render` に可視性を反映する。
  - `compiler/frontend/src/parser/mod.rs` の宣言パーサで可視性を先読みし、`pub` が付いた宣言を `Visibility::Public` として構築する。
  - `parser.syntax.expected_tokens` の期待値に `pub` を追加し、回復戦略が他の宣言と一致することを確認する。
- 成果物: `pub type Option<T> = ...` が構文エラーを出さない。
- 状態: 対象宣言の `pub` 受理と `render` 反映まで完了（期待トークン追加は未確認）。

2) シグネチャのみの関数宣言を許可
- 対象: `fn foo(...) -> T` 形式の宣言（本体なし）
- 目的: 本体なし宣言を「抽象関数」として受理し、後段で扱えるようにする。
- 詳細ステップ:
  - `compiler/frontend/src/parser/ast.rs` の関数定義に「本体なし」の状態を表すバリアントを追加する。
  - `compiler/frontend/src/parser/mod.rs` の関数パーサで `=` / `{` が無い場合にシグネチャのみで確定する分岐を追加する。
  - `compiler/frontend/src/typeck/` の関数登録処理で、本体なしの関数を「未実装/外部定義」として扱えるようにする。
  - MIR 生成や診断出力で本体なし関数が落ちないことを確認する。
- 成果物: `= todo` なしでも parse/typecheck が通る。
- 状態: AST/パーサ/型環境登録まで完了（MIR/診断の通過確認は未実施）。

3) trait ジェネリクス / associated type / 複数メンバ対応
- 対象: `trait Foo<T> { type Error; fn bar(...) -> ... }`
- 目的: 仕様サンプルで使われる最小構成の trait 構文を受理し、AST/MIR へ落とす。
- 詳細ステップ:
  - `compiler/frontend/src/parser/ast.rs` の `TraitDecl` / `TraitItem` を拡張し、ジェネリクスと associated type を表現できるようにする。
  - `compiler/frontend/src/parser/mod.rs` の trait パーサで、`type` / `fn` の複数メンバをセミコロン区切りで受理する。
  - typecheck 層で trait のシンボル登録と associated type の解決を行い、未実装のメンバは宣言として保持する。
  - 診断出力が trait ブロック終端で暴走しないよう、回復の境界を調整する。
- 成果物: Collector 例の trait が構文通過し、MIR に落とせる。
- 状態: パーサ/AST 拡張まで完了（typecheck/MIR の対応は未実施）。

4) 修飾子付き関数定義 (`Type.method` / `Type::method`) の受理
- 対象: `fn Iter.from_list` / `fn Diagnostic::invalid_value` など
- 目的: 関数名に型修飾子を含めた構文を AST で保持できるようにする。
- 詳細ステップ:
  - `compiler/frontend/src/parser/ast.rs` に「修飾付き関数名」（例: `QualifiedIdent`）の表現を追加する。
  - `compiler/frontend/src/parser/mod.rs` の関数定義で `Type.method` / `Type::method` を読み取る分岐を追加する。
  - 名前解決で修飾子付き関数の名前空間を整理し、既存の平坦名と衝突しないようにする。
  - `render` と diagnostics の出力が修飾付き名を正しく表示することを確認する。
- 成果物: 現行サンプルの修飾付き定義をそのままパースできる。
- 状態: `Type.method` / `Type::method` の受理まで完了（名前解決と表示検証は未実施）。

### フェーズ 2: 型/解決の整合
1) 組み込み型の別名を標準化
- 対象: `Float` / `f64` / `u32` / `usize` / `Char`
- 目的: 仕様サンプルで使う組み込み名を prelude 側で定義し、明示的な alias を不要にする。
- 詳細ステップ:
  - `compiler/frontend/src/typeck/types.rs` の `BuiltinType` に必要な型種別を追加する。
  - 組み込み型の名前解決／prelude 登録箇所で `Float` / `f64` / `u32` / `usize` / `Char` を同一種別へマッピングする。
  - diagnostics の型名表示が仕様の表記と一致するよう、表示名ルールを決めて統一する。
  - サンプル側の `type` 追加を削除しても unresolved が出ないことを確認する。
- 成果物: prelude で自動定義され、サンプル内の `type` 追加が不要になる。
- 状態: `BuiltinType` 追加と名前解決／表示名の統一、サンプルの型エイリアス削除と診断 0 件の確認まで完了（prelude 登録は明示実装なし）。

2) `Never` の循環型エイリアスの扱い
- 対象: `type Never = Result<Never, Never>`
- 目的: `Never` の発散型としての扱いを型検査で許容し、循環診断を抑制する。
- 詳細ステップ:
  - 型エイリアス循環検出のロジックを確認し、`Never` を特別扱いするか、循環でも許容するルールを定義する。
  - `Never` を底型として扱う場合の型推論/制約処理を整理し、既存の `type.alias.cycle` 診断が抑制される条件を明示する。
  - 診断メッセージに `Never` 特例の説明を追加するかを検討し、仕様との整合を取る。
- 成果物: エイリアス循環の許容または特別扱い（型推論での発散扱い）を追加。
- 状態: `Never` の循環検出を抑制する対応まで完了（底型扱いの整理は今後、診断文言は抑制方針のため追加なし）。

### フェーズ 3: サンプル復元
- 目的: 仕様サンプルを正準例に戻し、Rust Frontend の受理状況を再確認する。
- 詳細ステップ:
  - フォールバックで除去した `pub` / trait メンバ / 修飾子付き関数名を正準例に戻す。
  - `examples/docs-examples/spec/3-1-core-prelude-iteration/*.reml` を仕様のコードブロックと一致させる。
  - `compiler/frontend/target/debug/reml_frontend --output json` で対象サンプルを通し、診断 0 件を確認する。
  - `docs/plans/docs-examples-audit/1-2-spec-sample-fix-targets.md` の修正状況を更新する。

## 進捗管理
- 本計画書作成日: 2025-12-27
- 進捗欄（運用用）:
  - [x] フェーズ 1 完了（構文受理・AST 反映まで）
  - [x] フェーズ 2 完了（組み込み型追加/解決、Never 循環抑制、サンプル診断確認まで実施）
  - [x] フェーズ 3 完了
  - フェーズ 3: 正準例の復元と `reml_frontend --output json` による診断 0 件確認まで完了。

## 関連リンク
- `docs/spec/3-1-core-prelude-iteration.md`
- `docs/plans/docs-examples-audit/1-2-spec-sample-fix-plan.md`
