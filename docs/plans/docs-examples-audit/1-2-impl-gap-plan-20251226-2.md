# 1.2 実装ギャップ対応計画（Rust Frontend / 2025-12-26）

`docs/spec/2-3-lexer.md` のサンプル修正で判明した **仕様と Rust Frontend のギャップ** を整理し、実装側で追随するための対応計画を定義する。

## 目的
- 仕様側の記法に合わせて Rust Frontend の受理範囲を拡張する。
- サンプル側で行った簡略化・回避を、正準例へ戻せる状態にする。

## 対象範囲
- 仕様章: `docs/spec/2-3-lexer.md`
- サンプル: `examples/docs-examples/spec/2-3-lexer/*.reml`

## ギャップ一覧（簡略化／回避済み）

### 1. 型リテラルによるユニオン指定
- 症状: `radix: 2|8|10|16` が `parser.syntax.expected_tokens` で失敗する。
- 現状の回避: `radix: u8` に変更し、許容値をコメントで補足。
- 期待: 数値リテラルの列挙（型レベル union）が受理できること。

### 2. `const` 宣言と名前空間付き定数
- 症状: `const ConfigTriviaProfile::strict_json: ConfigTriviaProfile = ...` が構文エラー。
- 現状の回避: `let strict_json: ConfigTriviaProfile = ...` に置換。
- 期待: `const` キーワードと `Type::CONST` 形式の宣言を受理できること。

### 3. `let f(x) = ...` の関数糖衣
- 症状: `let sym(s) = ...` 形式が構文エラー。
- 現状の回避: `let sym = |s| ...` に置換。
- 期待: `let` による関数糖衣の受理（または仕様を `fn` に統一）。

### 4. 集合リテラル `{...}`
- 症状: `{"fn","let",...}` が構文エラー。
- 現状の回避: 配列リテラル `[...]` に置換。
- 期待: セットリテラルの受理、または仕様側で正式な構文を定義。

### 5. `struct` 宣言・レコード構築
- 症状: `struct LexPack { ... }` および `LexPack { ... }` の例が構文エラー。
- 現状の回避: `type LexPack = { ... }` と `= todo` に簡略化。
- 期待: `struct` 宣言とレコード構築の構文を受理できること。

## 実装修正計画（Rust Frontend）

### フェーズ 1: 構文受理（最小対応）
0) 事前確認（共通）
- `docs/spec/2-3-lexer.md` の該当セクションを読み、仕様の期待値をメモする。
- `examples/docs-examples/spec/2-3-lexer/*.reml` を現状で解析し、診断の出方を記録する（失敗箇所の最小再現を作る）。
- 既存の AST/パーサ/セマンティクスで近い構文がどこにあるかを洗い出す（`compiler/frontend/src/parser`, `.../semantics`, `.../typeck`）。
  - [x] 仕様セクションの確認
  - [x] サンプル現状解析（診断 0 件のため最小再現なし）
  - [x] 既存コードの調査（AST/パーサ/型チェック）

1) 型レベル union（`2|8|10|16`）の受理
- 型パーサの `Type` 分岐に「数値リテラルの列挙」を追加する。
- AST に型レベルリテラル/ユニオンの表現を追加し、既存の型ユニオンと衝突しない形にする。
- 型チェックで「許容値列挙」として扱える最低限の整合を入れる（将来の厳密化に備える）。
- パーサ単体テストか例示テストを追加して `2|8|10|16` を検証する。
  - [x] パーサ/AST/型チェック/テストを追加し受理を確認

2) `const` 宣言と名前空間付き定数
- トップレベル項目に `const` 宣言を追加する（`const <Path>: <Type> = <Expr>`）。
- `Type::CONST` 形式の参照（`Type::CONST` が識別子パスとして通ること）をパーサで受理する。
- 定数の束縛がセマンティクス/リゾルバに入ることを確認し、必要ならバインディング種別を追加する。
- 例示テストで `const ConfigTriviaProfile::strict_json: ...` が通ることを確認する。
  - [x] パーサ/字句/テストを追加し受理を確認

3) `let` 関数糖衣
- `let f(x) = expr` の構文をパーサで認識し、`let f = |x| expr` にデシュガーする。
- 複数引数やパターン引数の取り扱い範囲を明文化し、未対応の場合は診断で明示する。
- 既存のラムダ構文と同じスコープ/型推論になるかを確認し、テストを追加する。
  - [x] パーサ側で糖衣を受理しテストを追加

4) 集合リテラル
- `{ "a", "b" }` をセットリテラルとして受理する構文を追加する。
- レコード/ブロックとの曖昧さを避けるため、トークン先読み条件を定義する（例: `:` の有無で分岐）。
- AST に `Set` リテラルを追加し、型推論で最低限の `Set<T>` 形に整合させる。
- 例示テストで `{"fn","let"}` を通し、配列との差を確認する。
  - [x] AST/パーサ/型推論/テストを追加し受理を確認

5) `struct` 宣言・レコード構築
- `struct Name { field: Type, ... }` をトップレベル宣言として追加する。
- `Name { field, ... }` のレコード構築を式として受理する（フィールド省略は `field: field` と同義にする）。
- 型チェック/セマンティクスでレコード構築が既存の型表現と整合するかを確認する。
- 例示テストで構造体宣言と構築の両方が通ることを確認する。
  - [x] パーサ/AST/型チェック/テストを追加し受理を確認

### フェーズ 2: サンプル復元と再検証
1) 仕様・サンプルの復元
- `docs/spec/2-3-lexer.md` の簡略化箇所を正準例へ戻す（今回の 5 項目に対応する例を復元）。
- `examples/docs-examples/spec/2-3-lexer/*.reml` を仕様側の表記に合わせて戻す。
  - [x] 仕様・サンプルの復元を実施

2) 実行による再検証
- `cargo run --manifest-path compiler/frontend/Cargo.toml --bin reml_frontend -- --output json <sample>` で各サンプルの診断 0 件を確認する。
- 失敗が出た場合は、該当構文を最小化して原因を切り分け、フェーズ 1 の項目に差し戻す。
  - [x] 全サンプル診断 0 件を確認

3) 記録と追跡
- 実装差分と仕様差分が一致しているかを再確認する。
- 必要なら `docs/plans/docs-examples-audit/1-2-spec-sample-fix-plan.md` の該当項目に実施メモを追記する。
  - [x] 実装差分と仕様差分を確認

## 進捗管理
- 本計画書作成日: 2025-12-26
- 進捗欄（運用用）:
  - [x] フェーズ 1 完了
  - [x] フェーズ 2 完了

## 関連リンク
- `docs/spec/2-3-lexer.md`
- `docs/plans/docs-examples-audit/1-2-spec-sample-fix-plan.md`
