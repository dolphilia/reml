# 1.2 実装ギャップ対応計画（Rust Frontend / 2025-12-26）

`docs/spec/2-4-op-builder.md` のサンプル修正で判明した **仕様と実装のギャップ** を整理し、Rust Frontend 側で追随するための対応計画を定義する。

## 目的
- 仕様例をフォールバックなしで受理できるようにする。
- 仕様とサンプルを再び正準例へ戻す準備を整える。

## 対象範囲
- 仕様章: `docs/spec/2-4-op-builder.md`
- サンプル: `examples/docs-examples/spec/2-4-op-builder/*.reml`
- 監査ログ: `reports/spec-audit/ch2/docs-examples-fix-notes-20251224.md`

## ギャップ一覧（簡略化／回避済み）

### 1. メソッド定義風の構文（`Type.method`）未対応
- 影響: `PrecedenceBuilder<A>.level(...)` のような宣言が構文エラーになる。
- 該当サンプル:
  - `examples/docs-examples/spec/2-4-op-builder/sec_a_2.reml`
  - `examples/docs-examples/spec/2-4-op-builder/sec_a_3.reml`
- 現状の回避: 関数スタブ（`fn level(...)` / `fn build(...)`）へ置換。

### 2. `let sym(s) = ...` 形式の関数風束縛未対応
- 影響: `let sym(s) = symbol(sc, s)` が構文エラーになる。
- 該当サンプル:
  - `examples/docs-examples/spec/2-4-op-builder/sec_b.reml`
- 現状の回避: `fn sym(s: Str) -> Parser<()> = ...` へ置換。

### 3. ラムダ本体での単項 `-a` が構文エラー
- 影響: `|a| -a` がパース不能。
- 該当サンプル:
  - `examples/docs-examples/spec/2-4-op-builder/sec_b.reml`
- 現状の回避: `|a| 0 - a` へ置換。

### 4. レコード内フィールドの関数式が `(...)->` 記法で受理されない
- 影響: `build: (c,t,f) -> ...` が構文エラーになる。
- 該当サンプル:
  - `examples/docs-examples/spec/2-4-op-builder/sec_i_1.reml`
- 現状の回避: `build: |c, t, f| ...` へ置換。

### 5. `rec` キーワードによる再帰参照が未対応
- 影響: `then(rec expr)` が構文エラーになる。
- 該当サンプル:
  - `examples/docs-examples/spec/2-4-op-builder/sec_b.reml`
- 現状の回避: `then(expr)` へ置換。

## 実行計画（Rust Frontend）

### フェーズ 1: 構文受理（最小限のパース対応）
1) メソッド定義風構文の受理
- 目的: `Type.method` 形式の関数宣言を受理し、AST に落とす。
- 作業ステップ:
  - 現行の関数宣言パーサ（`compiler/frontend/src/parser/mod.rs` の `fn_signature` 付近）で `TypeName` 単体しか受けられないことを確認し、仕様例のエラーパターンを再現する。
  - `compiler/frontend/src/parser/ast.rs` の `FunctionSignature` に「受け手型（receiver）」を追加するか、別の糖衣用 AST を追加する方針を決める。
  - `TypeName` / `Type<A>` を `.` でつないだ `Type.method` を受理し、`impl Type { fn method ... }` 相当の AST へ変換する処理をパーサ内で実装する。
  - `Type<A>.method` の型引数が `impl` 側に束縛されることを明示し、`impl` への変換規則をドキュメント化する。
  - 変換後の AST を `Module::render` などの表示系で確認できるようにし、パース結果のトレースに残す。

2) `let name(args) = expr` の関数束縛受理
- 目的: 仕様例の簡易関数束縛をパース可能にする。
- 作業ステップ:
  - `compiler/frontend/src/parser/mod.rs` の `build_let_decl_parser` で `let` の関数糖衣（`let_fn_decl`）の受理条件を確認する。
  - `let sym(s)` が構文エラーになる再現パスを洗い出し、`pattern_var`/`params` のどちらが拒否しているかを切り分ける。
  - `let name(args)` を `ExprKind::Lambda` への変換で統一し、`fn` 宣言と同等の AST になることを確認する。
  - `let` の型注釈付き (`let name(args) -> T = ...`) も同時に受理できるように分岐を整理する。

3) ラムダ本体での単項演算子を受理
- 目的: `|a| -a` をパース可能にする。
- 作業ステップ:
  - ラムダ式の本体がどの式パーサを通っているかを確認し、単項演算子の優先順位ルールが欠落している箇所を特定する。
  - `|a| -a` / `|a| -(a)` / `|a| -f(a)` を受理できるよう、ラムダ本体が通常の `expr` と同等のパース経路になるように修正する。
  - AST では `ExprKind::Unary` で表現されることを確認し、診断の回帰がないかを確認する。

4) レコード内フィールドに `(...)->` 関数式を許可
- 目的: `field: (a,b) -> expr` を `field: |a, b| expr` と同等に扱う。
- 作業ステップ:
  - レコード値のパーサ（`compiler/frontend/src/parser/mod.rs` の `RecordField` 生成箇所）で、`:` 直後の `(` を検知できる分岐を追加する。
  - `(...)->` 形式の簡易関数式を `ExprKind::Lambda` に正規化し、既存の `|...|` と同一扱いにする。
  - `field: (a, b) -> expr` / `field: (a: T) -> expr` の両方でパースできるかを確認する。

5) `rec` による再帰参照の導入
- 目的: `rec expr` を再帰参照マーカーとして許可する。
- 作業ステップ:
  - `compiler/frontend/src/token.rs` と `compiler/frontend/src/lexer/mod.rs` に `KeywordRec` を追加する。
  - `compiler/frontend/src/parser/ast.rs` に `ExprKind::Rec` などの表現を追加し、`rec` の span を保持できるようにする。
  - `compiler/frontend/src/parser/mod.rs` の式パーサに `rec` を前置単項として組み込み、`rec expr` を AST へ落とす。
  - 既存の `rule("name", ...)` との併用時に許される範囲（式・宣言のどこで使えるか）をフェーズ 1 の段階で最小仕様として明文化する。

### フェーズ 2: 型付け・意味解釈の整合
- `Type.method` 糖衣を `impl` と等価に変換する際の型引数束縛ルールを整理し、`compiler/frontend/src/typeck/` の型推論に反映する。
- `let name(args) = expr` を `fn name(args) -> _ = expr` と同等に扱う型推論経路を追加し、`typeck` のエラーメッセージが `fn` と一致することを確認する。
- `rec expr` の参照解決に向けて、`compiler/frontend/src/semantics/` または `typeck` に再帰参照フラグの伝播処理を追加する。
- 再帰参照が無限再帰になるケースを検知し、既存の `rule` / `ParserId` の診断と衝突しないエラーコードを付与する。

### フェーズ 3: サンプル復元と再検証
1) サンプルを正準例へ戻す
- `sec_a_2.reml` / `sec_a_3.reml` をメソッド定義風へ復元する。
- `sec_b.reml` の `let sym(s)` / `rec expr` / `|a| -a` を正準例へ戻す。
- `sec_i_1.reml` の `build: (c,t,f) -> ...` を正準例へ戻す。

2) 再検証
- `compiler/frontend/target/debug/reml_frontend --emit-diagnostics <sample>` を実行し診断 0 件を確認する。
- `reports/spec-audit/ch2/2-4-op-builder__*.json` を更新する。
- `docs/plans/docs-examples-audit/1-1-spec-code-block-inventory.md` の `validation` 欄を更新する。
- 実行結果は `reports/spec-audit/ch2/docs-examples-fix-notes-20251224.md` に追記し、差分がある場合は要点を残す。

## 進捗管理
- 本計画書作成日: 2025-12-26
- 進捗欄（運用用）:
  - [x] フェーズ 1 完了
  - [x] フェーズ 2 完了
  - [x] フェーズ 3 完了

## 関連リンク
- `docs/spec/2-4-op-builder.md`
- `docs/plans/docs-examples-audit/1-2-spec-sample-fix-plan.md`
- `reports/spec-audit/ch2/docs-examples-fix-notes-20251224.md`
