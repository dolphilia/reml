# 3.4 中間 IR と CodeGen 再実装計画

## 目的
- Phase 3 マイルストーン M4 を達成するため、Reml 実装で Core IR/MIR/LLVM IR 生成パイプラインを再構築し、OCaml 版との互換性を確保する。
- モノモルフィゼーションやターゲット別最適化を適用しやすい構造を整え、性能の回帰を防止する。

## スコープ
- **含む**: Core IR/MIR データ構造定義、変換パス、最小最適化の移植、LLVM IR 出力、ターゲット別 DataLayout 適用。
- **含まない**: 高度な最適化（レジスタ割り当て改善等）、JIT。必要に応じて Phase 4 以降。
- **前提**: Phase 1 の Core IR 設計と Phase 2 の型クラス・効果が Reml 実装へ引き継がれていること。

## 作業ブレークダウン

### 1. Core IR データ構造定義（59-60週目）
**担当領域**: 中間表現の基盤

1.1. **Core IR ノード定義**
- `guides/llvm-integration-notes.md` の Core IR 仕様を Reml で実装
- 式ノード: `Var`, `Let`, `App`, `Lam`, `Match`, `Lit`
- 宣言ノード: `FnDef`, `TypeDef`, `ExternDecl`
- 型情報の付与: 全ノードに型注釈を保持
- 所有権情報の追跡: RC 参照カウント挿入ポイント

1.2. **型クラス/効果の表現**
- Phase 2 決定方式（辞書渡し or モノモルフィゼーション）の反映
- 辞書パラメータの明示的表現（辞書渡しの場合）
- 型パラメータのマーキング（モノモルフィゼーション用）
- 効果タグの保持と伝播

1.3. **OCaml版との互換性**
- Core IR のシリアライズ形式定義（JSON/Bincode）
- OCaml版との構造比較ツール
- 差分レポート生成
- ゴールデンテスト用スナップショット

**成果物**: `Core.IR.Core` モジュール、型定義、互換性ツール

### 2. TypedAST → Core IR 変換（60-61週目）
**担当領域**: 脱糖衣化

2.1. **構文糖の展開**
- パイプライン演算子 `|>` の関数適用への変換
- パターンマッチの case 式への展開
- レコード更新構文の明示的コピーへ変換
- 名前付き引数の位置引数化

2.2. **クロージャ変換**
- ラムダ式のクロージャ構造への変換
- 自由変数のキャプチャ
- 環境の構築と受け渡し
- 末尾呼び出しの検出とマーキング

2.3. **型クラス辞書の挿入**
- 制約から辞書引数への変換（辞書渡しの場合）
- メソッド呼び出しの辞書アクセスへ変換
- または型パラメータの具体化（モノモルフィゼーションの場合）
- 辞書生成コードの挿入

**成果物**: `Core.IR.Lower` モジュール、脱糖衣化テスト

### 3. MIR（Mid-level IR）設計（61-62週目）
**担当領域**: 最適化可能な中間表現

3.1. **MIR データ構造**
- SSA（Static Single Assignment）形式の採用
- 基本ブロックとコントロールフローグラフ
- 3番地コード形式: `tmp = op arg1 arg2`
- φ関数の明示的表現

3.2. **Core IR → MIR 変換**
- ネストした式の平坦化
- 一時変数の導入
- ジャンプとラベルの明示化
- 制御フローの正規化

3.3. **MIR 検証**
- SSA 形式の検証（支配木チェック）
- 型整合性の検証
- 未定義変数の検出
- デッドコードの検出

**成果物**: `Core.IR.MIR` モジュール、変換パス、検証ツール

### 4. 最小最適化パス（62-63週目）
**担当領域**: 基本最適化

4.1. **ローカル最適化**
- 定数畳み込み（constant folding）
- コピー伝播（copy propagation）
- デッドコード除去（dead code elimination）
- 共通部分式除去（common subexpression elimination）

4.2. **関数レベル最適化**
- インライン展開（小関数の展開）
- 末尾呼び出し最適化（tail call optimization）
- 未使用引数の除去
- 関数特殊化（定数引数の特殊化）

4.3. **RC 最適化**
- 参照カウント操作の最小化
- ムーブセマンティクスの活用
- 一時オブジェクトの最適化
- RC ペアの除去（inc/dec の相殺）

**成果物**: 最適化パス、性能計測、最適化効果レポート

### 5. LLVM IR 生成（63-64週目）
**担当領域**: バックエンド統合

5.1. **LLVM IR 基本生成**
- MIR → LLVM IR の変換
- `guides/llvm-integration-notes.md` の型マッピング適用
- 関数・グローバル変数の定義
- 基本ブロックとターミネータの生成

5.2. **ターゲット別対応**
- 3-3 で実装したターゲットプロファイルの活用
- DataLayout の適用（x86_64 vs ARM64）
- 呼出規約の設定（System V vs Windows x64 vs ARM64）
- ターゲット固有の型サイズ・アライメント

5.3. **LLVM 検証と最適化**
- `opt -verify` による IR 検証
- LLVM 最適化パスの適用（-O0/-O2/-O3）
- デバッグ情報の生成（DWARF）
- 出力 `.ll` ファイルの生成

**成果物**: `Core.IR.LLVM` モジュール、LLVM IR 生成、検証ツール

### 6. モノモルフィゼーション統合（64-65週目）
**担当領域**: 型パラメータ特殊化

6.1. **特殊化エンジン**
- Phase 2 決定方式がモノモルフィゼーションの場合の実装
- 型パラメータの具体型への置換
- シンボル名のマングリング（`foo<i32>` → `foo_i32`）
- 特殊化済み関数のキャッシュ

6.2. **コード膨張の制御**
- 特殊化の閾値設定（関数サイズ・呼び出し回数）
- 共通コードの抽出
- バイナリサイズの監視
- `0-3-audit-and-metrics.md` への記録

6.3. **辞書渡しとの統合**
- ハイブリッド手法の検討（小型はモノ化、大型は辞書）
- 切り替え基準の定義
- 性能トレードオフの評価
- ベンチマーク結果の記録

**成果物**: モノモルフィゼーションエンジン、コード膨張監視

### 7. 検証とテスト（65-66週目）
**担当領域**: 品質保証

7.1. **IR 差分比較**
- OCaml版とReml版のLLVM IR比較ツール
- `llvm-diff` による構造差分検出
- 許容差分の定義（最適化レベル依存）
- 差分レポート生成と承認プロセス

7.2. **統合テスト**
- Phase 1-2 のテストスイート実行
- 3ターゲット全てでのビルドと実行確認
- ゴールデンテスト（LLVM IR スナップショット）
- エッジケース（再帰、高階関数、複雑な型クラス）

7.3. **性能計測**
- コンパイル時間の測定（各IRフェーズ別）
- 生成バイナリの実行性能
- バイナリサイズの計測
- Phase 2 ベースライン ±10% の検証

**成果物**: 差分比較ツール、統合テスト、性能レポート

### 8. ドキュメント整備とレビュー（66週目）
**担当領域**: ドキュメント

8.1. **技術文書更新**
- `3-0-phase3-self-host.md` への IR パイプライン詳細追記
- IR 変換の設計文書作成
- 最適化パスの説明
- トラブルシューティングガイド

8.2. **仕様書反映**
- `guides/llvm-integration-notes.md` の更新
- `notes/llvm-spec-status-survey.md` への差分記録
- IR 仕様の最終化
- サンプルコードの追加

8.3. **レビュー資料作成**
- M4 マイルストーン達成報告書
- LLVM IR サンプル出力
- OCaml版との差分サマリ
- Phase 3 次タスク（3-5 Runtime）への引き継ぎ事項

**成果物**: 完全なドキュメント、更新仕様書、レビュー資料

## 成果物と検証
- `Core.IR.*` モジュール群が実装され、CI で IR 生成テストが通過すること。
- LLVM IR の差分が許容範囲内（構造的等価性 90% 以上）に収束し、差異理由が `notes/llvm-spec-status-survey.md` に文書化される。
- MIR/LLVM のテストが CI で安定通過し、性能が Phase 2 ベースライン ±10% に収まる。
- 生成バイナリが3ターゲット全てで実行でき、基本機能が動作する。

## リスクとフォローアップ
- 差分が大きい場合は OCaml 版をフォールバックとして維持し、最適化戦略の再評価を行う。
- ターゲットごとの最適化が複雑になりすぎる場合、Phase 4 のリリースパイプラインでの整合チェックを強化する。
- モノモルフィゼーションのコード膨張を監視し、`0-3-audit-and-metrics.md` に統計を記録。閾値超過時は辞書渡しへの切り替えを検討。
- LLVM バージョン依存性が発生した場合、サポートバージョン範囲を明示し、CI で複数バージョンをテスト。

## 参考資料
- [3-0-phase3-self-host.md](3-0-phase3-self-host.md)
- [guides/llvm-integration-notes.md](../../guides/llvm-integration-notes.md)
- [notes/llvm-spec-status-survey.md](../../notes/llvm-spec-status-survey.md)
- [1-3-core-ir-min-optimization.md](1-3-core-ir-min-optimization.md)
- [1-4-llvm-targeting.md](1-4-llvm-targeting.md)
- [2-1-typeclass-strategy.md](2-1-typeclass-strategy.md)
- [3-3-cross-compilation.md](3-3-cross-compilation.md)
- [0-3-audit-and-metrics.md](0-3-audit-and-metrics.md)
- [0-4-risk-handling.md](0-4-risk-handling.md)
