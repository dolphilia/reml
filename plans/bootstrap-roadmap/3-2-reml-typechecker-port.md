# 3.2 Reml TypeChecker 再実装計画

## 目的
- Phase 3 マイルストーン M2 を達成するため、OCaml の Typer を Reml で再実装し、型クラス・効果・Stage 判定を Reml コードで再現する。
- 辞書渡し/モノモルフィゼーションの最終方針（Phase 2 で決定）を反映し、セルフホスト環境での型推論性能を Phase 2 ベースライン ±10% に収める。

## スコープ
- **含む**: 型表現の移植、一般化/インスタンス化、型クラス解決、効果タグ検証、診断整合、計測フック。
- **含まない**: 将来拡張予定の型システム（依存型等）、メタプログラミング向け API。必要であれば Phase 4 以降。
- **前提**: Phase 2 の実装で型クラス方式が決定し、効果システム統合が安定していること。

## 作業ブレークダウン

### 1. 型表現とデータ構造（43-44週目）
**担当領域**: 型システム基盤

1.1. **Type データ型の定義**
- `1-2-types-Inference.md` の型表現を Reml で実装
- 基本型: `TVar(id: u32)`, `TCon(name: QualName)`, `TApp(con: Type, arg: Type)`, `TArrow(from: Type, to: Type)`
- 型スキーム: `TypeScheme { forall: Vec<TVar>, constraints: Vec<Constraint>, ty: Type }`
- 型クラス制約: `Constraint { class: QualName, tyvar: TVar }`
- 効果型: `Effect { tag: EffectTag, stage: CapabilityStage }`

1.2. **型環境の実装**
- 型環境: `Env = Map<Ident, TypeScheme>` の実装
- 型代入: `Subst = Map<TVar, Type>` と合成演算
- スコープ管理: ネストした環境の保持と検索
- 型変数生成器: フレッシュな型変数の生成機構

1.3. **OCaml版との互換性**
- 型表現のシリアライズ形式（JSON/Bincode）定義
- OCaml版との型情報比較ツール作成
- TypedAST の構造定義（型注釈付きAST）
- ゴールデンテスト用のスナップショット生成

**成果物**: `Core.Type.Types`, `Core.Type.Env`, `Core.Type.Subst` モジュール、型定義テスト

### 2. Hindley-Milner 推論エンジン（44-45週目）
**担当領域**: 型推論アルゴリズム

2.1. **制約ベース推論**
- 制約収集フェーズの実装（AST走査と制約生成）
- 単一化アルゴリズム（Robinson's unification）
- occurs check の実装とエラー検出
- 型代入の合成と正規化

2.2. **一般化とインスタンス化**
- let多相の一般化（generalize）: 自由型変数の∀束縛
- インスタンス化（instantiate）: 型スキームから具体型へ
- 型変数のフレッシュ生成とリネーム
- スコープ管理とレベル推論（効率化）

2.3. **型推論パイプライン**
- AST → TypedAST の変換処理
- 式・パターン・宣言の型付けルール実装
- `Result<TypedAST, TypeError>` ベースのエラー伝播
- 推論ステップの観測可能化（デバッグ用トレース）

**成果物**: `Core.Type.Infer` モジュール、推論エンジンテスト、トレース機能

### 3. 型クラス解決の移植（45-46週目）
**担当領域**: 型クラス実装

3.1. **型クラス方式の適用**
- Phase 2 決定方式（辞書渡し or モノモルフィゼーション）の実装
- 辞書型の定義: `Dict { vtable: Vec<FnPtr>, type_info: Metadata }`（辞書渡しの場合）
- 辞書引数の挿入ポイント決定
- 型パラメータ展開とマングリング（モノモルフィゼーションの場合）

3.2. **制約解決エンジン**
- 型クラス制約の収集と伝播
- スーパークラス制約の展開（例: `Ord` → `Eq`）
- デフォルト実装の解決ルール
- インスタンス検索とあいまい性検出（複数候補の警告）

3.3. **辞書/展開コード生成**
- 辞書構造体の生成（辞書渡しの場合）
- vtable レイアウトの計算（メソッド順序の決定）
- メソッド選択子の実装（vtable アクセスコード）
- 型パラメータの具体化（モノモルフィゼーションの場合）

**成果物**: `Core.Type.TypeClass` モジュール、型クラステスト、辞書生成コード

### 4. 効果システムとStage統合（46-47週目）
**担当領域**: 効果検証

4.1. **効果タグの実装**
- `1-3-effects-safety.md` の effect 注釈処理
- 効果型の定義と推論: `Effect { tag: EffectTag, stage: CapabilityStage }`
- 効果多相の一般化/インスタンス化
- 効果制約の解決（型クラスと同様の機構）

4.2. **RuntimeCapability 連携**
- `3-8-core-runtime-capability.md` の Stage 判定統合
- `verify_capability_stage` の型レベル統合
- Stage ミスマッチの検出とエラー生成
- 監査ログへの記録（`AuditEnvelope` への書き込み）

4.3. **effect推論**
- 式からの効果自動推論（関数呼び出し・FFI 等）
- FFI 呼び出しの効果検証
- 効果伝播の最小化（不要な効果タグの除去）
- 効果サブタイピング（効果の包含関係）

**成果物**: `Core.Type.Effect` モジュール、効果検証テスト、Stage 判定統合

### 5. 診断とエラーメッセージ（47-48週目）
**担当領域**: 診断システム

5.1. **型エラー診断**
- `3-6-core-diagnostics-audit.md` の Diagnostic 形式対応
- 型ミスマッチの詳細レポート（期待型 vs 実際の型）
- Span 情報を使った正確な位置表示
- 型変数の可読名付け（`'a`, `'b` 等）

5.2. **型クラス診断**
- 未解決制約の報告（"No instance for Eq i32"）
- インスタンス候補の提示（"Did you mean...?"）
- あいまいさエラーの説明（複数候補がある場合）
- スーパークラス欠落の検出（"Ord requires Eq"）

5.3. **OCaml版との診断整合**
- 診断メッセージの比較ツール
- 差分レポート生成（フォーマット差異の検出）
- 診断品質の評価（可読性・有用性）
- レグレッション防止（既存診断の保持）

**成果物**: `Core.Type.Diagnostic` モジュール、診断整合テスト、比較レポート

### 6. 性能計測と最適化（48-49週目）
**担当領域**: 性能評価

6.1. **性能ベンチマーク**
- 推論ステップ数の計測（制約生成・解決）
- 型クラス解決時間の測定
- メモリ使用量プロファイリング（型環境・代入のサイズ）
- Phase 2 ベースラインとの比較（±10% 目標）

6.2. **最適化実装**
- 型代入の最適化（永続データ構造の活用）
- 制約グラフの効率化（不要な制約の早期除去）
- インスタンス検索のキャッシュ（同一制約の再利用）
- 型クラス辞書の共有（同一辞書の重複排除）

6.3. **計測フック整備**
- `0-3-audit-and-metrics.md` への記録フォーマット定義
- CI での性能レグレッション検出（自動アラート）
- ボトルネック分析ツール（プロファイリング結果の可視化）
- 最適化効果の可視化（ビフォー・アフター比較）

**成果物**: 性能ベンチマーク、最適化版実装、計測レポート

### 7. 並行稼働とテスト（49-50週目）
**担当領域**: 品質保証

7.1. **並行稼働インフラ**
- CLI フラグ `--typer=ocaml|reml` の実装
- 両実装の TypedAST 比較ツール
- CI での並行実行設定（GitHub Actions マトリクス）
- フォールバック機構（Reml 失敗時に OCaml へ自動切替）

7.2. **統合テスト**
- `1-2-types-Inference.md` の全サンプルテスト
- 型クラス・効果の複雑な組み合わせテスト
- エッジケースの網羅（再帰型、高階関数等）
- ゴールデンテスト（TypedAST スナップショット比較）

7.3. **Phase 1 テストとの統合**
- 既存テストスイートの実行
- 型推論結果の検証
- 診断出力の比較
- テストカバレッジ計測（目標: >85%）

**成果物**: 並行稼働 CLI、統合テストスイート、カバレッジレポート

### 8. ドキュメント整備とレビュー（50-51週目）
**担当領域**: ドキュメント

8.1. **技術文書更新**
- `3-0-phase3-self-host.md` への実装詳細追記
- 型クラス方式の実装ガイド作成
- OCaml版との差異一覧の作成
- 移植ガイドの作成（開発者向け）

8.2. **メトリクス記録**
- 型推論性能の記録（推論時間・メモリ使用量）
- 型クラス解決時間の集計
- 診断整合率の計測（一致率・差異の分類）
- `0-3-audit-and-metrics.md` への反映

8.3. **レビュー資料作成**
- M2 マイルストーン達成報告書
- TypedAST/診断のサンプル出力
- 既知の制限事項と TODO リスト
- Phase 3 次タスク（3-3 クロスコンパイル）への引き継ぎ事項

**成果物**: 完全なドキュメント、メトリクス記録、レビュー資料

## 成果物と検証
- `Core.Type.*` モジュール群が実装され、CI で `reml test Core.Type` が通過すること。
- 型推論テストが Reml 実装で全て通過し、OCaml 版との差分が把握され文書化されている。
- 診断メッセージが整合し、差異がある場合は仕様更新またはフォローアップタスクが `0-4-risk-handling.md` に登録される。
- パフォーマンス計測がベースライン範囲内（±10%）で、改善が必要な場合は最適化タスクを起票。

## リスクとフォローアップ
- Reml 実装のパフォーマンスが劣る場合のフォールバックとして OCaml 版を維持し、最適化計画を別途策定。
- 効果システムとの相互作用にバグが出た場合、`3-2` と `3-5` のタスク間で調整しながら修正。
- 型クラス方式の決定が遅れると着手が遅延するため、Phase 2 の評価結果（2-1 完了時）を早期に反映する。
- 診断メッセージの品質が Phase 1-2 より低下する場合は、優先的に改善タスクを起票。

## 参考資料
- [3-0-phase3-self-host.md](3-0-phase3-self-host.md)
- [1-2-types-Inference.md](../../1-2-types-Inference.md)
- [1-3-effects-safety.md](../../1-3-effects-safety.md)
- [3-8-core-runtime-capability.md](../../3-8-core-runtime-capability.md)
- [3-6-core-diagnostics-audit.md](../../3-6-core-diagnostics-audit.md)
- [2-1-typeclass-strategy.md](2-1-typeclass-strategy.md)
- [0-3-audit-and-metrics.md](0-3-audit-and-metrics.md)
- [0-4-risk-handling.md](0-4-risk-handling.md)
