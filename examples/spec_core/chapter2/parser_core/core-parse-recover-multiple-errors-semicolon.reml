module Spec.Core.Chapter2.Parser.RecoverMultipleErrorsSemicolon

use Core.Parse as Parse
use Core.Prelude

// 文末 `;` を同期点にして、1 回の実行で複数エラーを収集する最小例。
// 期待: 欠落識別子（1件目）と欠落値（2件目）の 2 診断が蓄積される（CP-WS4-001）。

fn statement_value() -> Parse.Parser<Int> {
  Parse.expect_keyword("let")
    .skipL(Parse.expect_ident())
    .skipL(Parse.expect_symbol("="))
    .then(Parse.expect_int())
    .map(|(_, value)| value)
}

fn statement_recovering() -> Parse.Parser<Int> {
  let stmt =
    statement_value()
      .skipR(Parse.expect_symbol(";"))

  // 失敗したら `;` まで読み飛ばして 0 で継続（Step2: recover_with_default）。
  // `until` は同期点を消費する設計（2-5 §E-1）。
  Parse.recover_with_default(
    stmt,
    Parse.expect_symbol(";").map(|_| ()),
    0
  )
}

fn program() -> Parse.Parser<List<Int>> {
  Parse.many(statement_recovering())
    .skipR(Parse.expect_eof())
}

fn main() -> Str {
  let source = "let = 1; let x = ; let y = 3;"
  let first = Parse.run_with_recovery(program(), source)
  let _second = Parse.run_with_recovery(program(), source)
  match first with
    Err(diag) -> diag.to_json()
    Ok(values) -> format("ok=%s", [values.to_json()])
}
