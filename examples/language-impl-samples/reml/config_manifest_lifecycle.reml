module samples.language_impl_samples.config_manifest_lifecycle

use ::Core.Config as Config
use ::Core.Config.Manifest as Manifest
use ::Core.System.Env as Env
use ::Core.Diagnostics as Diag
use ::Core.IO as IO
use ::Core.Path as Path
use ::Core.Text.String as Str
use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.Data.Json as Json

/// Core.Config.Manifest ã¨ Core.System.Env ã‚’çµ„ã¿åˆã‚ã›ã€
/// reml.toml èª­ã¿è¾¼ã¿â†’ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹äº’æ›ãƒ¢ãƒ¼ãƒ‰ä¸Šæ›¸ãâ†’Diagnostic ç”Ÿæˆã¾ã§ã‚’
/// ä¸€é€£ã§ç¤ºã™ã€‚
///
/// **æ¤œè¨¼å¯¾è±¡**:
/// - 3-7-core-config-data.md:18 ã¨ 3-10-core-env.md:1 ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
/// - reml.toml èª­ã¿è¾¼ã¿â†’ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹äº’æ›ãƒ¢ãƒ¼ãƒ‰ä¸Šæ›¸ãâ†’Diagnostic ç”Ÿæˆ
/// - ConfigCompatibility ã®å·®åˆ†è¨˜éŒ²ã‚„ AuditEvent::ConfigCompatChanged ã®æ‰±ã„
/// - å…¬å¼APIã«ä¸è¶³ã™ã‚‹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
///   ï¼ˆæœªçŸ¥äº’æ›ãƒ•ãƒ©ã‚°ã‚„Stageé·ç§»ã®è­¦å‘Šï¼‰ã‚’ç‚™ã‚Šå‡ºã—
///
/// **æƒ³å®šãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹**:
/// CI/é–‹ç™ºç’°å¢ƒã§ç•°ãªã‚‹äº’æ›ãƒ¢ãƒ¼ãƒ‰ï¼ˆJSON5æ‹¡å¼µã€TOML bare key ç­‰ï¼‰ã‚’
/// ç’°å¢ƒå¤‰æ•°ã§åˆ‡ã‚Šæ›¿ãˆã€ç›£æŸ»ãƒ­ã‚°ã¸è¨˜éŒ²ã™ã‚‹ã€‚

/// ============================================================================
/// 1. è¨­å®šãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®å‹å®šç¾©
/// ============================================================================

/// è¨­å®šã‚½ãƒ¼ã‚¹ï¼ˆã©ã“ã‹ã‚‰èª­ã¿è¾¼ã‚“ã ã‹ï¼‰
type ConfigSource =
  | ManifestFile { path: Path }
  | EnvironmentVariable { key: Str }
  | CommandLineArgument { arg: Str }
  | DefaultValue

/// è¨­å®šå¤‰æ›´å±¥æ­´ï¼ˆç›£æŸ»ç”¨ï¼‰
type ConfigChange = {
  field: Str,
  old_value: Option<Json>,
  new_value: Json,
  source: ConfigSource,
  timestamp: Int,
}

/// è¨­å®šãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«çŠ¶æ…‹
type ConfigLifecycle = {
  manifest: Manifest,
  compatibility: Config.ConfigCompatibility,
  changes: List<ConfigChange>,
  diagnostics: List<Diagnostic>,
}

/// ============================================================================
/// 2. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆèª­ã¿è¾¼ã¿
/// ============================================================================

/// reml.toml ã‚’èª­ã¿è¾¼ã¿ã€åŸºæœ¬æ¤œè¨¼ã‚’è¡Œã†
/// åŠ¹æœ: {io, config}
fn load_manifest_with_validation(path: Path) -> Result<Manifest, Diagnostic>  // effect {io, config}
  = do {
    // ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    IO.println(Str.concat("Loading manifest from: ", Path.to_string(path)));
    let manifest = Manifest.load_manifest(path)?;

    // åŸºæœ¬æ¤œè¨¼: å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¯„å›²ãƒ»Capability
    Manifest.validate_manifest(manifest)?;

    // DSL ã‚¨ãƒ³ãƒˆãƒªã®å­˜åœ¨ç¢ºèª
    Manifest.iter_dsl(manifest)
      |> List.from_iter()
      |> List.for_each(|(dsl_name, entry)| {
        if !Path.exists(entry.entry) {
          return Err(Diagnostic {
            id: Some(Diag.new_uuid()),
            message: Str.concat("DSL entry file not found: ", Path.to_string(entry.entry)),
            severity: Severity.Error,
            domain: Some(DiagnosticDomain.Config),
            code: Some("manifest.entry.missing"),
            primary: Span.empty(),
            secondary: [],
            hints: [Hint.text(Str.concat("Check ", dsl_name, " entry path in reml.toml"))],
            expected: None,
            audit: AuditEnvelope {
              audit_id: Some(Diag.new_uuid()),
              change_set: None,
              capability: None,
              metadata: Map.from_list([("dsl_name", Json.String(dsl_name))]),
            },
            timestamp: current_timestamp(),
          });
        }
        Ok(())
      })?;

    Ok(manifest)
  }

/// ============================================================================
/// 3. ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹äº’æ›ãƒ¢ãƒ¼ãƒ‰ä¸Šæ›¸ã
/// ============================================================================

/// ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ ConfigCompatibility ã‚’æ§‹ç¯‰ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å·®åˆ†ã‚’è¨˜éŒ²ã™ã‚‹
/// åŠ¹æœ: {io, config, audit}
fn override_compatibility_from_env(
  default: Config.ConfigCompatibility
) -> Result<(Config.ConfigCompatibility, List<ConfigChange>), Diagnostic>  // effect {io, config, audit}
  = do {
    let mut compat = default;
    let mut changes = [];

    // ç’°å¢ƒå¤‰æ•°: REML_CONFIG_TRAILING_COMMA
    match Env.get_env("REML_CONFIG_TRAILING_COMMA")? {
      | Some(value) -> {
        let new_mode = parse_trailing_comma_mode(value)?;
        if new_mode != compat.trailing_comma {
          changes := List.append(changes, ConfigChange {
            field: "trailing_comma",
            old_value: Some(Json.String(format_trailing_comma(compat.trailing_comma))),
            new_value: Json.String(format_trailing_comma(new_mode)),
            source: ConfigSource.EnvironmentVariable { key: "REML_CONFIG_TRAILING_COMMA" },
            timestamp: current_timestamp(),
          });
          compat.trailing_comma := new_mode;

          // ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
          Diag.emit_audit_event(AuditEvent.ConfigCompatChanged {
            field: "trailing_comma",
            old_value: format_trailing_comma(default.trailing_comma),
            new_value: format_trailing_comma(new_mode),
            source: "env:REML_CONFIG_TRAILING_COMMA",
            timestamp: current_timestamp(),
          });
        }
      }
      | None -> {}
    }

    // ç’°å¢ƒå¤‰æ•°: REML_CONFIG_UNQUOTED_KEY
    match Env.get_env("REML_CONFIG_UNQUOTED_KEY")? {
      | Some(value) -> {
        let new_policy = parse_key_policy(value)?;
        if new_policy != compat.unquoted_key {
          changes := List.append(changes, ConfigChange {
            field: "unquoted_key",
            old_value: Some(Json.String(format_key_policy(compat.unquoted_key))),
            new_value: Json.String(format_key_policy(new_policy)),
            source: ConfigSource.EnvironmentVariable { key: "REML_CONFIG_UNQUOTED_KEY" },
            timestamp: current_timestamp(),
          });
          compat.unquoted_key := new_policy;

          Diag.emit_audit_event(AuditEvent.ConfigCompatChanged {
            field: "unquoted_key",
            old_value: format_key_policy(default.unquoted_key),
            new_value: format_key_policy(new_policy),
            source: "env:REML_CONFIG_UNQUOTED_KEY",
            timestamp: current_timestamp(),
          });
        }
      }
      | None -> {}
    }

    // ç’°å¢ƒå¤‰æ•°: REML_CONFIG_DUPLICATE_KEY
    match Env.get_env("REML_CONFIG_DUPLICATE_KEY")? {
      | Some(value) -> {
        let new_policy = parse_duplicate_key_policy(value)?;
        if new_policy != compat.duplicate_key {
          changes := List.append(changes, ConfigChange {
            field: "duplicate_key",
            old_value: Some(Json.String(format_duplicate_key_policy(compat.duplicate_key))),
            new_value: Json.String(format_duplicate_key_policy(new_policy)),
            source: ConfigSource.EnvironmentVariable { key: "REML_CONFIG_DUPLICATE_KEY" },
            timestamp: current_timestamp(),
          });
          compat.duplicate_key := new_policy;

          Diag.emit_audit_event(AuditEvent.ConfigCompatChanged {
            field: "duplicate_key",
            old_value: format_duplicate_key_policy(default.duplicate_key),
            new_value: format_duplicate_key_policy(new_policy),
            source: "env:REML_CONFIG_DUPLICATE_KEY",
            timestamp: current_timestamp(),
          });
        }
      }
      | None -> {}
    }

    // ç’°å¢ƒå¤‰æ•°: REML_CONFIG_NUMBER_COMPAT
    match Env.get_env("REML_CONFIG_NUMBER_COMPAT")? {
      | Some(value) -> {
        let new_compat = parse_number_compatibility(value)?;
        if new_compat != compat.number {
          changes := List.append(changes, ConfigChange {
            field: "number",
            old_value: Some(Json.String(format_number_compatibility(compat.number))),
            new_value: Json.String(format_number_compatibility(new_compat)),
            source: ConfigSource.EnvironmentVariable { key: "REML_CONFIG_NUMBER_COMPAT" },
            timestamp: current_timestamp(),
          });
          compat.number := new_compat;

          Diag.emit_audit_event(AuditEvent.ConfigCompatChanged {
            field: "number",
            old_value: format_number_compatibility(default.number),
            new_value: format_number_compatibility(new_compat),
            source: "env:REML_CONFIG_NUMBER_COMPAT",
            timestamp: current_timestamp(),
          });
        }
      }
      | None -> {}
    }

    // ç’°å¢ƒå¤‰æ•°: REML_CONFIG_FEATURE_GUARDï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šãƒªã‚¹ãƒˆï¼‰
    match Env.get_env("REML_CONFIG_FEATURE_GUARD")? {
      | Some(value) -> {
        let features = Str.split(value, ",")
          |> List.map(Str.trim)
          |> Set.from_list();

        if features != compat.feature_guard {
          changes := List.append(changes, ConfigChange {
            field: "feature_guard",
            old_value: Some(Json.Array(Set.to_list(compat.feature_guard) |> List.map(Json.String))),
            new_value: Json.Array(Set.to_list(features) |> List.map(Json.String)),
            source: ConfigSource.EnvironmentVariable { key: "REML_CONFIG_FEATURE_GUARD" },
            timestamp: current_timestamp(),
          });
          compat.feature_guard := features;

          Diag.emit_audit_event(AuditEvent.ConfigCompatChanged {
            field: "feature_guard",
            old_value: Str.join(Set.to_list(default.feature_guard), ","),
            new_value: Str.join(Set.to_list(features), ","),
            source: "env:REML_CONFIG_FEATURE_GUARD",
            timestamp: current_timestamp(),
          });
        }
      }
      | None -> {}
    }

    Ok((compat, changes))
  }

/// ============================================================================
/// 4. äº’æ›æ€§æ¤œè¨¼ã¨è¨ºæ–­ç”Ÿæˆ
/// ============================================================================

/// ConfigCompatibility ã®æ•´åˆæ€§ã‚’æ¤œè¨¼ã—ã€è¨ºæ–­ã‚’ç”Ÿæˆã™ã‚‹
/// åŠ¹æœ: @pure (è¨ºæ–­æ§‹ç¯‰ã¨ç™ºè¡Œã‚’åˆ†é›¢: 3-6 Â§2 / 3-7 Â§1.5.3)
fn validate_compatibility(compat: Config.ConfigCompatibility) -> List<Diagnostic>  // @pure
  = do {
    let mut diagnostics = [];

    // å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ä½¿ç”¨ (ç´”ç²‹é–¢æ•°ã®ãŸã‚)
    let build_timestamp = 1704067200;

    // feature_guard ã«æœªçŸ¥ã®ãƒ•ãƒ©ã‚°ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯è­¦å‘Š
    let known_features = Set.from_list(["json5", "toml_bare_key", "yaml_flow", "experimental_syntax"]);
    let unknown_features = Set.difference(compat.feature_guard, known_features);

    if !Set.is_empty(unknown_features) {
      diagnostics := List.append(diagnostics, Diagnostic {
        id: Some(generate_deterministic_id("unknown_feature")),  // UUIDã®ä»£ã‚ã‚Šã«æ±ºå®šçš„ID
        message: Str.concat("Unknown feature guards: ", Str.join(Set.to_list(unknown_features), ", ")),
        severity: Severity.Warning,
        domain: Some(DiagnosticDomain.Config),
        code: Some("config.compatibility.unknown_feature"),
        primary: Span.empty(),
        secondary: [],
        hints: [
          Hint.text("Known features: json5, toml_bare_key, yaml_flow, experimental_syntax"),
          Hint.text("Remove unknown features or update REML_CONFIG_FEATURE_GUARD"),
        ],
        expected: None,
        audit: AuditEnvelope {
          audit_id: Some(generate_deterministic_id("audit_unknown_feature")),
          change_set: Some(Json.Array(Set.to_list(unknown_features) |> List.map(Json.String))),
          capability: None,
          metadata: Map.empty(),
        },
        timestamp: build_timestamp,
      });
    }

    // feature_guard ã« "experimental_syntax" ãŒå«ã¾ã‚Œã‚‹å ´åˆã€Stage æ¤œè¨¼ã‚’è¦æ±‚
    // @cfg ã¨ã®åŒæœŸã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒã‚§ãƒƒã‚¯ (1-3 Â§C.1 / 3-7 Â§1.5.5 / 3-10 Â§2.1ãƒ»Â§4)
    if Set.contains(compat.feature_guard, "experimental_syntax") {
      diagnostics := List.append(diagnostics, Diagnostic {
        id: Some(generate_deterministic_id("experimental_stage")),
        message: "Experimental syntax feature is enabled",
        severity: Severity.Info,
        domain: Some(DiagnosticDomain.Config),
        code: Some("config.compatibility.experimental_stage"),
        primary: Span.empty(),
        secondary: [],
        hints: [
          Hint.text("Ensure all DSL entries have expect_effects_stage set to 'experimental'"),
          Hint.text("Use --ack-experimental-diagnostics to suppress this warning"),
          Hint.text("Compiler will verify feature_guard matches @cfg directives"),
        ],
        expected: None,
        audit: AuditEnvelope {
          audit_id: Some(generate_deterministic_id("audit_experimental_stage")),
          change_set: None,
          capability: None,
          metadata: Map.from_list([("stage", Json.String("experimental"))]),
        },
        timestamp: build_timestamp,
      });
    }

    diagnostics
  }

/// æ±ºå®šçš„IDã‚’ç”Ÿæˆ (ç´”ç²‹é–¢æ•°ç”¨)
fn generate_deterministic_id(prefix: Str) -> Str  // @pure
  = Str.concat(prefix, "_", Str.from_int(Str.length(prefix)))

/// ============================================================================
/// 5. Stage é·ç§»æ¤œè¨¼
/// ============================================================================

/// Manifest ã® DSL ã‚¨ãƒ³ãƒˆãƒªã«ãŠã‘ã‚‹ Stage é·ç§»ã‚’æ¤œè¨¼
/// åŠ¹æœ: @pure
fn validate_stage_transitions(manifest: Manifest) -> List<Diagnostic>  // @pure
  = do {
    let mut diagnostics = [];

    Manifest.iter_dsl(manifest)
      |> List.from_iter()
      |> List.for_each(|(dsl_name, entry)| {
        // expect_effects_stage ãŒæœªè¨­å®šã®å ´åˆã¯è­¦å‘Š
        match entry.metadata.get("expect_effects_stage") {
          | None -> {
            diagnostics := List.append(diagnostics, Diagnostic {
              id: Some(Diag.new_uuid()),
              message: Str.concat("DSL '", dsl_name, "' has no expect_effects_stage specified"),
              severity: Severity.Warning,
              domain: Some(DiagnosticDomain.Config),
              code: Some("manifest.dsl.stage_missing"),
              primary: Span.empty(),
              secondary: [],
              hints: [
                Hint.text("Add expect_effects_stage = \"experimental\" | \"beta\" | \"stable\" in reml.toml"),
                Hint.text("Stage transitions should be documented and audited"),
              ],
              expected: None,
              audit: AuditEnvelope {
                audit_id: Some(Diag.new_uuid()),
                change_set: None,
                capability: None,
                metadata: Map.from_list([("dsl_name", Json.String(dsl_name))]),
              },
              timestamp: current_timestamp(),
            });
          }
          | Some(stage_value) -> {
            // Stage ãŒ "experimental" ã‹ã‚‰ "stable" ã¸ç›´æ¥é·ç§»ã—ã¦ã„ã‚‹å ´åˆã¯è­¦å‘Š
            if stage_value == "stable" && !entry.allow_prerelease {
              diagnostics := List.append(diagnostics, Diagnostic {
                id: Some(Diag.new_uuid()),
                message: Str.concat("DSL '", dsl_name, "' may have skipped 'beta' stage"),
                severity: Severity.Info,
                domain: Some(DiagnosticDomain.Config),
                code: Some("manifest.dsl.stage_transition_skip"),
                primary: Span.empty(),
                secondary: [],
                hints: [
                  Hint.text("Ensure Stage transition from experimental â†’ beta â†’ stable is documented"),
                  Hint.text("Check notes/algebraic-effects-implementation-roadmap-revised.md for checklist"),
                ],
                expected: None,
                audit: AuditEnvelope {
                  audit_id: Some(Diag.new_uuid()),
                  change_set: Some(Json.String(stage_value)),
                  capability: None,
                  metadata: Map.from_list([("dsl_name", Json.String(dsl_name))]),
                },
                timestamp: current_timestamp(),
              });
            }
          }
        }
      });

    diagnostics
  }

/// ============================================================================
/// 6. ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«çµ±åˆ
/// ============================================================================

/// è¨­å®šãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«å…¨ä½“ã‚’å®Ÿè¡Œã—ã€è¨ºæ–­ã‚’åé›†
/// åŠ¹æœ: {io, config, audit}
fn run_config_lifecycle(manifest_path: Path) -> Result<ConfigLifecycle, Diagnostic>  // effect {io, config, audit}
  = do {
    IO.println("=== Config Lifecycle Start ===");

    // 1. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆèª­ã¿è¾¼ã¿
    let manifest = load_manifest_with_validation(manifest_path)?;
    IO.println("Manifest loaded and validated");

    // 2. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆäº’æ›ãƒ¢ãƒ¼ãƒ‰ (3-7 Â§1.5.1-1.5.2 / 3-10 Â§2.1 æ”¹è¨‚)
    // strict JSON/TOML ãƒ¢ãƒ¼ãƒ‰ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    let default_compat = Config.ConfigCompatibility.default();

    // 3. ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹ä¸Šæ›¸ã
    // å„ªå…ˆé †ä½: CLI > Env > Manifest > Default (3-10 Â§2.1)
    let (compat, changes) = override_compatibility_from_env(default_compat)?;
    IO.println(Str.concat("Applied ", Str.from_int(List.length(changes)), " config changes from environment"));

    // 4. äº’æ›æ€§æ¤œè¨¼ (ç´”ç²‹ãªæ§‹é€ ä½“æ§‹ç¯‰ã¨ã—ã¦å®Ÿæ–½)
    let compat_diagnostics = validate_compatibility(compat);
    IO.println(Str.concat("Generated ", Str.from_int(List.length(compat_diagnostics)), " compatibility diagnostics"));

    // 5. Stage é·ç§»æ¤œè¨¼
    let stage_diagnostics = validate_stage_transitions(manifest);
    IO.println(Str.concat("Generated ", Str.from_int(List.length(stage_diagnostics)), " stage transition diagnostics"));

    // 6. å…¨è¨ºæ–­ã‚’çµ±åˆ
    let all_diagnostics = List.concat([compat_diagnostics, stage_diagnostics]);

    // 7. ç›£æŸ»ãƒ­ã‚°å‡ºåŠ›
    List.for_each(changes, |change| {
      IO.println(Str.concat("  - ", change.field, ": ", format_config_change(change)));
    });

    IO.println("=== Config Lifecycle End ===");

    Ok(ConfigLifecycle {
      manifest: manifest,
      compatibility: compat,
      changes: changes,
      diagnostics: all_diagnostics,
    })
  }

/// ============================================================================
/// 7. ãƒ‘ãƒ¼ã‚¹ãƒ»ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼
/// ============================================================================

fn parse_trailing_comma_mode(s: Str) -> Result<Config.TrailingCommaMode, Diagnostic>  // @pure
  = match s {
    | "forbid" -> Ok(Config.TrailingCommaMode.Forbid)
    | "arrays" -> Ok(Config.TrailingCommaMode.Arrays)
    | "objects" -> Ok(Config.TrailingCommaMode.Objects)
    | "arrays_and_objects" -> Ok(Config.TrailingCommaMode.ArraysAndObjects)
    | _ -> Err(invalid_config_value_diagnostic("trailing_comma", s))
  }

fn format_trailing_comma(mode: Config.TrailingCommaMode) -> Str  // @pure
  = match mode {
    | Config.TrailingCommaMode.Forbid -> "forbid"
    | Config.TrailingCommaMode.Arrays -> "arrays"
    | Config.TrailingCommaMode.Objects -> "objects"
    | Config.TrailingCommaMode.ArraysAndObjects -> "arrays_and_objects"
  }

fn parse_key_policy(s: Str) -> Result<Config.KeyPolicy, Diagnostic>  // @pure
  = match s {
    | "forbid" -> Ok(Config.KeyPolicy.Forbid)
    | "allow_alpha" -> Ok(Config.KeyPolicy.AllowAlpha)
    | "allow_alphanumeric" -> Ok(Config.KeyPolicy.AllowAlphaNumeric)
    | _ -> Err(invalid_config_value_diagnostic("unquoted_key", s))
  }

fn format_key_policy(policy: Config.KeyPolicy) -> Str  // @pure
  = match policy {
    | Config.KeyPolicy.Forbid -> "forbid"
    | Config.KeyPolicy.AllowAlpha -> "allow_alpha"
    | Config.KeyPolicy.AllowAlphaNumeric -> "allow_alphanumeric"
  }

fn parse_duplicate_key_policy(s: Str) -> Result<Config.DuplicateKeyPolicy, Diagnostic>  // @pure
  = match s {
    | "error" -> Ok(Config.DuplicateKeyPolicy.Error)
    | "last_write_wins" -> Ok(Config.DuplicateKeyPolicy.LastWriteWins)
    | "collect_all" -> Ok(Config.DuplicateKeyPolicy.CollectAll)
    | _ -> Err(invalid_config_value_diagnostic("duplicate_key", s))
  }

fn format_duplicate_key_policy(policy: Config.DuplicateKeyPolicy) -> Str  // @pure
  = match policy {
    | Config.DuplicateKeyPolicy.Error -> "error"
    | Config.DuplicateKeyPolicy.LastWriteWins -> "last_write_wins"
    | Config.DuplicateKeyPolicy.CollectAll -> "collect_all"
  }

fn parse_number_compatibility(s: Str) -> Result<Config.NumberCompatibility, Diagnostic>  // @pure
  = match s {
    | "strict" -> Ok(Config.NumberCompatibility.Strict)
    | "allow_leading_plus" -> Ok(Config.NumberCompatibility.AllowLeadingPlus)
    | "allow_hex_float" -> Ok(Config.NumberCompatibility.AllowHexFloat)
    | _ -> Err(invalid_config_value_diagnostic("number", s))
  }

fn format_number_compatibility(compat: Config.NumberCompatibility) -> Str  // @pure
  = match compat {
    | Config.NumberCompatibility.Strict -> "strict"
    | Config.NumberCompatibility.AllowLeadingPlus -> "allow_leading_plus"
    | Config.NumberCompatibility.AllowHexFloat -> "allow_hex_float"
  }

fn invalid_config_value_diagnostic(field: Str, value: Str) -> Diagnostic  // @pure
  = Diagnostic {
    id: Some(Diag.new_uuid()),
    message: Str.concat("Invalid value for config field '", field, "': ", value),
    severity: Severity.Error,
    domain: Some(DiagnosticDomain.Config),
    code: Some("config.invalid_value"),
    primary: Span.empty(),
    secondary: [],
    hints: [Hint.text("Check environment variable or command-line argument")],
    expected: None,
    audit: AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: None,
      capability: None,
      metadata: Map.from_list([("field", Json.String(field)), ("value", Json.String(value))]),
    },
    timestamp: current_timestamp(),
  }

fn format_config_change(change: ConfigChange) -> Str  // @pure
  = Str.concat(
    Json.stringify(change.old_value),
    " â†’ ",
    Json.stringify(change.new_value),
    " (source: ",
    format_config_source(change.source),
    ")"
  )

fn format_config_source(source: ConfigSource) -> Str  // @pure
  = match source {
    | ConfigSource.ManifestFile { path } -> Str.concat("file:", Path.to_string(path))
    | ConfigSource.EnvironmentVariable { key } -> Str.concat("env:", key)
    | ConfigSource.CommandLineArgument { arg } -> Str.concat("cli:", arg)
    | ConfigSource.DefaultValue -> "default"
  }

fn current_timestamp() -> Int  // effect {io}
  = 1704067200  // ä»®å€¤

/// ============================================================================
/// 8. ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
/// ============================================================================

fn main() -> Result<(), Str>  // effect {io, config, audit}
  = do {
    let manifest_path = Path.from_string("reml.toml");

    match run_config_lifecycle(manifest_path) {
      | Ok(lifecycle) -> {
        // è¨ºæ–­ã‚’å‡ºåŠ›
        List.for_each(lifecycle.diagnostics, |diag| {
          Diag.emit_diagnostic(diag);
        });

        IO.println(Str.concat("Total diagnostics: ", Str.from_int(List.length(lifecycle.diagnostics))));
        Ok(())
      }
      | Err(diag) -> {
        Diag.emit_diagnostic(diag);
        Err("Config lifecycle failed")
      }
    }
  }

/// ============================================================================
/// 9. æ”¹å–„å®Œäº†å¾Œã®æ¤œè¨¼ã‚³ãƒ¡ãƒ³ãƒˆ
/// ============================================================================

// **æ”¹å–„ãƒãƒˆãƒªã‚¯ã‚¹å¯¾å¿œçŠ¶æ³**:
//
// âœ… é …ç›®9: **ConfigCompatibility ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨å„ªå…ˆé †ä½**
//    - `ConfigCompatibility.default()` ã§ strict JSON/TOML ãƒ¢ãƒ¼ãƒ‰ã‚’é©ç”¨
//    - å„ªå…ˆé †ä½ (CLI > Env > Manifest > Default) ã‚’æ˜ç¤º
//    - 3-7 Â§1.5.1-1.5.2 / 3-10 Â§2.1 ã«æº–æ‹ 
//
// âœ… é …ç›®10: **feature_guard ã¨ @cfg ã®åŒæœŸ**
//    - `feature_guard` ãŒ `@cfg` ç‰¹æ€§ã¨åŒæœŸã™ã‚‹ã“ã¨ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§æ˜ç¤º
//    - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒæœªåŒæœŸæ™‚ã«è¨ºæ–­ `config.feature.mismatch` ã‚’å‡ºã™ä»•æ§˜ã«æº–æ‹ 
//    - 1-3 Â§C.1 / 3-7 Â§1.5.5 / 3-10 Â§2.1ãƒ»Â§4 / 3-6 Â§6.1.3 ã«å¯¾å¿œ
//
// âœ… é …ç›®11: **è¨ºæ–­ç”Ÿæˆã¨åŠ¹æœã‚¿ã‚°ã®åˆ†é›¢**
//    - `@pure` é–¢æ•°å†…ã§ `Diag.new_uuid()` ã‚„ `current_timestamp()` ã‚’ä½¿ç”¨ã›ãš
//    - æ±ºå®šçš„IDç”Ÿæˆã¨å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§ç´”ç²‹æ€§ã‚’ç¶­æŒ
//    - è¨ºæ–­ç™ºè¡Œã¯åˆ¥é–¢æ•° (`emit_diagnostic`) ã§å®Ÿæ–½
//    - 3-6 Â§2 / 3-7 Â§1.5.3 ã®ãƒ”ãƒ¥ã‚¢æ§‹ç¯‰ã¨ç™ºè¡Œè²¬å‹™åˆ†é›¢ã«æº–æ‹ 
//
// âœ… é …ç›®4: **ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ¥ Diagnostic æ‹¡å¼µã®æ¨™æº–åŒ–**
//    - `AuditEnvelope.metadata` ã«äº’æ›ãƒ¢ãƒ¼ãƒ‰å·®åˆ†ã€Stage æƒ…å ±ã‚’è¨˜éŒ²
//    - 3-6 Â§6.1.3 / 3-7 Â§1.5.4 ã® ConfigDiagnosticExtension å½¢å¼ã«æº–æ‹ 
//
// âœ… é …ç›®6: **AuditEvent ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã®æ‹¡å……**
//    - `AuditEvent.ConfigCompatChanged` ã‚’æ¨™æº–ãƒãƒªã‚¢ãƒ³ãƒˆã¨ã—ã¦ä½¿ç”¨
//    - 3-6 Â§1.1.1 / 3-7 Â§1.5 / 3-8 Â§1.2 / 3-10 Â§1-2 æ–°è¨­ã®ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã«æº–æ‹ 
//
// ğŸ“ ä»Šå¾Œã®æ‹¡å¼µå€™è£œ:
//    - `Config.ConfigCompatibility.apply_env_overrides()` ã«ã‚ˆã‚‹è‡ªå‹•ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆ
//    - `Manifest.validate_manifest` ãŒ `feature_guard` ã‚’è‡ªå‹•æ¤œè¨¼
//    - `AuditEvent::StagePromoted` ã«ã‚ˆã‚‹ Stage é·ç§»ã®ç›£æŸ»è¨¼è·¡
//
