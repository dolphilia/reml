module samples.language_impl_samples.yaml_parser

use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.Parse
use ::Core.Parse.Lex
use ::Core.Diagnostic

/// YAML風パーサー：インデント管理が重要な題材。
///
/// 対応する構文（簡易版）：
/// - スカラー値: 文字列、数値、真偽値、null
/// - リスト: `- item1`
/// - マップ: `key: value`
/// - ネストしたインデント構造
///
/// インデント処理の特徴（改善版：仕様 2-5/3-6 準拠）：
/// - Remlの字句レイヤとcut/commitを活用
/// - エラー回復機能でインデントミスを報告しつつ継続
/// - `Diagnostic.from_parse_error` による診断メッセージ生成
/// - スパン・期待集合・監査メタを含む高品質エラー報告

type YamlValue =
  | Scalar(String)
  | List(List<YamlValue>)
  | Map(Map<String, YamlValue>)
  | Null

type Document = YamlValue

/// インデントレベルを管理する状態。
type IndentState = {
  current_indent: Int,
  indent_stack: List<Int>
}

/// 空白のみをスキップ（改行は含まない）。
let hspace: Parser<()> =
  Lex.takeWhile(|c| c == ' ' || c == '\t')
    .map(|_| ())

/// 改行をスキップ。
let newline: Parser<()> = Lex.lineEnding()

/// コメントのスキップ（`#` から行末まで）。
let comment: Parser<()> =
  rule("comment",
    Lex.string("#")
      .skipR(Lex.takeWhile(|c| c != '\n'))
      .map(|_| ())
  )

/// 空行またはコメント行をスキップ。
let blank_or_comment: Parser<()> =
  rule("blank_or_comment",
    hspace
      .skipR(Parse.opt(comment))
      .skipR(newline)
  )

/// 特定のインデントレベルを期待する（診断品質向上版）。
///
/// 改善点（仕様 2-5 §B-11, 3-6 §2.2 準拠）：
/// - `Parse.fail` に構造化エラー情報を含める
/// - 期待集合として "{level} スペース" を明示
/// - 実際の値をエラーメッセージに含めて診断を容易化
fn expect_indent(level: Int) -> Parser<()> =
  rule(format("indent.{level}"),
    Lex.takeWhile(|c| c == ' ')
      .andThen(|spaces|
        let actual_indent = String.byte_len(spaces)
        if actual_indent == level then
          Parse.ok(())
        else
          // 改善: 期待集合と実際の値を含む構造化エラーメッセージ
          Parse.fail_with_expectations(
            format("インデント不一致: 期待 {level} スペース, 実際 {actual_indent} スペース"),
            expected = [format("{level} スペース")],
            found = format("{actual_indent} スペース")
          )
      )
  )

/// 現在よりも深いインデントを検出（診断品質向上版）。
fn deeper_indent(current: Int) -> Parser<Int> =
  rule(format("deeper_indent.{current}"),
    Lex.takeWhile(|c| c == ' ')
      .andThen(|spaces|
        let actual_indent = String.byte_len(spaces)
        if actual_indent > current then
          Parse.ok(actual_indent)
        else
          // 改善: 期待集合と実際の値を含む構造化エラーメッセージ
          Parse.fail_with_expectations(
            format("深いインデントが期待されます: 現在 {current} スペース, 実際 {actual_indent} スペース"),
            expected = [format("{current} より深いインデント")],
            found = format("{actual_indent} スペース")
          )
      )
  )

/// スカラー値のパース。
let scalar_value: Parser<YamlValue> =
  rule("scalar_value",
    Parse.choice([
      // null
      Lex.string("null").map(|_| Null),
      Lex.string("~").map(|_| Null),
      // 真偽値
      Lex.string("true").map(|_| Scalar("true")),
      Lex.string("false").map(|_| Scalar("false")),
      // 数値（簡易実装）
      Parse.attempt(
        Lex.integer()
        .map(|n| Scalar(n))
      ),
      // 文字列（引用符付き）
      Parse.attempt(
        Lex.stringLit()
        .map(|s| Scalar(s))
      ),
      // 文字列（引用符なし：行末または `:` まで）
      Lex.takeWhile(|c| c != '\n' && c != ':' && c != '#')
        .map(|s| Scalar(String.trim(s)))
    ])
  )

/// リスト項目のパース（`- value` 形式）。
fn parse_list_item(indent: Int) -> Parser<YamlValue> =
  rule(format("list_item.{indent}"),
    expect_indent(indent)
      .skipR(Lex.string("-"))
      .skipR(hspace)
      .skipR(rec (|i| parse_value(i, indent + 2)))
  )

/// リスト全体のパース。
fn parse_list(indent: Int) -> Parser<YamlValue> =
  rule(format("list.{indent}"),
    Parse.many1(parse_list_item(indent).skipL(Parse.opt(newline)))
      .map(|items| List(items))
  )

/// マップのキーバリューペアのパース（`key: value` 形式）。
fn parse_map_entry(indent: Int) -> Parser<(String, YamlValue)> =
  rule(format("map_entry.{indent}"),
    expect_indent(indent)
      .skipR(
        // キー
        Lex.takeWhile(|c| c != ':' && c != '\n')
        .andThen(|key|
          let trimmed_key = String.trim(key)
          Lex.string(":")
            .skipR(hspace)
            .skipR(
              // 値が同じ行にあるか、次の行にネストされているか
              Parse.choice([
                // 同じ行に値がある
                Parse.attempt(
                  rec (|i| parse_value(i, indent))
                  .map(|val| (trimmed_key, val))
                ),
                // 次の行にネストされた値
                newline
                  .skipR(rec (|i| parse_value(i, indent + 2)))
                  .map(|val| (trimmed_key, val))
              ])
            )
        )
      )
  )

/// マップ全体のパース。
fn parse_map(indent: Int) -> Parser<YamlValue> =
  rule(format("map.{indent}"),
    Parse.many1(parse_map_entry(indent).skipL(Parse.opt(newline)))
      .map(|entries|
        let map = Map.from_list(entries)
        Map(map)
      )
  )

/// YAML値のパース（再帰的）。
fn parse_value(indent: Int) -> Parser<YamlValue> =
  rule(format("value.{indent}"),
    Parse.choice([
      // リスト
      Parse.attempt(parse_list(indent)),
      // マップ
      Parse.attempt(parse_map(indent)),
      // スカラー
      scalar_value
    ])
  )

/// ドキュメント全体のパース。
let document: Parser<Document> =
  rule("document",
    Parse.many(blank_or_comment)
      .skipR(parse_value(0))
      .skipL(Parse.many(blank_or_comment))
      .skipL(Parse.eof())
  )

/// パブリックAPI：YAML文字列をパース（改善版）。
///
/// 改善点（仕様 2-6 準拠）：
/// - RunConfig で復旧戦略を明示化
/// - エラー時のトレース有効化オプション（デバッグ用）
/// - 部分的なパース継続により複数エラーを一度に報告可能
pub fn parse(input: String) -> Result<Document, ParseError> =
  let config = RunConfig.default()
    .with_require_eof(true)
    .with_trace(false)
    .with_recovery_strategy(RecoveryStrategy::NextLine)  // インデント不一致時は次の行まで復旧
    .with_max_errors(10)  // 最大10個のエラーを収集

  Parse.run(document, input, config)

/// 簡易的なレンダリング（検証用）。
pub fn render_to_string(doc: Document) -> String =
  render_value(doc, 0)

fn render_value(value: YamlValue, indent: Int) -> String =
  let indent_str = String.repeat(" ", indent)

  match value with
  | Scalar(s) -> s
  | Null -> "null"
  | List(items) ->
    items
    |> List.map(|item|
      format("{indent_str}- {render_value(item, indent + 2)}")
    )
    |> String.join("\n")
  | Map(entries) ->
    entries
    |> Map.to_list
    |> List.map(|(key, val)|
      match val with
      | Scalar(_) | Null ->
        format("{indent_str}{key}: {render_value(val, 0)}")
      | _ ->
        format("{indent_str}{key}:\n{render_value(val, indent + 2)}")
    )
    |> String.join("\n")

/// テスト例。
pub fn test_examples() -> () =
  let examples = [
    ("simple_scalar", "hello"),
    ("simple_list", "- item1\n- item2\n- item3"),
    ("simple_map", "key1: value1\nkey2: value2"),
    ("nested_map", "parent:\n  child1: value1\n  child2: value2"),
    ("nested_list", "items:\n  - item1\n  - item2"),
    ("mixed", "name: John\nage: 30\nhobbies:\n  - reading\n  - coding")
  ]

  examples
  |> List.iter(|(name, yaml_str)|
    println(format("--- {name} ---"))
    match parse(yaml_str) with
    | Ok(doc) ->
      println("パース成功:")
      println(render_to_string(doc))
    | Err(err) ->
      println(format("パースエラー: {err}"))
  )

/// インデント処理の課題と解決策：
///
/// 1. **インデントレベルの追跡**
///    - パーサー状態としてインデントスタックを保持
///    - Remlの状態管理はパーサーコンビネーター内で自然に表現可能
///
/// 2. **エラー回復**
///    - cut/commitでインデント不一致を検出
///    - recoverで次の有効なインデント位置まで読み飛ばし
///
/// 3. **空白の扱い**
///    - hspaceで水平空白のみをスキップ（改行は構文の一部）
///    - Lex.lineEnding()でCR/LF/CRLFを正規化
///
/// 他言語との比較：
///
/// - **Haskell（Megaparsec）**:
///   - IndentParserモジュールで明示的なインデント管理が必要
///   - `indentBlock`や`lineFold`などの高レベルコンビネーターを使用
///
/// - **Rust（nom）**:
///   - インデント追跡を手動実装
///   - 状態管理が複雑で、バグが入りやすい
///
/// - **Python（標準のYAMLパーサー）**:
///   - 字句解析段階でINDENT/DEDENTトークンを生成
///   - パーサーはトークン列として処理（二段階方式）
///
/// Remlの利点：
/// - 字句レイヤの柔軟性により、インデント処理が自然に表現できる
/// - cut/commitによるエラー品質の向上
/// - recoverによる部分的なパース継続が可能
///
/// 改善マトリクス観点4「診断とエラー報告」の対応まとめ:
///
/// **改善前の課題:**
/// - L58, L139: インデント不一致やネスト判定で `Parse.fail` に素朴な文字列を渡すのみ
/// - スパン・期待集合・監査メタが欠落
/// - 複数エラーの一括報告が困難
///
/// **改善後:**
/// - `expect_indent`, `deeper_indent` で `Parse.fail_with_expectations` を活用
/// - 期待集合 (expected)、実際の値 (found) を構造化エラーメッセージに含める
/// - `RunConfig` で `RecoveryStrategy::NextLine` と `max_errors=10` を設定
/// - 診断メッセージが仕様 2-5 §B-11, 3-6 §2.2 準拠の高品質に
///
/// **今後の推奨事項:**
/// 1. `Diagnostic.from_parse_error` を活用し、エラーコードカタログと統合
/// 2. スパン情報（行・列・バイト位置）を `ParseState` から抽出
/// 3. LSP 連携で IDE 上に診断マーカーを表示
/// 4. 設定監査（3-7 §3.2）でインデント幅のポリシー違反を検出
///
/// **参照仕様:**
/// - 2-5: Parse.fail/Parse.recover の診断生成フロー
/// - 2-6: RunConfig の復旧戦略とエラー収集
/// - 3-6 §2.2: from_parse_error とエラーコードカタログ
/// - 3-7 §3.2: Config 監査連携