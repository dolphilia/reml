module samples.language_impl_samples.async_actor_supervision

use ::Core.Async as Async
use ::Core.Runtime as Runtime
use ::Core.Diagnostics as Diag
use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.IO as IO
use ::Core.Text.String as Str

/// Core.Async ã® Actor/Channel API ã¨ CapabilityRegistry ã‚’ç”¨ã„ãŸ
/// ç°¡æ˜“ãƒãƒ£ãƒƒãƒˆ or ãƒ¯ãƒ¼ã‚¯ã‚­ãƒ¥ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã€‚
///
/// **æ¤œè¨¼å¯¾è±¡**:
/// - 3-8-core-runtime-capability.md:96 ã§ç¤ºã•ã‚Œã‚‹ Stage æ¤œè¨¼
/// - effect {io.async} ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’ã‚³ãƒ¼ãƒ‰ã§å†ç¾
/// - AsyncError ã®ä¼æ’­ã‚„ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ã‚’ç¢ºèª
/// - ä¸¦è¡Œä¾‹ã«ã‚ˆã‚ŠéåŒæœŸå¥‘ç´„ã®æ›–æ˜§ã•
///   ï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©æ§‹æˆã‚„backpressureãƒ¡ãƒˆãƒªã‚¯ã‚¹ï¼‰ã‚’ç‰¹å®š
///
/// **æƒ³å®šãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹**:
/// è¤‡æ•°ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒéåŒæœŸã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ã—ã€ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ãŒ
/// ã‚¨ãƒ©ãƒ¼ç›£è¦–ãƒ»å†èµ·å‹•ãƒ»ç›£æŸ»ãƒ­ã‚°è¨˜éŒ²ã‚’è¡Œã†ã€‚

/// ============================================================================
/// 1. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‹å®šç¾©
/// ============================================================================

/// ãƒ¯ãƒ¼ã‚«ãƒ¼ã¸é€ä¿¡ã™ã‚‹ã‚¿ã‚¹ã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
type TaskMessage =
  | Process { id: Int, payload: Str }
  | Shutdown

/// ãƒ¯ãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã¸ã®å¿œç­”
type WorkerResponse =
  | Success { id: Int, result: Str }
  | Failure { id: Int, error: Str }
  | WorkerReady { worker_id: Int }

/// ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã‚³ãƒãƒ³ãƒ‰
type SupervisorCommand =
  | SubmitTask { id: Int, payload: Str }
  | RestartWorker { worker_id: Int }
  | GetStats
  | Terminate

/// ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã‹ã‚‰ã®å¿œç­”
type SupervisorResponse =
  | TaskQueued { id: Int }
  | WorkerRestarted { worker_id: Int }
  | Stats { tasks_completed: Int, tasks_failed: Int, workers_active: Int }
  | Terminated

/// ============================================================================
/// 2. Actor å®šç¾©: ãƒ¯ãƒ¼ã‚«ãƒ¼
/// ============================================================================

/// ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¢ã‚¯ã‚¿ãƒ¼: ã‚¿ã‚¹ã‚¯ã‚’å—ã‘å–ã‚Šå‡¦ç†ã™ã‚‹
/// åŠ¹æœ: {io.async, audit}
fn worker_actor(
  worker_id: Int,
  supervisor: Async.DslSender<WorkerResponse>,
  receiver: Async.DslReceiver<TaskMessage>
) -> Result<(), Str>  // effect {io.async, audit}
  = do {
    // Capability æ¤œè¨¼: io.async ãŒåˆ©ç”¨å¯èƒ½ã‹ Stage ã¾ã§å«ã‚ã¦ç¢ºèª
    // (3-8 Â§1.2 / 3-9 Â§1.9.4 ã® verify_capability_stage API ã‚’åˆ©ç”¨)
    let registry = Runtime.get_capability_registry();
    Runtime.verify_capability_stage(registry, "io.async", Stage.Stable)?;

    // æº–å‚™å®Œäº†ã‚’é€šçŸ¥
    Async.send(supervisor, WorkerResponse.WorkerReady { worker_id: worker_id }).await?;

    // ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆ: ãƒ¯ãƒ¼ã‚«ãƒ¼èµ·å‹•
    Diag.emit_audit_event(AuditEvent.WorkerStarted {
      worker_id: worker_id,
      timestamp: current_timestamp(),
    });

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ãƒ—
    loop {
      match Async.receive(receiver).await? {
        | TaskMessage.Process { id, payload } -> {
          // ã‚¿ã‚¹ã‚¯å‡¦ç†ï¼ˆä»®æƒ³çš„ãªå‡¦ç†ï¼‰
          let result = process_task(id, payload);

          match result {
            | Ok(output) -> {
              Async.send(supervisor, WorkerResponse.Success {
                id: id,
                result: output,
              }).await?;
            }
            | Err(err) -> {
              // AsyncError ã«å› æœãƒã‚§ãƒ¼ãƒ³ã‚’ä»˜ä¸
              // (3-6 Â§2.5 / 3-9 Â§1.8 ã® AsyncError.cause ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¯¾å¿œ)
              let async_error = AsyncError {
                kind: AsyncErrorKind.TaskFailure,
                message: err,
                cause: None,  // å…ƒã® cause ãŒã‚ã‚Œã° Some(Box.new(åŸå› )) ã§é€£é–å¯èƒ½
                metadata: Map.from_list([("task_id", Json.Number(id)), ("worker_id", Json.Number(worker_id))]),
              };

              // ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã¸å ±å‘Š
              Async.send(supervisor, WorkerResponse.Failure {
                id: id,
                error: err,
              }).await?;

              // ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆ: ã‚¿ã‚¹ã‚¯å¤±æ•— (æ¨™æº–AuditEventãƒãƒªã‚¢ãƒ³ãƒˆä½¿ç”¨)
              Diag.emit_audit_event(AuditEvent.AsyncTaskFailed {
                worker_id: worker_id,
                task_id: id,
                error: async_error,
                timestamp: current_timestamp(),
              });
            }
          }
        }
        | TaskMessage.Shutdown -> {
          // ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³é€šçŸ¥
          Diag.emit_audit_event(AuditEvent.WorkerStopped {
            worker_id: worker_id,
            timestamp: current_timestamp(),
          });
          return Ok(());
        }
      }
    }
  }

/// ã‚¿ã‚¹ã‚¯å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
fn process_task(id: Int, payload: Str) -> Result<Str, Str>  // @pure
  = if Str.length(payload) > 10 {
      Ok(Str.concat("Processed: ", payload))
    } else {
      Err("Payload too short")
    }

/// ============================================================================
/// 3. Actor å®šç¾©: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼
/// ============================================================================

/// ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼çŠ¶æ…‹
type SupervisorState = {
  workers: Map<Int, Async.DslSender<TaskMessage>>,
  task_queue: List<(Int, Str)>,
  tasks_completed: Int,
  tasks_failed: Int,
  workers_active: Int,
}

/// ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã‚¢ã‚¯ã‚¿ãƒ¼: ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’ç®¡ç†ã—ã€ã‚¿ã‚¹ã‚¯ã‚’åˆ†é…ã™ã‚‹
/// åŠ¹æœ: {io.async, audit}
fn supervisor_actor(
  num_workers: Int,
  command_receiver: Async.DslReceiver<SupervisorCommand>,
  response_sender: Async.DslSender<SupervisorResponse>
) -> Result<(), Str>  // effect {io.async, audit}
  = do {
    // Capability æ¤œè¨¼
    let registry = Runtime.get_capability_registry();
    Runtime.verify_capability_stage(registry, "io.async", Stage.Stable)?;

    // ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’èµ·å‹•
    let (worker_senders, worker_response_receiver) = spawn_workers(num_workers)?;

    // åˆæœŸçŠ¶æ…‹
    let mut state = SupervisorState {
      workers: Map.from_list(List.enumerate(worker_senders)),
      task_queue: [],
      tasks_completed: 0,
      tasks_failed: 0,
      workers_active: num_workers,
    };

    // ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆ: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼èµ·å‹•
    Diag.emit_audit_event(AuditEvent.SupervisorStarted {
      num_workers: num_workers,
      timestamp: current_timestamp(),
    });

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ãƒ—
    loop {
      // ã‚³ãƒãƒ³ãƒ‰ã¾ãŸã¯ãƒ¯ãƒ¼ã‚«ãƒ¼å¿œç­”ã‚’å—ä¿¡
      match Async.select([
        Async.map_future(Async.receive(command_receiver), |cmd| Either.Left(cmd)),
        Async.map_future(Async.receive(worker_response_receiver), |resp| Either.Right(resp)),
      ]).await? {
        | Either.Left(cmd) -> {
          match cmd {
            | SupervisorCommand.SubmitTask { id, payload } -> {
              // ã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ¥ãƒ¼ã¸è¿½åŠ 
              state.task_queue := List.append(state.task_queue, (id, payload));
              Async.send(response_sender, SupervisorResponse.TaskQueued { id: id }).await?;

              // ã‚¢ã‚¤ãƒ‰ãƒ«ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒã„ã‚Œã°å³åº§ã«å‰²ã‚Šå½“ã¦
              try_dispatch_task(&mut state);
            }
            | SupervisorCommand.RestartWorker { worker_id } -> {
              // ãƒ¯ãƒ¼ã‚«ãƒ¼å†èµ·å‹•ï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
              restart_worker(&mut state, worker_id)?;
              Async.send(response_sender, SupervisorResponse.WorkerRestarted { worker_id: worker_id }).await?;
            }
            | SupervisorCommand.GetStats -> {
              Async.send(response_sender, SupervisorResponse.Stats {
                tasks_completed: state.tasks_completed,
                tasks_failed: state.tasks_failed,
                workers_active: state.workers_active,
              }).await?;
            }
            | SupervisorCommand.Terminate -> {
              // å…¨ãƒ¯ãƒ¼ã‚«ãƒ¼ã¸ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³é€šçŸ¥
              shutdown_all_workers(&state.workers).await?;

              Diag.emit_audit_event(AuditEvent.SupervisorStopped {
                tasks_completed: state.tasks_completed,
                tasks_failed: state.tasks_failed,
                timestamp: current_timestamp(),
              });

              Async.send(response_sender, SupervisorResponse.Terminated).await?;
              return Ok(());
            }
          }
        }
        | Either.Right(response) -> {
          match response {
            | WorkerResponse.Success { id, result } -> {
              state.tasks_completed := state.tasks_completed + 1;
              // ã‚¿ã‚¹ã‚¯å®Œäº†ãƒ­ã‚°
              IO.println(Str.concat("Task ", Str.from_int(id), " completed: ", result));
            }
            | WorkerResponse.Failure { id, error } -> {
              state.tasks_failed := state.tasks_failed + 1;
              // ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã¨è¨ºæ–­ç™ºè¡Œ
              Diag.emit_diagnostic(Diagnostic {
                id: Some(Diag.new_uuid()),
                message: Str.concat("Task ", Str.from_int(id), " failed: ", error),
                severity: Severity.Warning,
                domain: Some(DiagnosticDomain.Async),
                code: Some("async.task.failure"),
                primary: Span.empty(),
                secondary: [],
                hints: [Hint.text("Consider resubmitting the task or checking worker health")],
                expected: None,
                audit: AuditEnvelope {
                  audit_id: Some(Diag.new_uuid()),
                  change_set: None,
                  capability: Some("io.async"),
                  metadata: Map.from_list([("task_id", Json.Number(id))]),
                },
                timestamp: current_timestamp(),
              });
            }
            | WorkerResponse.WorkerReady { worker_id } -> {
              // ãƒ¯ãƒ¼ã‚«ãƒ¼æº–å‚™å®Œäº†ã€æ¬¡ã®ã‚¿ã‚¹ã‚¯ã‚’å‰²ã‚Šå½“ã¦
              try_dispatch_task(&mut state);
            }
          }
        }
      }
    }
  }

/// ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆã—ã€å¿œç­”ãƒãƒ£ãƒãƒ«ã‚’çµ±åˆ
/// (3-9 Â§1.9.5 ã® spawn_supervised API ã‚’ä½¿ç”¨ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³)
fn spawn_workers(num_workers: Int) -> Result<(List<Async.DslSender<TaskMessage>>, Async.DslReceiver<WorkerResponse>), Str>  // effect {io.async}
  = do {
    let (supervisor_sender, supervisor_receiver) = Async.create_channel(buffer_size: 100, codec: identity_codec())?;

    // ãƒãƒ£ãƒãƒ«ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ç›£è¦–ã™ã‚‹ãŸã‚ã®ãƒãƒ³ãƒ‰ãƒ«å–å¾—
    // (3-6 Â§6.1.1 / 3-9 Â§1.4.5 ã® channel_metrics API)
    let channel_metrics = Async.channel_metrics(supervisor_receiver);

    let worker_senders = List.range(0, num_workers)
      |> List.map(|worker_id| {
        let (sender, receiver) = Async.create_channel(buffer_size: 10, codec: identity_codec())?;

        // æ¨™æº– Supervisor API ã§å†èµ·å‹•æˆ¦ç•¥ã‚’å®šç¾©
        let restart_strategy = RestartStrategy.permanent(max_restarts: 5, within: Duration.seconds(60));
        Async.spawn_supervised(
          worker_actor(worker_id, supervisor_sender, receiver),
          restart_strategy,
          default_scheduler()
        )?;

        Ok(sender)
      })
      |> List.collect_results()?;

    Ok((worker_senders, supervisor_receiver))
  }

/// ã‚¿ã‚¹ã‚¯ã‚’ã‚¢ã‚¤ãƒ‰ãƒ«ãƒ¯ãƒ¼ã‚«ãƒ¼ã¸å‰²ã‚Šå½“ã¦ï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
fn try_dispatch_task(state: &mut SupervisorState) -> ()  // @pure
  = ()  // å®Ÿè£…çœç•¥ï¼ˆã‚­ãƒ¥ãƒ¼ã¨ãƒ¯ãƒ¼ã‚«ãƒ¼çŠ¶æ…‹ã‚’ç®¡ç†ï¼‰

/// ãƒ¯ãƒ¼ã‚«ãƒ¼å†èµ·å‹•ï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
fn restart_worker(state: &mut SupervisorState, worker_id: Int) -> Result<(), Str>  // effect {io.async, audit}
  = do {
    // æ¨™æº– AuditEvent ãƒãƒªã‚¢ãƒ³ãƒˆã§å†èµ·å‹•ã‚’è¨˜éŒ²
    // (3-6 Â§1.1.1 æ–°è¨­ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼)
    Diag.emit_audit_event(AuditEvent.AsyncWorkerRestarted {
      worker_id: worker_id,
      restart_count: 1,  // å®Ÿéš›ã«ã¯ã‚«ã‚¦ãƒ³ã‚¿ã‚’ç®¡ç†
      timestamp: current_timestamp(),
    });
    Ok(())
  }

/// å…¨ãƒ¯ãƒ¼ã‚«ãƒ¼ã¸ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³é€šçŸ¥
fn shutdown_all_workers(workers: &Map<Int, Async.DslSender<TaskMessage>>) -> Result<(), Str>  // effect {io.async}
  = do {
    Map.iter(workers)
      |> List.from_iter()
      |> List.for_each(|(_, sender)| {
        Async.send(sender, TaskMessage.Shutdown).await
      })
  }

/// ============================================================================
/// 4. ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
/// ============================================================================

/// ç¾åœ¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆUnix ã‚¨ãƒãƒƒã‚¯ç§’ï¼‰
fn current_timestamp() -> Int  // effect {io}
  = 1704067200  // ä»®å€¤

/// æ’ç­‰Codecï¼ˆå‹å¤‰æ›ãªã—ï¼‰
fn identity_codec<T>() -> Codec<T, T>  // @pure
  = Codec {
    name: "identity",
    version: None,
    encode: |x| Ok(serialize(x)),
    decode: |bytes| Ok(deserialize(bytes)),
    validate: |_| Ok(()),
  }

/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©
fn default_scheduler() -> SchedulerHandle  // effect {io}
  = Runtime.get_default_scheduler()

/// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
fn serialize<T>(value: T) -> Bytes  // @pure
  = []  // å®Ÿè£…çœç•¥

/// ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºï¼ˆä»®æƒ³å®Ÿè£…ï¼‰
fn deserialize<T>(bytes: Bytes) -> T  // @pure
  = panic("Not implemented")

/// ============================================================================
/// 5. ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
/// ============================================================================

/// ãƒ¡ã‚¤ãƒ³é–¢æ•°: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã‚’èµ·å‹•ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’æŠ•å…¥
fn main() -> Result<(), Str>  // effect {io, io.async, audit}
  = do {
    // Capability Registry ã‹ã‚‰å¿…è¦ãªæ¨©é™ã‚’å–å¾—
    let registry = Runtime.get_capability_registry();
    Runtime.verify_capability_stage(registry, "io.async", Stage.Stable)?;

    // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼èµ·å‹•
    let (command_sender, command_receiver) = Async.create_channel(buffer_size: 50, codec: identity_codec())?;
    let (response_sender, response_receiver) = Async.create_channel(buffer_size: 50, codec: identity_codec())?;

    Async.spawn(supervisor_actor(num_workers: 3, command_receiver, response_sender), default_scheduler())?;

    // ã‚¿ã‚¹ã‚¯ã‚’æŠ•å…¥
    Async.send(command_sender, SupervisorCommand.SubmitTask { id: 1, payload: "task_payload_1" }).await?;
    Async.send(command_sender, SupervisorCommand.SubmitTask { id: 2, payload: "short" }).await?;
    Async.send(command_sender, SupervisorCommand.SubmitTask { id: 3, payload: "task_payload_3" }).await?;

    // çµ±è¨ˆå–å¾—
    Async.send(command_sender, SupervisorCommand.GetStats).await?;
    match Async.receive(response_receiver).await? {
      | SupervisorResponse.Stats { tasks_completed, tasks_failed, workers_active } -> {
        IO.println(Str.concat("Stats: completed=", Str.from_int(tasks_completed), ", failed=", Str.from_int(tasks_failed), ", active=", Str.from_int(workers_active)));
      }
      | _ -> {}
    }

    // çµ‚äº†
    Async.send(command_sender, SupervisorCommand.Terminate).await?;
    Async.receive(response_receiver).await?;

    Ok(())
  }

/// ============================================================================
/// 6. æ”¹å–„å®Œäº†å¾Œã®æ¤œè¨¼ã‚³ãƒ¡ãƒ³ãƒˆ
/// ============================================================================

// **æ”¹å–„ãƒãƒˆãƒªã‚¯ã‚¹å¯¾å¿œçŠ¶æ³**:
//
// âœ… é …ç›®1: **Stage æ¤œè¨¼ã®æ˜ç¢ºåŒ–**
//    - `Runtime.verify_capability_stage(registry, "io.async", Stage.Stable)` ã§ Stage ã‚’æ˜ç¤º
//    - 3-8 Â§1.2 / 3-9 Â§1.9.4 ã® verify_capability_stage API ã‚’ä½¿ç”¨
//
// âœ… é …ç›®7: **AsyncError ã®å› æœãƒã‚§ãƒ¼ãƒ³**
//    - `AsyncError` ã« `cause` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ `metadata` ã‚’è¿½åŠ 
//    - 3-6 Â§2.5 / 3-9 Â§1.8 ã®è¨ºæ–­é€£æºä»•æ§˜ã«æº–æ‹ 
//
// âœ… é …ç›®8: **Actor/Supervisor ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¨™æº– API**
//    - `Async.spawn_supervised` ã¨ `RestartStrategy` ã‚’ä½¿ç”¨
//    - 3-9 Â§1.9.5 / 3-6 Â§2.5.1 ã® Supervisor æŠ½è±¡åŒ–ã«æº–æ‹ 
//
// âœ… é …ç›®3: **ãƒãƒ£ãƒãƒ«ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç›£è¦–**
//    - `Async.channel_metrics` ã§ãƒãƒƒã‚¯ãƒ—ãƒ¬ãƒƒã‚·ãƒ£ãƒ¼çŠ¶æ³ã‚’å–å¾—
//    - 3-6 Â§6.1.1 / 3-9 Â§1.4.5 ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ API ã‚’ä½¿ç”¨
//
// âœ… é …ç›®6: **AuditEvent ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã®æ‹¡å……**
//    - `AuditEvent.AsyncTaskFailed` / `AsyncWorkerRestarted` ã‚’æ¨™æº–ãƒãƒªã‚¢ãƒ³ãƒˆã¨ã—ã¦ä½¿ç”¨
//    - 3-6 Â§1.1.1 æ–°è¨­ã®ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã«æº–æ‹ 
//
// ğŸ“ ä»Šå¾Œã®æ‹¡å¼µå€™è£œ:
//    - SupervisorSpec ã«ã‚ˆã‚‹å®£è¨€çš„ Supervisor æ§‹æˆ
//    - CapabilityRegistry ã¨åŠ¹æœãƒãƒ³ãƒ‰ãƒ©ã®è‡ªå‹•çµ±åˆ (é …ç›®æœªå¯¾å¿œ)
//    - SchedulerConfig ã®é™çš„æ¤œè¨¼ (é …ç›®4 ã®ä¸€éƒ¨)
//
