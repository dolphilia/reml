module samples.language_impl_samples.markdown_parser

use ::Core.Collection.List as List
use ::Core.Text as Text
use ::Core.Text.String as String
use ::Core.Text.Char as Char
use ::Core.Text.Grapheme as Grapheme

/// Markdown AST ã®è¦ç´ å‹ï¼ˆæ”¹å–„ç‰ˆï¼šUnicodeå¹…è¨ˆç®—çµ±åˆï¼‰ã€‚
///
/// ç°¡æ˜“å®Ÿè£…ã®ãŸã‚ã€è¦‹å‡ºã—ãƒ»æ®µè½ãƒ»ãƒªã‚¹ãƒˆãƒ»ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãƒ»å¼·èª¿ãƒ»ãƒªãƒ³ã‚¯ã®ã¿å¯¾å¿œã€‚
///
/// æ”¹å–„ç‚¹ï¼ˆä»•æ§˜ 1-4/2-5/3-3 æº–æ‹ ï¼‰ï¼š
/// - `Text.display_width` ã«ã‚ˆã‚‹ Grapheme å˜ä½ã®åˆ—å¹…è¨ˆç®—ï¼ˆL58ï¼‰
/// - `ParseState` ã®åˆ—å…±æœ‰è¦ç´„ï¼ˆ2-5 Â§B-11ï¼‰ã«æº–æ‹ ã—ãŸä½ç½®è¿½è·¡
/// - Unicode 3å±¤ãƒ¢ãƒ‡ãƒ«ï¼ˆByte/Char/Graphemeï¼‰ã‚’æ„è­˜ã—ãŸå®Ÿè£…
type Block =
  | Heading(level: Int, inline: List<Inline>)
  | Paragraph(inline: List<Inline>)
  | UnorderedList(items: List<List<Inline>>)
  | OrderedList(items: List<List<Inline>>)
  | CodeBlock(lang: Option<String>, code: String)
  | HorizontalRule

type Inline =
  | Text(String)
  | Strong(List<Inline>)
  | Emphasis(List<Inline>)
  | Code(String)
  | Link(text: List<Inline>, url: String)
  | LineBreak

type Document = List<Block>

/// ãƒ‘ãƒ¼ã‚µãƒ¼çŠ¶æ…‹ï¼šä½ç½®æƒ…å ±ã¨ã‚¨ãƒ©ãƒ¼è“„ç©ã€‚
type ParseState = {
  input: String,
  pos: Int,        // ãƒã‚¤ãƒˆä½ç½®
  line: Int,
  line_start: Int, // ç¾åœ¨è¡Œã®ãƒã‚¤ãƒˆå…ˆé ­
  col: Int,
  errors: List<String>
}

type ParseResult<T> = Result<(T, ParseState), String>

/// æ‰‹ç¶šãçš„ãƒ‘ãƒ¼ã‚µãƒ¼ï¼šUnicode 3å±¤ãƒ¢ãƒ‡ãƒ«ã‚’æ„è­˜ã—ãŸå®Ÿè£…ã€‚
/// Byte/Char ã‚’è¿½è·¡ã—ã¤ã¤ `display_width` ã§ Grapheme å˜ä½ã®è¡¨ç¤ºå¹…ã‚’è¨ˆç®—ã™ã‚‹ã€‚

/// ç¾åœ¨ä½ç½®ã®1æ–‡å­—ï¼ˆCharï¼‰ã‚’å–å¾—ã€‚
let peek(state: ParseState) -> Option<Char> =
  String.char_at(state.input, state.pos)

/// 1æ–‡å­—ï¼ˆCharï¼‰ã‚’æ¶ˆè²»ã—ã¦é€²ã‚ã‚‹ï¼ˆæ”¹å–„ç‰ˆï¼šä»•æ§˜ 1-4/3-3 æº–æ‹ ï¼‰ã€‚
///
/// æ”¹å–„ç‚¹ï¼š
/// - `Text.display_width` ã§ Grapheme å˜ä½ã®è¡¨ç¤ºå¹…ã‚’æ­£ç¢ºã«è¨ˆç®—
/// - çµµæ–‡å­—ãƒ»çµåˆæ–‡å­—ãƒ»å…¨è§’æ–‡å­—ã®å¹…ã‚’é©åˆ‡ã«æ‰±ã†
/// - åˆ—ç•ªå·ï¼ˆcolï¼‰ã¯ Grapheme å˜ä½ã®è¡¨ç¤ºå¹…ã§æ›´æ–°ï¼ˆ2-5 Â§B-11 æº–æ‹ ï¼‰
let advance_char(state: ParseState) -> ParseState =
  match peek(state) with
  | None -> state
  | Some(ch) ->
    let byte_len = Char.utf8_len(ch)
    let new_pos = state.pos + byte_len
    let (new_line, new_line_start, new_col) =
      if ch == '\n' then (state.line + 1, new_pos, 0)
      else
        // æ”¹å–„: Text.display_width ã§è¡Œé ­ã‹ã‚‰ã®è¡¨ç¤ºå¹…ã‚’è¨ˆç®—
        let line_slice = String.slice(state.input, state.line_start, new_pos)
        let width = Text.display_width(line_slice)
        (state.line, state.line_start, width)
    { state with pos = new_pos, line = new_line, line_start = new_line_start, col = new_col }

/// å›ºå®šæ–‡å­—åˆ—ã‚’ãƒãƒƒãƒï¼ˆNFCæ­£è¦åŒ–å‰æï¼‰ã€‚
let match_string(target: String, state: ParseState) -> Option<ParseState> =
  let remaining = String.slice_from(state.input, state.pos)
  if String.starts_with(remaining, target) then
    let byte_len = String.byte_len(target)
    Some({ state with pos = state.pos + byte_len })
  else
    None

/// ç©ºç™½ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ°´å¹³ã®ã¿ï¼‰ã€‚
let skip_hspace(state: ParseState) -> ParseState =
  match peek(state) with
  | Some(ch) if Char.is_horizontal_space(ch) ->
    skip_hspace(advance_char(state))
  | _ -> state

/// è¡Œæœ«ã¾ã§èª­ã‚€ã€‚
let read_until_eol(state: ParseState) -> (String, ParseState) =
  let start = state.pos
  let rec loop(s: ParseState) -> ParseState =
    match peek(s) with
    | Some('\n') | None -> s
    | Some(_) -> loop(advance_char(s))
  let end_state = loop(state)
  let text = String.slice(state.input, start, end_state.pos)
  (text, end_state)

/// æ”¹è¡Œã‚’æ¶ˆè²»ã€‚
let consume_newline(state: ParseState) -> Option<ParseState> =
  match peek(state) with
  | Some('\n') -> Some(advance_char(state))
  | _ -> None

/// è¦‹å‡ºã—è¡Œã®ãƒ‘ãƒ¼ã‚¹ï¼ˆ`# Heading` å½¢å¼ï¼‰ã€‚
let parse_heading(state: ParseState) -> ParseResult<Block> =
  let state1 = skip_hspace(state)
  // `#` ã®é€£ç¶šã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  let rec count_hash(s: ParseState, n: Int) -> (Int, ParseState) =
    match peek(s) with
    | Some('#') -> count_hash(advance_char(s), n + 1)
    | _ -> (n, s)

  let (level, state2) = count_hash(state1, 0)
  if level == 0 || level > 6 then
    Err("è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«ã¯1-6ã®ç¯„å›²å†…ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
  else
    let state3 = skip_hspace(state2)
    let (text, state4) = read_until_eol(state3)
    let inline = [Text(String.trim(text))]  // ç°¡æ˜“å®Ÿè£…ï¼šã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¦ç´ ã¯æœªãƒ‘ãƒ¼ã‚¹
    let state5 = consume_newline(state4) |> Option.unwrap_or(state4)
    Ok((Heading(level, inline), state5))

/// æ°´å¹³ç·šã®ãƒ‘ãƒ¼ã‚¹ï¼ˆ`---`, `***`, `___`ï¼‰ã€‚
let parse_horizontal_rule(state: ParseState) -> ParseResult<Block> =
  let state1 = skip_hspace(state)
  let (text, state2) = read_until_eol(state1)
  let trimmed = String.trim(text)
  let is_rule =
    (String.all(trimmed, |c| c == '-') && String.char_len(trimmed) >= 3) ||
    (String.all(trimmed, |c| c == '*') && String.char_len(trimmed) >= 3) ||
    (String.all(trimmed, |c| c == '_') && String.char_len(trimmed) >= 3)

  if is_rule then
    let state3 = consume_newline(state2) |> Option.unwrap_or(state2)
    Ok((HorizontalRule, state3))
  else
    Err("æ°´å¹³ç·šã¨ã—ã¦èªè­˜ã§ãã¾ã›ã‚“")

/// ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ‘ãƒ¼ã‚¹ï¼ˆ```è¨€èªåï¼‰ã€‚
let parse_code_block(state: ParseState) -> ParseResult<Block> =
  match match_string("```", state) with
  | None -> Err("ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
  | Some(state1) ->
    let (lang_line, state2) = read_until_eol(state1)
    let lang =
      let trimmed = String.trim(lang_line)
      if String.is_empty(trimmed) then None else Some(trimmed)
    let state3 = consume_newline(state2) |> Option.unwrap_or(state2)

    // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…å®¹ã‚’ ```é–‰ã˜ã¾ã§èª­ã‚€
    let rec read_code(s: ParseState, lines: List<String>) -> (List<String>, ParseState) =
      match match_string("```", s) with
      | Some(end_state) -> (lines, end_state)
      | None ->
        match peek(s) with
        | None -> (lines, s)  // EOF
        | Some(_) ->
          let (line, s2) = read_until_eol(s)
          let s3 = consume_newline(s2) |> Option.unwrap_or(s2)
          read_code(s3, List.append(lines, [line]))

    let (code_lines, state4) = read_code(state3, [])
    let code = String.join(code_lines, "\n")
    let state5 = consume_newline(state4) |> Option.unwrap_or(state4)
    Ok((CodeBlock(lang, code), state5))

/// ãƒªã‚¹ãƒˆé …ç›®ã®ãƒ‘ãƒ¼ã‚¹ï¼ˆç°¡æ˜“ç‰ˆï¼š`-` ã¾ãŸã¯ `*` ã®ã¿ï¼‰ã€‚
let parse_unordered_list(state: ParseState) -> ParseResult<Block> =
  let rec parse_items(s: ParseState, items: List<List<Inline>>) -> (List<List<Inline>>, ParseState) =
    let s1 = skip_hspace(s)
    match peek(s1) with
    | Some('-') | Some('*') ->
      let s2 = advance_char(s1)
      let s3 = skip_hspace(s2)
      let (text, s4) = read_until_eol(s3)
      let inline = [Text(String.trim(text))]
      let s5 = consume_newline(s4) |> Option.unwrap_or(s4)
      parse_items(s5, List.append(items, [inline]))
    | _ -> (items, s)

  let (items, state_end) = parse_items(state, [])
  if List.is_empty(items) then
    Err("ãƒªã‚¹ãƒˆé …ç›®ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
  else
    Ok((UnorderedList(items), state_end))

/// æ®µè½ã®ãƒ‘ãƒ¼ã‚¹ï¼ˆç°¡æ˜“ç‰ˆï¼šç©ºè¡Œã¾ã§ï¼‰ã€‚
let parse_paragraph(state: ParseState) -> ParseResult<Block> =
  let rec read_lines(s: ParseState, lines: List<String>) -> (List<String>, ParseState) =
    match peek(s) with
    | None -> (lines, s)
    | Some('\n') ->
      let s1 = advance_char(s)
      match peek(s1) with
      | Some('\n') -> (lines, s1)  // ç©ºè¡Œã§æ®µè½çµ‚äº†
      | _ -> read_lines(s1, List.append(lines, [""]))
    | Some(_) ->
      let (line, s2) = read_until_eol(s)
      let s3 = consume_newline(s2) |> Option.unwrap_or(s2)
      read_lines(s3, List.append(lines, [line]))

  let (lines, state_end) = read_lines(state, [])
  let text = String.join(lines, " ")
  let inline = [Text(String.trim(text))]
  Ok((Paragraph(inline), state_end))

/// ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã®ãƒ‘ãƒ¼ã‚¹ï¼ˆå„ªå…ˆé †ä½ä»˜ãè©¦è¡Œï¼‰ã€‚
let parse_block(state: ParseState) -> ParseResult<Block> =
  let state1 = skip_hspace(state)

  // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—
  match peek(state1) with
  | Some('\n') ->
    let state2 = advance_char(state1)
    parse_block(state2)
  | None -> Err("EOF")
  | Some('#') -> parse_heading(state1)
  | Some('`') ->
    match match_string("```", state1) with
    | Some(_) -> parse_code_block(state1)
    | None -> parse_paragraph(state1)
  | Some('-') | Some('*') | Some('_') ->
    // æ°´å¹³ç·šã‹ãƒªã‚¹ãƒˆã‹åˆ¤å®š
    match parse_horizontal_rule(state1) with
    | Ok(result) -> Ok(result)
    | Err(_) -> parse_unordered_list(state1)
  | Some(_) -> parse_paragraph(state1)

/// ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã®ãƒ‘ãƒ¼ã‚¹ã€‚
pub fn parse(input: String) -> Result<Document, String> =
  let initial_state = {
    input: input,
    pos: 0,
    line: 1,
    line_start: 0,
    col: 0,
    errors: []
  }

  let rec parse_all(state: ParseState, blocks: List<Block>) -> Result<Document, String> =
    match parse_block(state) with
    | Ok((block, new_state)) ->
      parse_all(new_state, List.append(blocks, [block]))
    | Err("EOF") -> Ok(blocks)
    | Err(msg) -> Err(msg)

  parse_all(initial_state, [])

/// ç°¡æ˜“çš„ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆæ¤œè¨¼ç”¨ï¼‰ã€‚
pub fn render_to_string(doc: Document) -> String =
  let render_inline(inline: List<Inline>) -> String =
    inline
    |> List.map(|i| match i with
      | Text(s) -> s
      | Strong(inner) -> "**" ++ render_inline(inner) ++ "**"
      | Emphasis(inner) -> "*" ++ render_inline(inner) ++ "*"
      | Code(s) -> "`" ++ s ++ "`"
      | Link(text, url) -> "[" ++ render_inline(text) ++ "](" ++ url ++ ")"
      | LineBreak -> "\n"
    )
    |> String.concat

  let render_block(block: Block) -> String =
    match block with
    | Heading(level, inline) ->
      let prefix = String.repeat("#", level)
      prefix ++ " " ++ render_inline(inline) ++ "\n\n"
    | Paragraph(inline) ->
      render_inline(inline) ++ "\n\n"
    | UnorderedList(items) ->
      items
      |> List.map(|item| "- " ++ render_inline(item) ++ "\n")
      |> String.concat
      |> (|s| s ++ "\n")
    | OrderedList(items) ->
      items
      |> List.map_indexed(|i, item| format("{i + 1}. {render_inline(item)}\n"))
      |> String.concat
      |> (|s| s ++ "\n")
    | CodeBlock(lang, code) ->
      let lang_str = lang |> Option.map(|l| l) |> Option.unwrap_or("")
      "```" ++ lang_str ++ "\n" ++ code ++ "\n```\n\n"
    | HorizontalRule ->
      "---\n\n"

  doc
  |> List.map(render_block)
  |> String.concat

/// æ”¹å–„ãƒãƒˆãƒªã‚¯ã‚¹è¦³ç‚¹6ã€ŒUnicode/Grapheme æ“ä½œã€ã®å¯¾å¿œã¾ã¨ã‚:
///
/// **æ”¹å–„å‰ã®èª²é¡Œ:**
/// - L40, L48: `ParseState`â†’`Diagnostic` ã®åˆ—å…±æœ‰è¦ç´„ãŒæœªçµ±ä¸€
/// - `display_width` ã«ã‚ˆã‚‹å¹…è¨ˆç®—ãŒæ•´å‚™ã•ã‚Œã¦ã„ãŸãŒã€æ˜ç¤ºçš„ãªèª¬æ˜ãŒä¸è¶³
/// - IDE/LSPå®Ÿè£…ã§ã® Grapheme å˜ä½å¹…è¨ˆç®—ã®æ´»ç”¨ä¾‹ãŒæœªæ•´å‚™
///
/// **æ”¹å–„å¾Œ:**
/// - `advance_char` é–¢æ•°ï¼ˆL60-73ï¼‰ã§ `Text.display_width` ã‚’æ´»ç”¨ã—ã€ä»•æ§˜ 1-4/3-3 æº–æ‹ ã®å¹…è¨ˆç®—ã‚’å®Ÿè£…
/// - åˆ—ç•ªå·ï¼ˆcolï¼‰ã‚’ Grapheme å˜ä½ã®è¡¨ç¤ºå¹…ã§æ›´æ–°ï¼ˆ2-5 Â§B-11 æº–æ‹ ï¼‰
/// - çµµæ–‡å­—ï¼ˆğŸ‰, ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ï¼‰ã€çµåˆæ–‡å­—ï¼ˆÃ© = e + Ìï¼‰ã€å…¨è§’æ–‡å­—ï¼ˆã‚ã€æ¼¢ï¼‰ã®å¹…ã‚’æ­£ç¢ºã«æ‰±ã†
/// - Unicode 3å±¤ãƒ¢ãƒ‡ãƒ«ï¼ˆByte/Char/Graphemeï¼‰ã‚’æ„è­˜ã—ãŸä½ç½®è¿½è·¡ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§æ˜ç¤º
///
/// **å®Ÿè£…ã®è©³ç´°:**
/// 1. ãƒã‚¤ãƒˆä½ç½®ï¼ˆposï¼‰: UTF-8ãƒã‚¤ãƒˆå˜ä½ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ•ã‚¡ã‚¤ãƒ«I/Oç”¨ï¼‰
/// 2. æ–‡å­—ä½ç½®ï¼ˆCharï¼‰: Unicodeã‚¹ã‚«ãƒ©ãƒ¼å€¤ï¼ˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼‰å˜ä½
/// 3. è¡¨ç¤ºå¹…ï¼ˆcolï¼‰: Graphemeå˜ä½ã®è¡¨ç¤ºå¹…ï¼ˆEast Asian Widthæº–æ‹ ï¼‰
///
/// **ä»Šå¾Œã®æ¨å¥¨äº‹é …ï¼ˆä»•æ§˜ 1-4/2-5/3-3 æº–æ‹ ï¼‰:**
/// 1. IDE/LSPå®Ÿè£…ã§ `GraphemeSeq::width` ã‚’æ´»ç”¨ã—ãŸæŠœç²‹è¡¨ç¤ºæ¤œè¨¼ã‚’å®Ÿæ–½
/// 2. ã‚¨ãƒ©ãƒ¼è¨ºæ–­æ™‚ã®ã‚¹ãƒ‘ãƒ³æƒ…å ±ã« Grapheme å¹…ã‚’å«ã‚ã‚‹ã“ã¨ã§ã€æ­£ç¢ºãªåˆ—ä½ç½®ã‚’å ±å‘Š
/// 3. `Diagnostic.from_parse_error` ã§ `ParseState.col` ã‚’æ´»ç”¨ã—ã€IDEä¸Šã§ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ­£ç¢ºã«è¡¨ç¤º
/// 4. Markdown ã®è¡¨ï¼ˆtableï¼‰ãƒ‘ãƒ¼ã‚¹æ™‚ã«åˆ—å¹…ã‚’ Grapheme å˜ä½ã§è¨ˆç®—
///
/// **Unicodeå¹…è¨ˆç®—ã®å®Ÿä¾‹:**
/// - ASCIIæ–‡å­—ï¼ˆ"a"ï¼‰: 1å¹…
/// - å…¨è§’æ–‡å­—ï¼ˆ"ã‚"ï¼‰: 2å¹…
/// - çµµæ–‡å­—ï¼ˆ"ğŸ‰"ï¼‰: 2å¹…
/// - çµåˆæ–‡å­—ï¼ˆ"Ã©" = "e" + çµåˆã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼‰: 1å¹…
/// - å®¶æ—çµµæ–‡å­—ï¼ˆ"ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦" = ZWJçµåˆï¼‰: 2å¹…ï¼ˆ1ã¤ã®Graphemeã¨ã—ã¦æ‰±ã†ï¼‰
///
/// **å‚ç…§ä»•æ§˜:**
/// - 1-4 Â§G.1: Unicodeæ–‡å­—ãƒ¢ãƒ‡ãƒ«ï¼ˆByte/Char/Graphemeï¼‰
/// - 2-5 Â§B-11: ParseStateâ†’Diagnostic ã®åˆ—å…±æœ‰è¦ç´„
/// - 3-3 Â§5.1: display_width ã«ã‚ˆã‚‹å¹…è¨ˆç®—æ‰‹é †
/// - guides/core-parse-streaming.md: ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‘ãƒ¼ã‚µãƒ¼ã§ã®Graphemeå‡¦ç†
