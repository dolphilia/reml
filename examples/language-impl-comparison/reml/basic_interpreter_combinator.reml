module samples.language_impl_comparison.basic_interpreter_combinator

use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.Prelude.Result::{self, Result}
use ::Core.Text::{self, Text}
use ::Core.Parse::{self, Parser, Input}
use ::Core.Parse.Lex as Lex

/// パーサーコンビネーターを使った Basic インタープリタ。
/// LET, PRINT, IF, FOR, WHILE, GOTO, GOSUB, RETURN, DIM, END をサポート。

type Value =
  | VNumber(f64)
  | VString(Text)
  | VArray(List<Value>)

type Env = Map<Text, Value>

type Statement =
  | Let { var: Text, expr: Expr }
  | Print(List<Expr>)
  | If { cond: Expr, then_block: List<Statement>, else_block: List<Statement> }
  | For { var: Text, start: Expr, end: Expr, step: Expr, body: List<Statement> }
  | While { cond: Expr, body: List<Statement> }
  | Goto(i32)
  | Gosub(i32)
  | Return
  | Dim { var: Text, size: Expr }
  | End

type Expr =
  | Number(f64)
  | String(Text)
  | Variable(Text)
  | ArrayAccess { var: Text, index: Expr }
  | BinOp { op: BinOperator, left: Expr, right: Expr }
  | UnaryOp { op: UnaryOperator, operand: Expr }

type BinOperator =
  | Add | Sub | Mul | Div
  | Eq | Ne | Lt | Le | Gt | Ge
  | And | Or

type UnaryOperator =
  | Neg | Not

type Program = List<(i32, Statement)>

type RuntimeState = {
  env: Env,
  call_stack: List<i32>,
  output: List<Text>,
}

type RuntimeError =
  | UndefinedVariable { name: Text }
  | UndefinedLabel { line: i32 }
  | TypeMismatch { expected: Text, got: Text }
  | IndexOutOfBounds
  | DivisionByZero
  | StackUnderflow

// ========== パーサー定義 ==========

fn ws() -> Parser<()> {
  Parse.many(Parse.one_of([' ', '\t', '\r', '\n']))
    |> Parse.map(|_| ())
}

fn lexeme(p: Parser<T>) -> Parser<T> {
  p |> Parse.skip(ws())
}

fn keyword(kw: Text) -> Parser<Text> {
  lexeme(Lex.keyword(kw))
}

fn symbol(sym: Text) -> Parser<Text> {
  lexeme(Lex.symbol(sym))
}

fn line_number() -> Parser<i32> {
  lexeme(Lex.integer())
}

fn identifier() -> Parser<Text> {
  lexeme(Lex.identifier())
}

fn number() -> Parser<f64> {
  lexeme(Lex.float())
}

fn string_literal() -> Parser<Text> {
  lexeme(Lex.string_literal())
}

// 式パーサー
fn expr() -> Parser<Expr> {
  or_expr()
}

fn or_expr() -> Parser<Expr> {
  Parse.chainl1(
    and_expr(),
    symbol("OR") |> Parse.map(|_| |l, r| BinOp { op: Or, left: l, right: r })
  )
}

fn and_expr() -> Parser<Expr> {
  Parse.chainl1(
    comparison_expr(),
    symbol("AND") |> Parse.map(|_| |l, r| BinOp { op: And, left: l, right: r })
  )
}

fn comparison_expr() -> Parser<Expr> {
  let comp_op = Parse.choice([
    symbol("=") |> Parse.map(|_| Eq),
    symbol("<>") |> Parse.map(|_| Ne),
    symbol("<=") |> Parse.map(|_| Le),
    symbol(">=") |> Parse.map(|_| Ge),
    symbol("<") |> Parse.map(|_| Lt),
    symbol(">") |> Parse.map(|_| Gt),
  ])

  Parse.chainl1(
    additive_expr(),
    comp_op |> Parse.map(|op| |l, r| BinOp { op, left: l, right: r })
  )
}

fn additive_expr() -> Parser<Expr> {
  let add_op = Parse.choice([
    symbol("+") |> Parse.map(|_| Add),
    symbol("-") |> Parse.map(|_| Sub),
  ])

  Parse.chainl1(
    multiplicative_expr(),
    add_op |> Parse.map(|op| |l, r| BinOp { op, left: l, right: r })
  )
}

fn multiplicative_expr() -> Parser<Expr> {
  let mul_op = Parse.choice([
    symbol("*") |> Parse.map(|_| Mul),
    symbol("/") |> Parse.map(|_| Div),
  ])

  Parse.chainl1(
    unary_expr(),
    mul_op |> Parse.map(|op| |l, r| BinOp { op, left: l, right: r })
  )
}

fn unary_expr() -> Parser<Expr> {
  Parse.choice([
    symbol("-")
      |> Parse.then(primary_expr())
      |> Parse.map(|(_, operand)| UnaryOp { op: Neg, operand }),
    symbol("NOT")
      |> Parse.then(primary_expr())
      |> Parse.map(|(_, operand)| UnaryOp { op: Not, operand }),
    primary_expr()
  ])
}

fn primary_expr() -> Parser<Expr> {
  Parse.choice([
    number() |> Parse.map(Number),
    string_literal() |> Parse.map(String),
    Parse.try(array_access()),
    identifier() |> Parse.map(Variable),
    symbol("(")
      |> Parse.then(expr())
      |> Parse.skip(symbol(")"))
      |> Parse.map(|(_, e)| e)
  ])
}

fn array_access() -> Parser<Expr> {
  identifier()
    |> Parse.skip(symbol("("))
    |> Parse.then(expr())
    |> Parse.skip(symbol(")"))
    |> Parse.map(|(var, index)| ArrayAccess { var, index })
}

// 文パーサー
fn statement() -> Parser<Statement> {
  Parse.choice([
    let_stmt(),
    print_stmt(),
    if_stmt(),
    for_stmt(),
    while_stmt(),
    goto_stmt(),
    gosub_stmt(),
    return_stmt(),
    dim_stmt(),
    end_stmt()
  ])
}

fn let_stmt() -> Parser<Statement> {
  keyword("LET")
    |> Parse.then(identifier())
    |> Parse.skip(symbol("="))
    |> Parse.then(expr())
    |> Parse.map(|((_, var), expr)| Let { var, expr })
}

fn print_stmt() -> Parser<Statement> {
  keyword("PRINT")
    |> Parse.then(Parse.sep_by(expr(), symbol(",")))
    |> Parse.map(|(_, exprs)| Print(exprs))
}

fn if_stmt() -> Parser<Statement> {
  keyword("IF")
    |> Parse.then(expr())
    |> Parse.skip(keyword("THEN"))
    |> Parse.then(Parse.many(statement()))
    |> Parse.then(Parse.optional(
      keyword("ELSE")
        |> Parse.then(Parse.many(statement()))
        |> Parse.map(|(_, stmts)| stmts)
    ))
    |> Parse.skip(keyword("END"))
    |> Parse.map(|(((_, cond), then_block), else_opt)| {
      let else_block = else_opt.unwrap_or(List.empty())
      If { cond, then_block, else_block }
    })
}

fn for_stmt() -> Parser<Statement> {
  keyword("FOR")
    |> Parse.then(identifier())
    |> Parse.skip(symbol("="))
    |> Parse.then(expr())
    |> Parse.skip(keyword("TO"))
    |> Parse.then(expr())
    |> Parse.then(Parse.optional(
      keyword("STEP")
        |> Parse.then(expr())
        |> Parse.map(|(_, e)| e)
    ))
    |> Parse.then(Parse.many(statement()))
    |> Parse.skip(keyword("NEXT"))
    |> Parse.map(|(((((_, var), start), end), step_opt), body)| {
      let step = step_opt.unwrap_or(Number(1.0))
      For { var, start, end, step, body }
    })
}

fn while_stmt() -> Parser<Statement> {
  keyword("WHILE")
    |> Parse.then(expr())
    |> Parse.then(Parse.many(statement()))
    |> Parse.skip(keyword("WEND"))
    |> Parse.map(|((_, cond), body)| While { cond, body })
}

fn goto_stmt() -> Parser<Statement> {
  keyword("GOTO")
    |> Parse.then(line_number())
    |> Parse.map(|(_, line)| Goto(line))
}

fn gosub_stmt() -> Parser<Statement> {
  keyword("GOSUB")
    |> Parse.then(line_number())
    |> Parse.map(|(_, line)| Gosub(line))
}

fn return_stmt() -> Parser<Statement> {
  keyword("RETURN")
    |> Parse.map(|_| Return)
}

fn dim_stmt() -> Parser<Statement> {
  keyword("DIM")
    |> Parse.then(identifier())
    |> Parse.skip(symbol("("))
    |> Parse.then(expr())
    |> Parse.skip(symbol(")"))
    |> Parse.map(|((_, var), size)| Dim { var, size })
}

fn end_stmt() -> Parser<Statement> {
  keyword("END")
    |> Parse.map(|_| End)
}

fn program_line() -> Parser<(i32, Statement)> {
  line_number()
    |> Parse.then(statement())
}

fn program() -> Parser<Program> {
  ws()
    |> Parse.then(Parse.many(program_line()))
    |> Parse.skip(Parse.eof())
    |> Parse.map(|(_, lines)| lines)
}

// ========== 実行エンジン ==========

fn parse_and_run(source: Text) -> Result<List<Text>, Text> {
  match Parse.run(program(), source) with
  | Err(err) -> Result.err(format("パースエラー: {err}"))
  | Ok(prog) ->
    match run(prog) with
    | Err(err) -> Result.err(format("実行エラー: {err}"))
    | Ok(output) -> Result.ok(output)
}

fn run(program: Program) -> Result<List<Text>, RuntimeError> {
  let state = RuntimeState {
    env: Map.empty(),
    call_stack: List.empty(),
    output: List.empty(),
  }
  let sorted = List.sort_by(program, |(line, _)| line)
  execute_program(sorted, 0, state)
}

fn execute_program(
  program: List<(i32, Statement)>,
  pc: i32,
  state: RuntimeState
) -> Result<List<Text>, RuntimeError> {
  if pc >= List.length(program) {
    return Result.ok(state.output)
  }

  let (line, stmt) = List.get(program, pc).unwrap()

  match stmt with
  | End -> Result.ok(state.output)
  | Let(let_stmt) ->
    let value = eval_expr(let_stmt.expr, state.env)?
    let new_env = Map.insert(state.env, let_stmt.var, value)
    execute_program(program, pc + 1, { state with env = new_env })

  | Print(exprs) ->
    let values = collect_expr_results(exprs, state.env)?
    let text = values
      |> List.map(value_to_text)
      |> Text.join(" ")
    let new_output = List.push_back(state.output, text)
    execute_program(program, pc + 1, { state with output = new_output })

  | If(if_stmt) ->
    let cond_val = eval_expr(if_stmt.cond, state.env)?
    let branch = if is_truthy(cond_val) {
      if_stmt.then_block
    } else {
      if_stmt.else_block
    }
    let new_state = execute_block(branch, state)?
    execute_program(program, pc + 1, new_state)

  | For(for_stmt) ->
    let start_val = eval_expr(for_stmt.start, state.env)?
    let end_val = eval_expr(for_stmt.end, state.env)?
    let step_val = eval_expr(for_stmt.step, state.env)?
    execute_for_loop(for_stmt.var, start_val, end_val, step_val, for_stmt.body, program, pc, state)

  | While(while_stmt) ->
    execute_while_loop(while_stmt.cond, while_stmt.body, program, pc, state)

  | Goto(target) ->
    let new_pc = find_line(program, target)?
    execute_program(program, new_pc, state)

  | Gosub(target) ->
    let new_pc = find_line(program, target)?
    let new_call_stack = List.push_back(state.call_stack, pc + 1)
    execute_program(program, new_pc, { state with call_stack = new_call_stack })

  | Return ->
    match List.pop_back(state.call_stack) with
    | None -> Result.err(StackUnderflow)
    | Some((rest, return_pc)) ->
      execute_program(program, return_pc, { state with call_stack = rest })

  | Dim(dim_stmt) ->
    let size_val = eval_expr(dim_stmt.size, state.env)?
    match size_val with
    | VNumber(n) ->
      let size = n as i32
      let array = List.repeat(VNumber(0.0), size)
      let new_env = Map.insert(state.env, dim_stmt.var, VArray(array))
      execute_program(program, pc + 1, { state with env = new_env })
    | _ -> Result.err(TypeMismatch { expected: "Number", got: "Other" })
}

fn execute_block(
  block: List<Statement>,
  state: RuntimeState
) -> Result<RuntimeState, RuntimeError> {
  List.fold(block, Result.ok(state), |state_res, stmt| {
    match state_res with
    | Err(e) -> Result.err(e)
    | Ok(s) -> execute_single_statement(stmt, s)
  })
}

fn execute_single_statement(
  stmt: Statement,
  state: RuntimeState
) -> Result<RuntimeState, RuntimeError> {
  match stmt with
  | Let(let_stmt) ->
    let value = eval_expr(let_stmt.expr, state.env)?
    let new_env = Map.insert(state.env, let_stmt.var, value)
    Result.ok({ state with env = new_env })

  | Print(exprs) ->
    let values = collect_expr_results(exprs, state.env)?
    let text = values
      |> List.map(value_to_text)
      |> Text.join(" ")
    let new_output = List.push_back(state.output, text)
    Result.ok({ state with output = new_output })

  | _ -> Result.ok(state)
}

fn execute_for_loop(
  var: Text,
  start: Value,
  end: Value,
  step: Value,
  body: List<Statement>,
  program: List<(i32, Statement)>,
  pc: i32,
  state: RuntimeState
) -> Result<List<Text>, RuntimeError> {
  match (start, end, step) with
  | (VNumber(s), VNumber(e), VNumber(st)) ->
    for_loop_helper(var, s, e, st, body, program, pc, state)
  | _ -> Result.err(TypeMismatch { expected: "Number", got: "Other" })
}

fn for_loop_helper(
  var: Text,
  current: f64,
  end: f64,
  step: f64,
  body: List<Statement>,
  program: List<(i32, Statement)>,
  pc: i32,
  state: RuntimeState
) -> Result<List<Text>, RuntimeError> {
  if (step > 0.0 and current > end) or (step < 0.0 and current < end) {
    execute_program(program, pc + 1, state)
  } else {
    let new_env = Map.insert(state.env, var, VNumber(current))
    let new_state = execute_block(body, { state with env = new_env })?
    for_loop_helper(var, current + step, end, step, body, program, pc, new_state)
  }
}

fn execute_while_loop(
  cond: Expr,
  body: List<Statement>,
  program: List<(i32, Statement)>,
  pc: i32,
  state: RuntimeState
) -> Result<List<Text>, RuntimeError> {
  let cond_val = eval_expr(cond, state.env)?
  if is_truthy(cond_val) {
    let new_state = execute_block(body, state)?
    execute_while_loop(cond, body, program, pc, new_state)
  } else {
    execute_program(program, pc + 1, state)
  }
}

fn eval_expr(expr: Expr, env: Env) -> Result<Value, RuntimeError> {
  match expr with
  | Number(n) -> Result.ok(VNumber(n))
  | String(s) -> Result.ok(VString(s))
  | Variable(name) ->
    Map.get(env, name).ok_or(UndefinedVariable { name })

  | ArrayAccess(access) ->
    match Map.get(env, access.var) with
    | None -> Result.err(UndefinedVariable { name: access.var })
    | Some(VArray(arr)) ->
      let index_val = eval_expr(access.index, env)?
      match index_val with
      | VNumber(idx) ->
        let i = idx as i32
        List.get(arr, i).ok_or(IndexOutOfBounds)
      | _ -> Result.err(TypeMismatch { expected: "Number", got: "Other" })
    | Some(_) -> Result.err(TypeMismatch { expected: "Array", got: "Other" })

  | BinOp(bin) ->
    let left = eval_expr(bin.left, env)?
    let right = eval_expr(bin.right, env)?
    eval_binop(bin.op, left, right)

  | UnaryOp(unary) ->
    let operand = eval_expr(unary.operand, env)?
    eval_unaryop(unary.op, operand)
}

fn eval_binop(op: BinOperator, left: Value, right: Value) -> Result<Value, RuntimeError> {
  match (op, left, right) with
  | (Add, VNumber(l), VNumber(r)) -> Result.ok(VNumber(l + r))
  | (Sub, VNumber(l), VNumber(r)) -> Result.ok(VNumber(l - r))
  | (Mul, VNumber(l), VNumber(r)) -> Result.ok(VNumber(l * r))
  | (Div, VNumber(l), VNumber(r)) ->
    if r == 0.0 {
      Result.err(DivisionByZero)
    } else {
      Result.ok(VNumber(l / r))
    }
  | (Eq, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l == r { 1.0 } else { 0.0 }))
  | (Ne, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l != r { 1.0 } else { 0.0 }))
  | (Lt, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l < r { 1.0 } else { 0.0 }))
  | (Le, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l <= r { 1.0 } else { 0.0 }))
  | (Gt, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l > r { 1.0 } else { 0.0 }))
  | (Ge, VNumber(l), VNumber(r)) -> Result.ok(VNumber(if l >= r { 1.0 } else { 0.0 }))
  | (And, l, r) -> Result.ok(VNumber(if is_truthy(l) and is_truthy(r) { 1.0 } else { 0.0 }))
  | (Or, l, r) -> Result.ok(VNumber(if is_truthy(l) or is_truthy(r) { 1.0 } else { 0.0 }))
  | _ -> Result.err(TypeMismatch { expected: "Number", got: "Other" })
}

fn eval_unaryop(op: UnaryOperator, operand: Value) -> Result<Value, RuntimeError> {
  match (op, operand) with
  | (Neg, VNumber(n)) -> Result.ok(VNumber(-n))
  | (Not, v) -> Result.ok(VNumber(if is_truthy(v) { 0.0 } else { 1.0 }))
  | _ -> Result.err(TypeMismatch { expected: "Number", got: "Other" })
}

fn is_truthy(value: Value) -> bool {
  match value with
  | VNumber(n) -> n != 0.0
  | VString(s) -> not Text.is_empty(s)
  | VArray(a) -> not List.is_empty(a)
}

fn value_to_text(value: Value) -> Text {
  match value with
  | VNumber(n) -> format("{n}")
  | VString(s) -> s
  | VArray(_) -> "[Array]"
}

fn find_line(program: List<(i32, Statement)>, target: i32) -> Result<i32, RuntimeError> {
  List.find_index(program, |(line, _)| line == target)
    .ok_or(UndefinedLabel { line: target })
}

fn collect_expr_results(exprs: List<Expr>, env: Env) -> Result<List<Value>, RuntimeError> {
  List.fold(exprs, Result.ok(List.empty()), |acc, e| {
    match acc with
    | Err(err) -> Result.err(err)
    | Ok(list) ->
      match eval_expr(e, env) with
      | Ok(value) -> Result.ok(List.push_back(list, value))
      | Err(err) -> Result.err(err)
  })
}

// 利用例
// let source = """
// 10 LET x = 0
// 20 LET x = x + 1
// 30 PRINT x
// 40 IF x < 10 THEN GOTO 20 END
// 50 END
// """
// (parse_and_run source) => Ok(["1", "2", ..., "10"])
