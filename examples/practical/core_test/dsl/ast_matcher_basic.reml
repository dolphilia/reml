module Examples.Practical.CoreTest.Dsl.AstMatcherBasic

use Core.Parse
use Core.Parse.Lex
use Core.Test.Dsl

type Expr =
  | Int(Int)
  | Add(Expr, Expr)

type Ast = {
  tag: Str,
  items: List<Expr>
}

let sc: Parser<()> =
  Lex.whitespace()
    |> Lex.skipMany

fn lexeme<A>(p: Parser<A>) -> Parser<A> {
  Lex.lexeme(sc, p)
}

fn sym(text: Str) -> Parser<()> {
  Lex.symbol(sc, text)
}

fn int_expr() -> Parser<Expr> {
  lexeme(Lex.int10())
    .andThen(|digits| match Lex.parseI64(digits) with
      | Ok(value) -> ok(Int(value))
      | Err(_) -> fail(format("数値として解釈できません: {digits}"))
    )
}

fn expr_parser() -> Parser<Expr> {
  rule("dsl.expr.add",
    int_expr()
      .then(skipL(sym("+"), int_expr()))
      .map(|(lhs, rhs)| Add(lhs, rhs))
  )
}

fn ast_parser() -> Parser<Ast> {
  expr_parser().map(|expr| { tag: "expr", items: [expr] })
}

fn main() -> Str {
  let outcome = test_parser(ast_parser()) {
    case "1 + 2" => Ast(Record([
      ("tag", Pattern("\"expr\"")),
      ("items", List([Pattern("Add(Int(1), Int(2))")])),
    ]))
    case "1 + 3" => Ast(Pattern("...Add(Int(1), Int(3))..."))
  }
  match outcome with
    | Ok(_) -> "dsl:ok"
    | Err(_) -> "dsl:error"
}
