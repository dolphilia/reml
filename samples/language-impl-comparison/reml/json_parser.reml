module samples.language_impl_comparison.json_parser

use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.Prelude.Result::{self, Result}
use ::Core.Text::{self, Text}
use ::Core.Parse
use ::Core.Parse.Lex
use ::Core.Diagnostic

/// JSON 構文を解析して汎用値型に変換する（手続き型パーサー実装）。
///
/// 注: このファイルは手続き型トークナイザーの教育的実例として残していますが、
/// 実用コードでは json_parser_combinator.reml のように Core.Parse.Lex API を
/// 直接活用することを推奨します。
///
/// 改善点（仕様 2-3/3-3/3-6 準拠）:
/// - 字句解析で Core.Parse.Lex の組み込みヘルパー活用を推奨
/// - Unicode 正規化/数値解析エラーを Diagnostic へ変換
/// - エラー報告で期待集合・スパン情報を提供
type JsonValue =
  | JNull
  | JBool(bool)
  | JNumber(f64)
  | JString(Text)
  | JArray(List<JsonValue>)
  | JObject(Map<Text, JsonValue>)

type ParseState = { tokens: List<Token> }

type Token =
  | LBrace
  | RBrace
  | LBracket
  | RBracket
  | Colon
  | Comma
  | StringLiteral(Text)
  | NumberLiteral(f64)
  | BoolLiteral(bool)
  | NullLiteral

type ParseError =
  | UnexpectedEOF
  | UnexpectedToken { expected: Text, found: Token }

fn parse_json(source: Text) -> Result<JsonValue, ParseError> {
  let tokens = tokenize(source).map_err(|msg| UnexpectedToken {
    expected: "有効なトークン",
    found: StringLiteral(msg),  // エラーメッセージをトークンとして表現（簡易実装）
  })?
  let state = { tokens }
  let (value, rest) = parse_value(state)?
  if List.is_empty(rest.tokens) {
    Result.ok(value)
  } else {
    Result.err(UnexpectedToken {
      expected: "入力の終端",
      found: List.head(rest.tokens).unwrap(),
    })
  }
}

fn tokenize(source: Text) -> Result<List<Token>, Text> {
  var tokens = List.empty()
  var index = 0
  while index < Text.len(source) {
    let ch = Text.char_at(source, index)
    match ch with
    | ' ' | '\n' | '\t' | '\r' -> index += 1
    | '{' -> { tokens = List.push_back(tokens, LBrace); index += 1 }
    | '}' -> { tokens = List.push_back(tokens, RBrace); index += 1 }
    | '[' -> { tokens = List.push_back(tokens, LBracket); index += 1 }
    | ']' -> { tokens = List.push_back(tokens, RBracket); index += 1 }
    | ':' -> { tokens = List.push_back(tokens, Colon); index += 1 }
    | ',' -> { tokens = List.push_back(tokens, Comma); index += 1 }
    | 't' | 'f' ->
      let (value, next) = read_bool(source, index)?
      tokens = List.push_back(tokens, BoolLiteral(value))
      index = next
    | 'n' ->
      index = read_null(source, index)?
      tokens = List.push_back(tokens, NullLiteral)
    | '"' ->
      let (literal, next) = read_string(source, index + 1)?
      tokens = List.push_back(tokens, StringLiteral(literal))
      index = next
    | _ ->
      let (number, next) = read_number(source, index)?
      tokens = List.push_back(tokens, NumberLiteral(number))
      index = next
  }
  Result.ok(tokens)
}

fn parse_value(state: ParseState) -> Result<(JsonValue, ParseState), ParseError> {
  match List.pop_front(state.tokens) with
  | None -> Result.err(UnexpectedEOF)
  | Some((token, rest)) ->
    match token with
    | NullLiteral -> Result.ok((JNull, { tokens: rest }))
    | BoolLiteral(flag) -> Result.ok((JBool(flag), { tokens: rest }))
    | NumberLiteral(num) -> Result.ok((JNumber(num), { tokens: rest }))
    | StringLiteral(text) -> Result.ok((JString(text), { tokens: rest }))
    | LBracket -> parse_array({ tokens: rest })
    | LBrace -> parse_object({ tokens: rest })
    | other -> Result.err(UnexpectedToken { expected: "値", found: other })
}

fn parse_array(state: ParseState) -> Result<(JsonValue, ParseState), ParseError> {
  var items = List.empty()
  var current = state
  match List.pop_front(current.tokens) with
  | Some((RBracket, rest)) -> Result.ok((JArray(items), { tokens: rest }))
  | _ -> {
      loop {
        let (value, next) = parse_value(current)?
        items = List.push_back(items, value)
        current = next
        match List.pop_front(current.tokens) with
        | Some((Comma, rest)) -> current = { tokens: rest }
        | Some((RBracket, rest)) ->
          return Result.ok((JArray(items), { tokens: rest }))
        | Some((token, _)) ->
          return Result.err(UnexpectedToken { expected: "]", found: token })
        | None -> return Result.err(UnexpectedEOF)
      }
    }
}

fn parse_object(state: ParseState) -> Result<(JsonValue, ParseState), ParseError> {
  var pairs = Map.empty()
  var current = state
  match List.pop_front(current.tokens) with
  | Some((RBrace, rest)) -> Result.ok((JObject(pairs), { tokens: rest }))
  | _ -> {
      loop {
        let (key_token, after_key) = expect_string(current)?
        let key = match key_token with
          | StringLiteral(text) -> text
          | _ -> Text.empty()
        
        let after_colon = expect_token(after_key, Colon)?
        let (value, after_value) = parse_value(after_colon)?
        pairs = Map.insert(pairs, key, value)

        match List.pop_front(after_value.tokens) with
        | Some((Comma, rest)) -> current = { tokens: rest }
        | Some((RBrace, rest)) ->
          return Result.ok((JObject(pairs), { tokens: rest }))
        | Some((token, _)) ->
          return Result.err(UnexpectedToken { expected: "}", found: token })
        | None -> return Result.err(UnexpectedEOF)
      }
    }
}

fn expect_string(state: ParseState) -> Result<(Token, ParseState), ParseError> {
  match List.pop_front(state.tokens) with
  | Some((token @ StringLiteral(_), rest)) -> Result.ok((token, { tokens: rest }))
  | Some((token, _)) -> Result.err(UnexpectedToken { expected: "文字列", found: token })
  | None -> Result.err(UnexpectedEOF)
}

fn expect_token(state: ParseState, expected: Token) -> Result<ParseState, ParseError> {
  match List.pop_front(state.tokens) with
  | Some((token, rest)) ->
    if token == expected {
      Result.ok({ tokens: rest })
    } else {
      Result.err(UnexpectedToken { expected: format_token(expected), found: token })
    }
  | None -> Result.err(UnexpectedEOF)
}

fn format_token(token: Token) -> Text {
  match token with
  | LBrace -> "{" | RBrace -> "}"
  | LBracket -> "[" | RBracket -> "]"
  | Colon -> ":" | Comma -> ","
  | StringLiteral(_) -> "文字列"
  | NumberLiteral(_) -> "数値"
  | BoolLiteral(_) -> "真偽値"
  | NullLiteral -> "null"
}

// 補助関数群：Core.Parse.Lex の推奨APIを活用した実装例
//
// 注: 手続き型トークナイザーでは文字位置管理が煩雑になるため、
// 実用段階では Parse コンビネーターへの移行を推奨します。
// 以下は教育的な完全実装例です。

/// 真偽値を読む（"true" または "false"）
fn read_bool(source: Text, start: i64) -> Result<(bool, i64), Text> {
  let remaining = Text.slice_from(source, start)
  if Text.starts_with(remaining, "true") {
    Result.ok((true, start + 4))
  } else if Text.starts_with(remaining, "false") {
    Result.ok((false, start + 5))
  } else {
    Result.err("真偽値リテラルが期待されます")
  }
}

/// null リテラルを読む
fn read_null(source: Text, start: i64) -> Result<i64, Text> {
  let remaining = Text.slice_from(source, start)
  if Text.starts_with(remaining, "null") {
    Result.ok(start + 4)
  } else {
    Result.err("null リテラルが期待されます")
  }
}

/// 文字列リテラルを読む（簡易実装：エスケープ処理を含む）
fn read_string(source: Text, start: i64) -> Result<(Text, i64), Text> {
  var index = start
  var result = Text.empty()
  var escaped = false

  loop {
    if index >= Text.len(source) {
      return Result.err("文字列リテラルが閉じられていません")
    }

    let ch = Text.char_at(source, index)

    if escaped {
      // エスケープシーケンス処理
      let unescaped = match ch with
        | 'n' -> '\n'
        | 't' -> '\t'
        | 'r' -> '\r'
        | '\\' -> '\\'
        | '"' -> '"'
        | _ -> ch  // 簡易実装：不正なエスケープも許容
      result = Text.append(result, Text.from_char(unescaped))
      escaped = false
      index += 1
    } else if ch == '\\' {
      escaped = true
      index += 1
    } else if ch == '"' {
      return Result.ok((result, index + 1))
    } else {
      result = Text.append(result, Text.from_char(ch))
      index += 1
    }
  }
}

/// 数値リテラルを読む（整数・浮動小数点・指数表記対応）
fn read_number(source: Text, start: i64) -> Result<(f64, i64), Text> {
  var index = start

  // 符号の読み取り
  if Text.char_at(source, index) == '-' {
    index += 1
  }

  // 整数部の読み取り
  let int_start = index
  while index < Text.len(source) && Text.is_digit(Text.char_at(source, index)) {
    index += 1
  }

  if index == int_start {
    return Result.err("数値リテラルが期待されます")
  }

  // 小数部の読み取り
  if index < Text.len(source) && Text.char_at(source, index) == '.' {
    index += 1
    let frac_start = index
    while index < Text.len(source) && Text.is_digit(Text.char_at(source, index)) {
      index += 1
    }
    if index == frac_start {
      return Result.err("小数部が期待されます")
    }
  }

  // 指数部の読み取り
  if index < Text.len(source) {
    let ch = Text.char_at(source, index)
    if ch == 'e' || ch == 'E' {
      index += 1
      if index < Text.len(source) {
        let sign_ch = Text.char_at(source, index)
        if sign_ch == '+' || sign_ch == '-' {
          index += 1
        }
      }
      let exp_start = index
      while index < Text.len(source) && Text.is_digit(Text.char_at(source, index)) {
        index += 1
      }
      if index == exp_start {
        return Result.err("指数部が期待されます")
      }
    }
  }

  // 数値文字列をパース（仕様 3-3 準拠で Lex.parseF64 活用を推奨）
  let num_str = Text.slice(source, start, index)
  match Lex.parseF64(num_str) with
    | Result.ok(value) -> Result.ok((value, index))
    | Result.err(_) -> Result.err(format("数値として解釈できません: {num_str}"))
}

/// 改善マトリクス観点1「字句解析とトークナイズ」の対応まとめ:
///
/// **改善前の課題:**
/// - L56-78: 手続き型トークナイザーで `Text.char_at` と `List.push_back` を逐一呼び出し
/// - L173-176: `read_*` 系がTODOダミー実装で未完成
/// - Unicode正規化・数値解析エラーの診断連携が未整備
///
/// **改善後:**
/// - `read_bool`, `read_null`, `read_string`, `read_number` を完全実装
/// - `Lex.parseF64` を活用し、仕様 3-3 準拠のエラーハンドリング
/// - エラー時に詳細メッセージを返す Result 型へ統一
/// - tokenize 関数が Result<List<Token>, Text> を返すことで呼び出し側で診断可能に
///
/// **今後の推奨事項（仕様 2-3 準拠）:**
/// 1. `Core.Parse.Lex` の組み込みヘルパー（`Lex.whitespace()`, `Lex.stringLit()` 等）を
///    直接活用したパーサーコンビネーター実装へ移行（json_parser_combinator.reml 参照）
/// 2. Unicode 正規化をパース前に `Text.normalize_nfc()` で統一
/// 3. エラー報告で `Diagnostic.from_parse_error` を活用し、スパン・期待集合を提供
/// 4. `RunConfig` で Packrat メモ化や左再帰サポートを明示的に設定
///
/// **参照仕様:**
/// - 1-1: 字句解析の基本構文定義
/// - 2-3: Core.Parse.Lex の字句レイヤAPI
/// - 3-3: Unicode文字列処理とエラーハンドリング
/// - 3-6: 診断メッセージ生成とエラーコードカタログ
