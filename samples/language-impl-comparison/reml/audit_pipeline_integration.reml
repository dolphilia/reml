module samples.language_impl_comparison.audit_pipeline_integration

use ::Core.Parse as Parse
use ::Core.Async as Async
use ::Core.Diagnostics as Diag
use ::Core.Runtime as Runtime
use ::Core.Resource as Resource
use ::Core.Collection.List as List
use ::Core.Collection.Map as Map
use ::Core.IO as IO
use ::Core.Text.String as Str
use ::Core.Config as Config

/// 監査対応パイプライン: Conductor/Capability/監査イベントの複合運用を再現
///
/// **検証対象**:
/// - 3-6-core-diagnostics-audit.md §1.1.1 の AuditEvent タクソノミー
/// - 3-8-core-runtime-capability.md §1.2 の Capability検証と Stage チェック
/// - 3-9-core-async-ffi-unsafe.md §1.4.5 の channel_metrics API
/// - 異常系: タイムアウト、Capability不足、リソース制限超過
/// - 再設定ケース: ConfigCompatibility の動的変更と監査ログ記録
///
/// **想定ユースケース**:
/// 監査要件の厳しいシステムで、パイプライン実行の全ステージを
/// AuditEvent として記録し、Capability 不一致や異常終了を
/// Diagnostic として可視化する。

/// ============================================================================
/// 1. データ型定義
/// ============================================================================

/// パイプライン入力データ
type PipelineInput = {
  id: Int,
  data: Str,
  priority: Int,
}

/// パイプライン出力データ
type PipelineOutput = {
  id: Int,
  result: Str,
  processed_at: Int,
}

/// パイプライン統計情報
type PipelineMetrics = {
  total_processed: Int,
  total_failed: Int,
  avg_latency_ms: Float,
  backpressure_events: Int,
}

/// ============================================================================
/// 2. 監査イベント発行ユーティリティ
/// ============================================================================

/// パイプライン開始イベントを発行
/// 効果: {audit}
fn emit_pipeline_started(
  pipeline_id: Str,
  node_id: Str
) -> Result<(), Diag.AuditError>  // effect {audit}
  = do {
    let event = Diag.AuditEvent.PipelineStarted;
    let envelope = Diag.AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: None,
      capability: None,
      metadata: Map.from_list([
        ("pipeline.id", Json.String(pipeline_id)),
        ("pipeline.node", Json.String(node_id)),
        ("timestamp", Json.Number(current_timestamp())),
      ]),
    };

    let diagnostic = Diag.diagnostic("Pipeline started")
      |> Diag.with_severity(Diag.Severity.Info)
      |> Diag.with_domain(Diag.DiagnosticDomain.Runtime)
      |> Diag.with_code("audit.pipeline.started")
      |> Diag.attach_audit(envelope)
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)
  }

/// パイプライン完了イベントを発行
/// 効果: {audit}
fn emit_pipeline_completed(
  pipeline_id: Str,
  count: Int
) -> Result<(), Diag.AuditError>  // effect {audit}
  = do {
    let envelope = Diag.AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: None,
      capability: None,
      metadata: Map.from_list([
        ("pipeline.id", Json.String(pipeline_id)),
        ("pipeline.outcome", Json.String("success")),
        ("pipeline.count", Json.Number(count)),
        ("timestamp", Json.Number(current_timestamp())),
      ]),
    };

    let diagnostic = Diag.diagnostic("Pipeline completed successfully")
      |> Diag.with_severity(Diag.Severity.Info)
      |> Diag.with_domain(Diag.DiagnosticDomain.Runtime)
      |> Diag.with_code("audit.pipeline.completed")
      |> Diag.attach_audit(envelope)
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)
  }

/// パイプライン失敗イベントを発行
/// 効果: {audit}
fn emit_pipeline_failed(
  pipeline_id: Str,
  error_code: Str,
  error_message: Str
) -> Result<(), Diag.AuditError>  // effect {audit}
  = do {
    let envelope = Diag.AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: None,
      capability: None,
      metadata: Map.from_list([
        ("pipeline.id", Json.String(pipeline_id)),
        ("error.code", Json.String(error_code)),
        ("error.message", Json.String(error_message)),
        ("error.severity", Json.String("Error")),
        ("timestamp", Json.Number(current_timestamp())),
      ]),
    };

    let diagnostic = Diag.diagnostic(error_message)
      |> Diag.with_severity(Diag.Severity.Error)
      |> Diag.with_domain(Diag.DiagnosticDomain.Runtime)
      |> Diag.with_code(error_code)
      |> Diag.attach_audit(envelope)
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)
  }

/// Capability 不一致イベントを発行
/// 効果: {audit}
fn emit_capability_mismatch(
  capability_id: Str,
  expected_stage: Runtime.StageId,
  actual_stage: Runtime.StageId
) -> Result<(), Diag.AuditError>  // effect {audit}
  = do {
    let envelope = Diag.AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: None,
      capability: Some(capability_id),
      metadata: Map.from_list([
        ("capability.id", Json.String(capability_id)),
        ("capability.expected_stage", Json.String(stage_to_string(expected_stage))),
        ("capability.actual_stage", Json.String(stage_to_string(actual_stage))),
        ("timestamp", Json.Number(current_timestamp())),
      ]),
    };

    let diagnostic = Diag.diagnostic(
        Str.concat("Capability stage mismatch: ", capability_id)
      )
      |> Diag.with_severity(Diag.Severity.Error)
      |> Diag.with_domain(Diag.DiagnosticDomain.Effect)
      |> Diag.with_code("effects.contract.stage_mismatch")
      |> Diag.attach_audit(envelope)
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)
  }

/// ============================================================================
/// 3. Capability 検証と Stage チェック
/// ============================================================================

/// Capability Registry を使用して Stage を検証
/// 効果: {runtime, audit}
fn verify_pipeline_capabilities(
  required_capabilities: List<(Str, Runtime.StageRequirement)>
) -> Result<(), Str>  // effect {runtime, audit}
  = do {
    let registry = Runtime.registry();

    List.for_each(required_capabilities, |(cap_id, stage_req)| {
      match Runtime.verify_capability_stage(cap_id, stage_req) {
        | Ok(handle) -> {
          IO.println(Str.concat("✓ Capability verified: ", cap_id));
          Ok(())
        }
        | Err(err) -> {
          let (expected, actual) = match stage_req {
            | Runtime.StageRequirement.Exact(stage) -> (stage, Runtime.StageId.Experimental)
            | Runtime.StageRequirement.AtLeast(stage) -> (stage, Runtime.StageId.Experimental)
          };

          emit_capability_mismatch(cap_id, expected, actual)?;
          Err(Str.concat("Capability verification failed: ", cap_id))
        }
      }
    })?;

    Ok(())
  }

/// ============================================================================
/// 4. リソース制限と監視メトリクス
/// ============================================================================

/// リソース制限を設定し、監視メトリクスを初期化
/// 効果: {runtime}
fn setup_resource_limits_and_metrics(
  pipeline_id: Str
) -> Result<Diag.DslMetricsHandle, Str>  // effect {runtime}
  = do {
    // リソース制限の設定
    let limits = Async.ResourceLimitSet.new(
      memory: Some(Resource.MemoryLimit.from_mb(256)),
      cpu: Some(Resource.CpuQuota.from_ratio(0.75))
    );

    IO.println("Resource limits configured:");
    IO.println(Str.concat("  Memory: 256MB"));
    IO.println(Str.concat("  CPU: 75%"));

    // メトリクスハンドルを作成
    let metrics_registry = Runtime.create_metrics_registry();
    let metrics_handle = Diag.register_dsl_metrics(metrics_registry, pipeline_id)?;

    Ok(metrics_handle)
  }

/// バックプレッシャーイベントを記録
/// 効果: {trace, audit}
fn record_backpressure_event(
  handle: Diag.DslMetricsHandle,
  channel_id: Str,
  queue_depth: Int
) -> ()  // effect {trace, audit}
  = do {
    Diag.observe_backpressure(handle, queue_depth);

    IO.println(Str.concat(
      "⚠ Backpressure detected on channel ",
      Str.concat(channel_id, Str.concat(": queue depth = ", Str.from_int(queue_depth)))
    ));
  }

/// ============================================================================
/// 5. チャネルメトリクス監視
/// ============================================================================

/// チャネルメトリクスを収集して監視
/// 効果: {io.async}
fn monitor_channel_metrics(
  receiver: Async.DslReceiver<PipelineInput>,
  channel_id: Str
) -> Result<Async.ChannelMetricsHandle, Async.AsyncError>  // effect {io.async}
  = do {
    let registry = Runtime.create_metrics_registry();
    let opts = Async.ChannelMetricOptions {
      collect_dropped_messages: true,
      collect_latency: true,
      collect_throughput: true,
    };

    let metrics = Async.channel_metrics(receiver, registry, channel_id, opts)?;

    IO.println(Str.concat("✓ Channel metrics enabled for: ", channel_id));

    Ok(metrics)
  }

/// チャネルメトリクスのスナップショットを取得して診断
/// 効果: {io.async, audit}
fn check_channel_health(
  handle: Async.ChannelMetricsHandle,
  channel_id: Str,
  high_watermark: Int
) -> Result<(), Async.AsyncError>  // effect {io.async, audit}
  = do {
    let sample = Async.snapshot_channel_metrics(handle)?;

    IO.println(Str.concat("Channel ", Str.concat(channel_id, " metrics:")));
    IO.println(Str.concat("  Queue depth: ", Str.from_int(sample.queue_depth)));
    IO.println(Str.concat("  Dropped messages: ", Str.from_int(sample.dropped_messages)));
    IO.println(Str.concat("  Throughput: ", Str.from_float(sample.throughput_per_sec)));

    // 高水位チェック
    if sample.queue_depth > high_watermark {
      let diagnostic = Diag.diagnostic("Channel queue depth exceeds high watermark")
        |> Diag.with_severity(Diag.Severity.Warning)
        |> Diag.with_domain(Diag.DiagnosticDomain.Async)
        |> Diag.with_code("async.channel.backpressure")
        |> Diag.attach_audit(Diag.AuditEnvelope {
          audit_id: Some(Diag.new_uuid()),
          change_set: None,
          capability: None,
          metadata: Map.from_list([
            ("channel_id", Json.String(channel_id)),
            ("queue_depth", Json.Number(sample.queue_depth)),
            ("high_watermark", Json.Number(high_watermark)),
          ]),
        })
        |> Diag.finish();

      Diag.emit(diagnostic, Diag.console_audit_sink)?;
    }

    Ok(())
  }

/// ============================================================================
/// 6. 設定互換性の動的変更と監査
/// ============================================================================

/// 設定互換性を動的に変更し、監査イベントを発行
/// 効果: {config, audit}
fn update_compatibility_mode(
  old_compat: Config.ConfigCompatibility,
  new_compat: Config.ConfigCompatibility
) -> Result<(), Diag.AuditError>  // effect {config, audit}
  = do {
    // 変更差分を記録
    let change_set = Config.diff_compatibility(old_compat, new_compat);

    let envelope = Diag.AuditEnvelope {
      audit_id: Some(Diag.new_uuid()),
      change_set: Some(Json.Object(change_set)),
      capability: None,
      metadata: Map.from_list([
        ("config.source", Json.String("Runtime")),
        ("config.format", Json.String(old_compat.format)),
        ("config.profile", Json.String(old_compat.profile)),
        ("config.compatibility", Json.String(new_compat.profile)),
        ("timestamp", Json.Number(current_timestamp())),
      ]),
    };

    let diagnostic = Diag.diagnostic("Configuration compatibility mode changed")
      |> Diag.with_severity(Diag.Severity.Warning)
      |> Diag.with_domain(Diag.DiagnosticDomain.Config)
      |> Diag.with_code("config.compat.changed")
      |> Diag.attach_audit(envelope)
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)?;

    IO.println(Str.concat(
      "Configuration compatibility updated: ",
      Str.concat(old_compat.profile, Str.concat(" → ", new_compat.profile))
    ));

    Ok(())
  }

/// ============================================================================
/// 7. パイプライン実行: 正常系
/// ============================================================================

/// パイプラインを実行（正常系）
/// 効果: {io.async, audit, runtime}
fn run_pipeline_normal(
  inputs: List<PipelineInput>,
  pipeline_id: Str
) -> Result<List<PipelineOutput>, Str>  // effect {io.async, audit, runtime}
  = do {
    emit_pipeline_started(pipeline_id, "normal_flow")?;

    // Capability 検証
    verify_pipeline_capabilities([
      ("io.async", Runtime.StageRequirement.AtLeast(Runtime.StageId.Stable)),
      ("audit", Runtime.StageRequirement.AtLeast(Runtime.StageId.Stable)),
    ])?;

    // メトリクス設定
    let metrics = setup_resource_limits_and_metrics(pipeline_id)?;

    // チャネル作成
    let (sender, receiver) = Async.create_channel(100, Async.Codec.json())?;
    let channel_metrics = monitor_channel_metrics(receiver, "input_channel")?;

    // データ処理
    let outputs = List.map(inputs, |input| {
      PipelineOutput {
        id: input.id,
        result: Str.concat("Processed: ", input.data),
        processed_at: current_timestamp(),
      }
    });

    // チャネルヘルスチェック
    check_channel_health(channel_metrics, "input_channel", 80)?;

    // 完了イベント発行
    emit_pipeline_completed(pipeline_id, List.length(outputs))?;

    Ok(outputs)
  }

/// ============================================================================
/// 8. パイプライン実行: 異常系（タイムアウト）
/// ============================================================================

/// パイプラインを実行（タイムアウト異常系）
/// 効果: {io.async, audit, runtime}
fn run_pipeline_timeout(
  inputs: List<PipelineInput>,
  pipeline_id: Str,
  timeout_ms: Int
) -> Result<List<PipelineOutput>, Str>  // effect {io.async, audit, runtime}
  = do {
    emit_pipeline_started(pipeline_id, "timeout_test")?;

    // タイムアウト付き実行をシミュレート
    let future = Async.timeout(
      Async.sleep_async(Duration.from_millis(timeout_ms + 100)),
      Duration.from_millis(timeout_ms)
    );

    match Async.block_on(future) {
      | Ok(_) -> {
        emit_pipeline_completed(pipeline_id, 0)?;
        Ok([])
      }
      | Err(Async.AsyncError.Timeout) -> {
        emit_pipeline_failed(
          pipeline_id,
          "async.timeout",
          Str.concat("Pipeline timed out after ", Str.concat(Str.from_int(timeout_ms), "ms"))
        )?;
        Err("Timeout")
      }
      | Err(err) -> {
        emit_pipeline_failed(pipeline_id, "async.error", err.message)?;
        Err(err.message)
      }
    }
  }

/// ============================================================================
/// 9. パイプライン実行: 異常系（Capability不足）
/// ============================================================================

/// パイプラインを実行（Capability不足異常系）
/// 効果: {audit, runtime}
fn run_pipeline_capability_missing(
  pipeline_id: Str
) -> Result<(), Str>  // effect {audit, runtime}
  = do {
    emit_pipeline_started(pipeline_id, "capability_missing_test")?;

    // 存在しない Capability を要求
    match verify_pipeline_capabilities([
      ("io.async", Runtime.StageRequirement.AtLeast(Runtime.StageId.Stable)),
      ("nonexistent.capability", Runtime.StageRequirement.Exact(Runtime.StageId.Stable)),
    ]) {
      | Ok(_) -> {
        emit_pipeline_completed(pipeline_id, 0)?;
        Ok(())
      }
      | Err(err) -> {
        emit_pipeline_failed(pipeline_id, "capability.missing", err)?;
        Err(err)
      }
    }
  }

/// ============================================================================
/// 10. パイプライン実行: リソース制限超過
/// ============================================================================

/// パイプラインを実行（リソース制限超過異常系）
/// 効果: {io.async, audit, runtime}
fn run_pipeline_resource_exceeded(
  inputs: List<PipelineInput>,
  pipeline_id: Str
) -> Result<(), Str>  // effect {io.async, audit, runtime}
  = do {
    emit_pipeline_started(pipeline_id, "resource_exceeded_test")?;

    // 意図的に小さいリソース制限を設定
    let limits = Async.ResourceLimitSet.new(
      memory: Some(Resource.MemoryLimit.from_kb(1)),  // 1KB - 非常に小さい
      cpu: Some(Resource.CpuQuota.from_ratio(0.01))   // 1% - 非常に小さい
    );

    // リソース制限超過を検出
    let diagnostic = Diag.diagnostic("Resource limit exceeded")
      |> Diag.with_severity(Diag.Severity.Error)
      |> Diag.with_domain(Diag.DiagnosticDomain.Runtime)
      |> Diag.with_code("runtime.resource.exceeded")
      |> Diag.attach_audit(Diag.AuditEnvelope {
        audit_id: Some(Diag.new_uuid()),
        change_set: None,
        capability: None,
        metadata: Map.from_list([
          ("pipeline.id", Json.String(pipeline_id)),
          ("resource.memory.limit", Json.String("1KB")),
          ("resource.cpu.limit", Json.String("1%")),
        ]),
      })
      |> Diag.finish();

    Diag.emit(diagnostic, Diag.console_audit_sink)?;

    emit_pipeline_failed(
      pipeline_id,
      "runtime.resource.exceeded",
      "Memory or CPU limit exceeded"
    )?;

    Err("Resource limit exceeded")
  }

/// ============================================================================
/// 11. メイン実行フロー
/// ============================================================================

/// 全パターンを実行してテスト
/// 効果: {io.async, audit, runtime, config}
pub fn main() -> Result<(), Str>  // effect {io.async, audit, runtime, config}
  = do {
    IO.println("=== 監査対応パイプライン統合テスト ===");
    IO.println("");

    // テストデータ
    let inputs = List.range(0, 10)
      |> List.map(|i| PipelineInput {
        id: i,
        data: Str.concat("data_", Str.from_int(i)),
        priority: i % 3,
      });

    // 1. 正常系
    IO.println("--- Test 1: 正常系パイプライン実行 ---");
    match run_pipeline_normal(inputs, "pipeline_normal") {
      | Ok(outputs) -> {
        IO.println(Str.concat("✓ 正常完了: ", Str.concat(Str.from_int(List.length(outputs)), "件処理")));
      }
      | Err(err) -> IO.println(Str.concat("✗ エラー: ", err))
    }
    IO.println("");

    // 2. タイムアウト異常系
    IO.println("--- Test 2: タイムアウト異常系 ---");
    match run_pipeline_timeout(inputs, "pipeline_timeout", 100) {
      | Ok(_) -> IO.println("✗ 想定外の成功")
      | Err(err) -> IO.println(Str.concat("✓ 期待通りエラー: ", err))
    }
    IO.println("");

    // 3. Capability不足異常系
    IO.println("--- Test 3: Capability不足異常系 ---");
    match run_pipeline_capability_missing("pipeline_capability_missing") {
      | Ok(_) -> IO.println("✗ 想定外の成功")
      | Err(err) -> IO.println(Str.concat("✓ 期待通りエラー: ", err))
    }
    IO.println("");

    // 4. リソース制限超過異常系
    IO.println("--- Test 4: リソース制限超過異常系 ---");
    match run_pipeline_resource_exceeded(inputs, "pipeline_resource_exceeded") {
      | Ok(_) -> IO.println("✗ 想定外の成功")
      | Err(err) -> IO.println(Str.concat("✓ 期待通りエラー: ", err))
    }
    IO.println("");

    // 5. 設定互換性変更テスト
    IO.println("--- Test 5: 設定互換性動的変更 ---");
    let old_compat = Config.ConfigCompatibility.default();
    let new_compat = Config.ConfigCompatibility {
      format: "json5",
      profile: "strict",
      extensions: Map.from_list([("allow_comments", Json.Bool(true))]),
    };
    match update_compatibility_mode(old_compat, new_compat) {
      | Ok(_) -> IO.println("✓ 設定変更完了")
      | Err(err) -> IO.println(Str.concat("✗ エラー: ", Str.from_audit_error(err)))
    }
    IO.println("");

    IO.println("=== 全テスト完了 ===");
    Ok(())
  }

/// ============================================================================
/// ユーティリティ関数
/// ============================================================================

fn current_timestamp() -> Int  // @pure
  = 1704067200  // 2024-01-01 00:00:00 UTC (仮想値)

fn stage_to_string(stage: Runtime.StageId) -> Str  // @pure
  = match stage {
    | Runtime.StageId.Experimental -> "Experimental"
    | Runtime.StageId.Beta -> "Beta"
    | Runtime.StageId.Stable -> "Stable"
  }
