// マクロベンチマーク: コレクション操作での型クラス性能測定
// Phase 2 Week 20-21: 実世界ユースケースを模したシナリオ

// リスト内の要素探索（Eq使用）
fn find_element(arr: [i64], target: i64, size: i64) -> Bool = {
  let mut found: Bool = false;
  let mut i: i64 = 0;

  while i < size {
    if arr[i] == target {
      found = true
    };
    i = i + 1
  };

  found
}

// リスト内の最小値探索（Ord使用）
fn find_min(arr: [i64], size: i64) -> i64 = {
  let mut min_val: i64 = arr[0];
  let mut i: i64 = 1;

  while i < size {
    if arr[i] < min_val {
      min_val = arr[i]
    };
    i = i + 1
  };

  min_val
}

// リスト内の重複要素カウント（Eq使用）
fn count_duplicates(arr: [i64], target: i64, size: i64) -> i64 = {
  let mut count: i64 = 0;
  let mut i: i64 = 0;

  while i < size {
    if arr[i] == target {
      count = count + 1
    };
    i = i + 1
  };

  count
}

// バブルソート（Ord使用）
fn bubble_sort_iteration(arr: [i64], size: i64) -> i64 = {
  let mut swaps: i64 = 0;
  let mut i: i64 = 0;

  while i < size - 1 {
    let mut j: i64 = 0;
    while j < size - i - 1 {
      if arr[j] > arr[j + 1] {
        // スワップ操作（簡易版）
        let temp: i64 = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        swaps = swaps + 1
      };
      j = j + 1
    };
    i = i + 1
  };

  swaps
}

// フィルタ処理（Ord使用）
fn filter_greater_than(arr: [i64], threshold: i64, size: i64) -> i64 = {
  let mut count: i64 = 0;
  let mut i: i64 = 0;

  while i < size {
    if arr[i] > threshold {
      count = count + 1
    };
    i = i + 1
  };

  count
}

// 複合操作: 範囲内の要素カウント（Ord使用）
fn count_in_range(arr: [i64], min: i64, max: i64, size: i64) -> i64 = {
  let mut count: i64 = 0;
  let mut i: i64 = 0;

  while i < size {
    if (arr[i] >= min) && (arr[i] <= max) {
      count = count + 1
    };
    i = i + 1
  };

  count
}

// main関数: すべてのマクロベンチマークを実行
fn main() -> i64 = {
  // テストデータ（10要素の配列）
  let arr: [i64] = [5, 2, 8, 1, 9, 3, 7, 4, 6, 0];
  let size: i64 = 10;

  // 各ベンチマークを10000回繰り返す
  let iterations: i64 = 10000;
  let mut total: i64 = 0;
  let mut i: i64 = 0;

  while i < iterations {
    // 要素探索
    let r1: Bool = find_element(arr, 5, size);
    if r1 { total = total + 1 };

    // 最小値探索
    let r2: i64 = find_min(arr, size);
    total = total + r2;

    // 重複カウント
    let r3: i64 = count_duplicates(arr, 5, size);
    total = total + r3;

    // バブルソート（1イテレーション）
    let r4: i64 = bubble_sort_iteration(arr, size);
    total = total + r4;

    // フィルタ処理
    let r5: i64 = filter_greater_than(arr, 5, size);
    total = total + r5;

    // 範囲内カウント
    let r6: i64 = count_in_range(arr, 3, 7, size);
    total = total + r6;

    i = i + 1
  };

  total
}
