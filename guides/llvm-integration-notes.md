# LLVMとの連携

「LLVM IR文字列を実行できるランタイム（IR実行器）」がすでに存在していることを前提に、Reml → LLVM IR までの"実装プロセス"を、\*\*ブートストラップ（OCaml実装）→ 最小構成（MVP）→ 本命構成（本格）→ セルフホスト\*\*の順に具体化します。

## ブートストラップ戦略

**Phase 0: Bootstrap Implementation (OCaml)**
- **目的**: 最初のRemlコンパイラをOCamlで実装
- **期間**: 2-3ヶ月（MVP）+ 4-6ヶ月（本格実装）
- **理由**: HM型推論・ADT実装に最適、最短期間でRemlコンパイラを実現
- **成果物**: RemlソースからLLVM IRを生成するOCaml製コンパイラ

**Phase 1: Self-Bootstrap準備**
- **目的**: OCaml実装でReml言語の基本機能を検証・安定化
- **重要**: Core.Parseライブラリの実装・検証
- **成果物**: 安定したReml言語仕様とOCaml実装

**Phase 2: Self-Host Transition**
- **目的**: RemlでRemlコンパイラを書き直し
- **期間**: 6-12ヶ月
- **戦略**: 段階的移植（Parser → TypeChecker → CodeGen → 統合）
- **成果物**: Reml自身で記述されたRemlコンパイラ

**Phase 3: Bootstrap完了**
- **検証**: Reml(OCaml実装)とReml(Self-Host)の出力一致確認
- **移行**: OCaml実装からSelf-Host実装への完全移行
- **保守**: 以降はReml自身でRemlを開発

---

# 全体像（産物と通過点）

```
Reml源コード
   └─(1) 構文解析：Core.Parse（字句/構文） → AST
         └─(2) 意味解析：名前解決・型推論(HM)・型クラス解決 → 型付きAST(TAST)
               └─(3) 降格/糖衣剥がし：パターンマッチ/パイプ等 → Core(中間表現)
                     └─(4) 中間最適化：単純化/インライン/モノモルフィゼーション → MIR
                           └─(5) LLVM IR生成：型レイアウト/呼出規約/所有権 → LLVM IR文字列
                                 └─(6) 実行：IR実行器に投げる（JIT/インタプリタ）
```

---

# 1) 構文解析（Parser）

## 目的

* Remlのソースを**AST**へ。**Bootstrap段階（OCaml実装）**: OCamlのパーサライブラリ（Menhir等）を使用。**Self-Host段階**: Core.Parse を使い、**エラー品質・左→右の読みやすさ**をそのまま享受。

## やること

* 字句：`lexeme/symbol/identifier/number/string`、コメント/空白の共通吸収。
* 構文：式（パイプ、関数適用、ラムダ、パターン、`match`）、宣言（`let/var/fn/type/use`）、モジュール。
* 優先度：`precedence{ right "^"; left "*/"; left "+-" }` 等で演算子宣言。
* **出力**：未型付けAST（位置情報Span含む）。
  例）`Expr::Call(fn, args, span)`、`Decl::Fn(name, params, retTy?, body, span)`。

> 早期MVPでは**式言語（数値/Bool/関数）+ let + if + 関数宣言**まででOK。

---

# 2) 意味解析（Resolver / Typer）

## 目的

* **名前解決**（スコープ・モジュール）、**型推論**（HM）、**型クラス/トレイト辞書**の具体化、**型注釈の補完**。

## やること

* シンボル表（Scopes）：トップレベル → 関数 → ローカル。
* HM型推論：`unify(subst, ty1, ty2)`、多相型の一般化/インスタンス化。
* トレイト（型クラス）制約：`Show a => a -> String` を**辞書引数**へ明示化（Coreで実体化）。
* **出力**：**型付きAST (TAST)**：ノードごとに最終型、関数は**多相スキーム**を保持。
* **エラー**：未束縛名、型不一致、曖昧制約、未解決トレイト。

> MVPでは型クラスなしでもよい。先に**単相/ジェネリクス最小**から。

---

# 3) 降格・糖衣剥がし（Desugar → Core）

## 目的

* LLVMに落としやすい形へ**正規化**。Reml構文砂糖（`|>`パイプ、`match`、パターン束縛、名前付き引数 等）を展開。

## やること（代表例）

* パイプ `x |> f |> g(a=1)` → 正格な関数適用列 `g(f(x), a=1)`。
* `match` → **決定木**（if-else/ジャンプテーブル）と**束縛抽出**。
* パターン束縛 `let (x, y) = pair` → フィールド抽出。
* クロージャ → **表明示**：`{ env_struct*, code_ptr }` にLower。
* 型クラス辞書 → 関数の**追加引数**として渡す（辞書パッシング）。

**Core IRの形**

* 式：`Let`, `If`, `Call`, `PrimOp`, `Closure{env, code}`, `Load/Store`（抽象）
* 代数的データ型(ADT)：`Tag + payload` の**明示表現**（tagged union）
* メモリ：抽象的に `alloc`（箱化）/ `stack`（逃げない場合）を注記

---

# 4) 中間最適化（Core→MIR）

## 目的

* IR生成前に**簡約**して構造を安定化。**モノモルフィゼーション**で多相を具体型へ。

## やること

* β簡約/インライン（閾値つき）、定数畳み込み、デッドコード削除、CSE（簡易）。
* **モノモルフィゼーション**：`fn id<T>(x:T)->T` を実際の使用型ごとに具体関数へ。

  * 代替案：**辞書渡し+reified型**で単一実装にする（MVPはモノモルフ推奨）。
* クロージャの**環境捕捉解析**：キャプチャ集合 → `env struct` レイアウト固定。
* **出力**：MIR（基本ブロックCFG、SSA準備済みの命令列＋型情報）。

> LLVMにSSA生成機能はあるが、**φノード位置**を意識したブロック割りが楽になる。

---

# 5) LLVM IR 生成（コード生成）

## 目的

* MIRを**LLVM IR文字列**に落とす。実行器に渡せる“正しいIR”。

## 必要な設計

### 5.0 ターゲット ABI / データレイアウト（ドラフト）

| 項目                  | 既定値 / 方針 | 備考 |
| ------------------- | ------------ | ---- |
| 主要ターゲット         | System V AMD64 (`x86_64-unknown-linux-gnu`)、Windows x64 (`x86_64-pc-windows-msvc`) | LLVM のデフォルト ABI から逸脱しない構成を優先。将来 ARM64 を追加予定。 |
| エンディアン           | リトルエンディアン | LLVM `DataLayout` 文字列で宣言。 |
| ポインタ幅             | 64bit (`p:64:64`) | Opaque Pointer 前提。FAT ポインタは構造体で表現。 |
| 整数アラインメント      | `i8:8`, `i16:16`, `i32:32`, `i64:64` | System V 互換。Windows でも互換値。 |
| 浮動小数点アラインメント | `f32:32`, `f64:64` | SSE2 対応前提。 |
| 構造体パッキング        | デフォルト（自然境界）。`#[repr(C)]` 相当の再現を優先。 | Reml 側で `@repr(packed)` 等のシンタックスを導入するまでは暗黙で自然境界。 |
| ベクトルアラインメント    | `v128:128` | SIMD 拡張予定時の互換性確保。 |

* **DataLayout 文字列例**（System V）：`e-m:e-p:64:64-f64:64:64-v128:128:128-a:0:64`。
* **呼出規約**：FFI 互換性のため、公開関数は `cc ccc`（C 既定）を採用。Windows では `RunConfig.extensions["runtime"].codegen.call_conv = "win64"` のような切替オプションを後日提供予定。
* **構造体レイアウト**：
  * 代数的データ型は `{i32 tag, [payload]}` を基本とし、payload は最大幅の union または variant ごとの構造体に Lower。
  * 文字列/スライスは `{ptr data, i64 len}`。FFI 渡し時は所有権ルール（下記）が必須。
* **所有権モデル**：
  * RC ベース。`extern` へ渡す場合は `inc_ref` で寿命を延長し、戻ったら `dec_ref`。逆方向で受け取る場合は FFI 側が `reml_release_*` を呼ぶ契約を `guides/reml-ffi-handbook.md` で定義する。
  * `unsafe` 境界で未解放が起こらないよう、FFI シムは RAII 風ヘルパを提供予定。
* **例外とパニック**：Reml は例外を持たず、`panic` は `abort` 相当。C++ 例外との境界では `noexcept` としてリンク。
* **WASM/WASI**：DataLayout と ABI は未定。別途調査メモを参照し、この節に将来追加する。

### 5.1 型対応表

| Reml     | LLVM IR                | 備考                               |
| ----------- | ---------------------- | -------------------------------- |
| `i1`/`Bool` | `i1`                   | 分岐/比較結果                          |
| `i32/i64`   | `i32/i64`              | そのまま                             |
| `f64`       | `double`               |                                  |
| ポインタ        | `ptr`                  | LLVM 15+のopaque ptrを想定           |
| 文字列         | `{i8*, i64}`           | データ/長さ（実装都合でRT管理）                |
| 代数型         | `{i32 tag, [payload]}` | tag先頭、payloadは最大幅のunion表現 or 個別型 |

### 5.2 呼び出し規約 & 名称

* C互換（`cc ccc`）、`extern "C"` でFFIしやすく。
* 関数名はモジュール名でマングル：`k__mod__fn__i64_i64`.

### 5.3 メモリ/所有権

* **MVP**：**参照カウント(RC)** のランタイム（`inc_ref/dec_ref`）を同梱。

  * 文字列/ボックス化値/クロージャ環境で使用。
  * **借用はコンパイラ内の最適化**に留め、言語表面には出さない。
* 後でArena/RCハイブリッドやリージョン最適化に拡張可。

### 5.4 ランタイム（最小）

* `mem_alloc(size)`, `mem_free(ptr)`, `panic(msg)`, `print_i64`, `inc_ref`, `dec_ref`。
* これらは**別モジュールのIR**として用意し、リンクまたは実行器へ同時投入。

### 5.5 代表的なLowering

* **if**：`br` で2ブロック＋φノード。
* **パターンマッチ**：`switch tag` → caseごとにcast/extract。
* **クロージャ**：`env*` を1引数目に、`code_ptr(env*, args...)` 形式。
* **タプル/構造体**：`insertvalue/extractvalue` or `alloca`＋`gep`。
* **配列/スライス**：`{ptr, len, cap}`（MVPは不変長だけでも可）。

### 5.6 例：Reml → LLVM IR（ミニ）

**Reml**

```reml
fn add(a: i64, b: i64) -> i64 = a + b

pub fn main() -> i64 = add(2, 40)
```

**出力IR（概略）**

```llvm
declare i64 @print_i64(i64)

define i64 @k__add(i64 %a, i64 %b) {
entry:
  %sum = add i64 %a, %b
  ret i64 %sum
}

define i64 @k__main() {
entry:
  %r = call i64 @k__add(i64 2, i64 40)
  ret i64 %r
}
```

---

# 6) 実行フェーズ

* 生成したIR文字列を**IR実行器**へ渡す。

  * 単一モジュール文字列 or 本体IR + ランタイムIRを**連結**して投入。
  * エントリは `@k__main`（戻り値をプロセス終了コードに流す等）。

---

# 7) テスト/検証の進め方（実務手順）

1. **E2Eスモーク**：算術/if/let/関数呼び出し → IR → 実行器 → 期待値。
2. **型推論の単体**：多相関数の一般化/インスタンス化・エラー系。
3. **Core等式性**：糖衣前後で意味が等しいことのプロパティテスト。
4. **IR整合性**：`opt -verify` 相当の検証をCIで回す。
5. **メモリ安全**：`inc_ref/dec_ref` のリーク/二重解放をサニタイザで監視。
6. **パターンマッチ網羅**：非網羅時に警告/エラー（将来的に必須）。

---

# 8) 実装段階の拡張計画

* **MVP（最小実装）**

  * 型：`i64`, `bool`、単相関数
  * 機能：let/if/fn/app、**基本演算子のみのトレイト**、標準I/O最小
  * メモリ：プリミティブ中心（GC不要）
  * **ゴール**：IR実行器で `main` が走る

* **本格実装**

  * タプル/配列/文字列（RC管理）、クロージャ（env\*）
  * モノモルフィゼーションでジェネリクス
  * **ユーザ定義トレイト**、where制約、制約解決

* **完全実装**

  * ADT/`match`/型クラス**辞書パッシング**、パターン網羅性チェック
  * 例外ではなく `Result` を一級化、`?` 演算子風デシュガ
  * デバッグ情報（DWARF）、最適化フラグ（`-O2`相当）連携
  * **高階型クラス**、特殊化

* **拡張実装**

  * 左再帰・Packrat切替、インクリメンタル/LLDリンク、FFI、並列/タスク

---

# 9) 作業ブレークダウン（タスクリスト）

* [ ] **文法定義**（Core.Parse）：式/宣言/モジュール、precedence表
* [ ] **AST構造体**＋Span
* [ ] **名前解決**：スコープ/モジュール/インポート
* [ ] **型表現**：単相→多相、ユニフィケーション、型エラー整形
* [ ] **Desugar**：パイプ/パターン/ラムダ/辞書
* [ ] **Core/MIR**：ブロックCFG、閉包表現、ADT表現
* [ ] **IR選択**：型マップ、呼出規約、ランタイムAPI
* [ ] **IRエミッタ**：関数/ブロック/命令/φ/スイッチ/構造体
* [ ] **ランタイムIR**：mem/rc/print/panic
* [ ] **統合**：IR実行器連携ユーティリティ（モジュール結合、エントリ呼び）
* [ ] **テスト**：E2E、型推論、IR検証、メモリ衛生

---

# 10) 小さな“つなぎ込み”例（if/phi）

**Reml**

```reml
fn abs(x: i64) -> i64 =
  if x < 0 then -x else x
```

**LLVM IR（概略）**

```llvm
define i64 @k__abs(i64 %x) {
entry:
  %isneg = icmp slt i64 %x, 0
  br i1 %isneg, label %neg, label %pos

neg:
  %nx = sub i64 0, %x
  br label %join

pos:
  br label %join

join:
  %r = phi i64 [ %nx, %neg ], [ %x, %pos ]
  ret i64 %r
}
```

---

## まとめ

* **パーサ**（Core.Parse）→ **型推論** → **Desugar/Core** → **MIR最適化** → **LLVM IR** → **実行器**という一本道。
* 最初は**単相・プリミティブ中心**で“IRが正しく動く”ところまで最短で到達し、次に**クロージャ/ADT/辞書**へ広げるのが最短経路。
* **所有権/メモリ**はMVPでは最小（RC or no-GC）で済ませ、将来最適化で“ゼロコスト抽象”へ近づける。
