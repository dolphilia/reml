# Kestrel プロジェクトの目的と指針

## 1. プロジェクトが解決したい課題

- パーサーコンビネーターを核にした言語処理系を、構想から実行まで最短距離で組み立てられるようにする。
- DSL やコンパイラを何度も試作・改良する際のサイクルを縮め、試行錯誤を支える学習・実務両面の環境を整える。
- 実サービスやツールとして利用できる現実的な性能・FFI・JIT/IR 連携を備え、学習用途でも妥協しない品質を確保する。

## 2. プロジェクトの最上位ゴール

1. **書きやすく読みやすい言語体験**: 宣言的な優先度設定、左から右へ流れるパイプ、強力な型推論によって短い記述で意図が伝わること。
2. **エラー品質の徹底**: 位置・期待集合・コミット境界・復旧・トレースを揃え、何が欲しかったのかを即座に伝える診断を標準で提供すること。
3. **実用性能と安全性の両立**: 末尾最適化・トランポリン・Packrat/左再帰の切り替え、ゼロコピー志向の設計で、大規模入力やリアルタイム用途にも耐える基盤を確保すること。
4. **Unicode ファーストな実装**: `byte/char/grapheme` の三層モデルを前提に、現実の多言語・絵文字・結合記号を安全に扱えること。
5. **自力完結できるエコシステム**: Kestrel 自身が Nest.Parse を使ってセルフホストでき、LLVM/FFI と接続して現実のアプリケーションへ落とし込めるまでの道筋を示すこと。

## 3. 設計を貫く基本哲学

- **小さく強いコア**: 言語も標準パーサ API も 10 数個の本質的プリミティブに凝縮し、残りは合成で表現する。
- **宣言で終わらせる操作性**: 演算子優先度・空白処理・字句規則を宣言的に与えることで、記述者が「何をしたいか」に集中できるようにする。
- **効果の制御と安全なバックトラック**: `cut`, `label`, `recover`, `trace` などの効果を明示し、失敗の伝播や復旧をプログラマが設計できるようにする。
- **ツールフレンドリーな情報保持**: `SpanTrace` や期待集合を保持し、IDE・可視化・インクリメンタル解析への連携を想定してデータを捨てない。
- **段階的な最適化パイプライン**: 構文解析 → 型推論 → 降格 → MIR → LLVM IR の工程を明文化し、MVP から本格実装まで拡張しやすい構造にする。

## 4. 想定利用シナリオ

- **コンパイラ開発の学習基盤**: HM 型推論や効果システムを含むフルスタックな処理系設計を、教材として再現・改造しやすいようにする。
- **多数の DSL を抱えるプロジェクト**: ゲームエンジンなど複数ジャンルで異なる記法が必要な現場で、Nest.Parse を中心に高速に DSL を組み立てられるよう支援する。
- **実運用を視野に入れたツール開発**: LLVM 連携や FFI を前提に、JIT 実行・実行形式生成・ホスト言語との橋渡しを行うアプリケーションを想定する。

## 5. 成功の判断基準

- Kestrel と Nest.Parse だけで「読みやすく診断が良い」パーサを組み立て、Packrat/左再帰の切り替えやエラー整形が宣言的に制御できる。
- 自身のコンパイラが Kestrel で記述され、LLVM IR 生成パイプラインを通じて JIT/バイナリを実行できる状態まで持っていける。
- Unicode を含む複雑な入力や大規模データに対しても、設計思想どおりに安定した性能・エラー品質・可観測性が確認できる。
- 教材や実務で再利用しやすいガイド（本仕様群）として、関係ドキュメント間で理念・目的が一貫して説明されている。

## 6. 今後の対話で検証すべき観点

- ここに挙げたゴールを満たすうえで、各仕様書が具体的にどこを支えているか（欠落や重複がないか）。
- Packrat/左再帰やエラー回復など、オプション機能のトレードオフと既定値が目的に沿っているか。
- LLVM 連携・セルフホスト達成までのロードマップが、ドキュメント間で矛盾なく説明されているか。
- 教育用途・実務用途の双方で使いやすいよう、サンプル・チュートリアル・ユースケースが十分か。
