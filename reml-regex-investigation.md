# Reml における正規表現導入検討

## 背景
Reml はパーサーコンビネーター最適化と言語仕様の明確性を重視しており、宣言的な構文合成、強力な推論、Unicode 第一主義、詳細なエラーレポートが核心要素である。本検討では、外部言語で広く用いられる正規表現を Reml の仕様または標準 API に組み込むべきかを評価する。

## メリット
- 既存エコシステムとの親和性: PCRE や POSIX 互換の正規表現経験を持つ開発者が Reml でも同様のパターン表現を再利用できる。
- 軽量な字句処理の効率化: 固定フォーマットのログ解析や単純なバリデーションを線形時間で処理でき、`2-3-lexer.md` が担う字句層の責務を補助する。
- パーサーと役割分担: コンビネータで扱いづらい微細なテキスト断片を正規表現で事前フィルタし、その結果を Reml パーサに渡すといった二層構成が可能になる。

## デメリット・懸念
- 設計哲学との緊張: 正規表現は宣言的だが Reml の高水準パターン合成とは抽象レベルが異なり、学習負荷と二重定義を招く恐れがある。
- 安全性・性能リスク: バックトラッキング型エンジンは Catastrophic Backtracking を引き起こす可能性があり、`2-5-error.md` で重視する決定的なエラー報告を損ねる。
- Unicode 整合性の課題: Reml の 3 層文字モデル（Byte / Char / Grapheme）に合わせた `Regex` 実装が必要で、既存ライブラリの流用は難しい。
- エラー統合の複雑さ: 正規表現由来のエラーを Reml の期待集合・トレース形式にマッピングする追加設計が不可欠。

## 実装方針（想定）
1. 標準ライブラリに `Core.Regex` モジュールを追加し、`Regex.compile` もしくは `regex "…"` リテラルで NFA/DFA を生成する。
2. 字句層連携として `RegexParser : Parser<Token>` 等のブリッジコンビネータを提供し、既存パーサーと組み合わせやすくする。
3. Unicode モードを必須指定とし、`mode = Byte | Char | Grapheme` などで Reml の文字層に沿った判定を行う。
4. エラー処理は `RegexError` を `ParseError` に変換するラッパーを用意し、失敗位置・期待集合を Reml 標準の形式に再構築する。
5. 既定は DFA ベースで線形時間を保証し、バックトラックを伴う高度機能は `unsafe regex` など効果システム経由で明示的に opt-in させる。

## 総合評価
正規表現は Reml のコア仕様に組み込むよりも、標準ライブラリの補助モジュールとして提供する方が整合的である。特定ユースケース（外部データとの連携、簡易バリデーション）で有用だが、Reml のコンビネータが本来担う文法記述と競合させない設計が望ましい。導入の際は Unicode 仕様、エラー統合、性能保証について明確な仕様策定が前提条件になる。

## 今後のアクション
- Unicode モードとエラー統合を含む `Core.Regex` の仕様ドラフトを作成する。
- `2-3-lexer.md` に正規表現利用の設計サンプルを追加し、責務分担を明示する。
- 安全な利用ガイドライン（線形保証、危険なパターンの検出手順）をドキュメント化する。
