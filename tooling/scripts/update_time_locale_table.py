#!/usr/bin/env python3
"""
Core.Time のロケールテーブルを CSV から生成する補助スクリプト。

`docs/plans/bootstrap-roadmap/assets/time-format-locale-map.csv` を読み取り、
`compiler/runtime/src/time/locale_table_data.rs` を上書きする。
"""

from __future__ import annotations

import argparse
import csv
import datetime as dt
from pathlib import Path
from typing import List, Sequence


ROOT = Path(__file__).resolve().parents[2]
DEFAULT_CSV = ROOT / "docs" / "plans" / "bootstrap-roadmap" / "assets" / "time-format-locale-map.csv"
DEFAULT_OUTPUT = ROOT / "compiler" / "rust" / "runtime" / "src" / "time" / "locale_table_data.rs"

STATUS_MAP = {
    "supported": "LocaleStatus::Supported",
    "planned": "LocaleStatus::Planned",
    "deprecated": "LocaleStatus::Deprecated",
}


def parse_bool(value: str) -> bool:
    normalized = value.strip().lower()
    if normalized in {"1", "true", "yes"}:
        return True
    if normalized in {"0", "false", "no", ""}:
        return False
    raise ValueError(f"bool として解釈できません: {value!r}")


def escape_str(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def load_entries(csv_path: Path) -> List[str]:
    with csv_path.open(newline="", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        rows = list(reader)
    entries: List[str] = []
    for row in rows:
        locale_id = row.get("locale_id", "").strip()
        if not locale_id:
            continue
        status_key = row.get("status", "").strip().lower()
        status = STATUS_MAP.get(status_key)
        if status is None:
            raise ValueError(f"未知の status: {row.get('status')} (locale={locale_id})")
        fallback = row.get("fallback", "").strip()
        notes = escape_str(row.get("notes", "").strip())
        supports_rfc3339 = parse_bool(row.get("supports_rfc3339", "true"))
        supports_unix = parse_bool(row.get("supports_unix", "true"))
        supports_custom = parse_bool(row.get("supports_custom", "true"))
        fallback_expr = f'Some("{fallback}")' if fallback else "None"
        entry = f"""    TimeLocaleEntry {{
        id: "{locale_id}",
        supports_rfc3339: {str(supports_rfc3339).lower()},
        supports_unix: {str(supports_unix).lower()},
        supports_custom: {str(supports_custom).lower()},
        status: {status},
        fallback: {fallback_expr},
        notes: "{notes}",
    }},"""
        entries.append(entry)
    return entries


def render(entries: Sequence[str], csv_path: Path) -> str:
    timestamp = dt.datetime.now(dt.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    header = f"""// @generated by tooling/scripts/update_time_locale_table.py
// Source: {csv_path.as_posix()}
// Generated: {timestamp}

pub(crate) const TIME_LOCALE_TABLE: &[TimeLocaleEntry] = &[
"""
    body = "\n".join(entries)
    footer = "\n];\n"
    return header + body + footer


def main() -> None:
    parser = argparse.ArgumentParser(description="Core.Time ロケールテーブル生成")
    parser.add_argument("--csv", type=Path, default=DEFAULT_CSV, help="入力 CSV パス")
    parser.add_argument("--output", type=Path, default=DEFAULT_OUTPUT, help="出力 Rust ファイル")
    args = parser.parse_args()

    entries = load_entries(args.csv)
    if not entries:
        raise SystemExit("CSV からロケール行を取得できませんでした")
    content = render(entries, args.csv)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(content, encoding="utf-8")
    print(f"Wrote {len(entries)} entries to {args.output}")


if __name__ == "__main__":
    main()
