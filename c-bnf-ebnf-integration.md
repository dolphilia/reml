# RemlにおけるBNF/EBNF対応検討

## 背景
Remlはパーサーコンビネーターを中核に据え、型推論・効果安全・高品質なエラー報告を特徴とする言語仕様を目指している。言語処理系の世界ではBNF/EBNF形式で文法を宣言的に記述し、パーサージェネレーターにより解析器を生成する手法が広く使われている。本メモではBNF/EBNFを直接扱うツールの事例、利点と欠点、Remlへの適用可能性と実装構想を整理する。

## BNF/EBNFを直接扱う代表的ツール・言語
- `yacc`/`bison`, `ANTLR`, `JavaCC`: BNF/EBNFや拡張構文で文法を入力し、LR/LL系解析器やトークナイザを生成するクラシックなパーサージェネレーター。
- PEG系（`PEG.js`, `LPeg`, Rust `pest`）: PEG/EBNFライクな宣言記法からPackratパーサーを生成し、バックトラッキングを制御なしに扱える。
- Scala `parser combinators`: EBNF風のシンタックスシュガーを持つDSLで、宣言的文法を直接コンビネーターにマッピング。
- その他言語組み込みDSL（TypeScript `nearley`, Python `lark` など）: BNF/EBNF記法をベースに複数ターゲットで解析器を生成。

## 直接扱うメリット
- 文法の可視性と共有性が高く、既存言語仕様や外部資料からの移植が容易。
- 宣言的記述により文法全体像を把握しやすく、ドキュメント用途にも適する。
- ツールチェインの自動生成が可能で、手続き的コードを手書きする必要が減る。

## 直接扱うデメリット
- 生成物がブラックボックス化しやすく、細かなバックトラック制御や効果的エラーハンドリングの挙動を把握しづらい。
- 文法記述と実際の処理ロジックが分離し、メンテナンスが二重化する（文法更新→生成→コード反映）。
- Reml固有のcut/commit、期待集合、効果安全などの情報はBNFでは表現しづらく、追加注釈が肥大化する恐れがある。
- Unicodeの3層モデル（byte/char/grapheme）をBNFで扱うには前処理やラベルが必要になり、抽象度が矛盾する。

## Reml設計との適合性評価
- Remlはコンビネーターを通じて「構文解析と効果・エラー処理を一体化」する設計思想を持つ。BNF中心に切り替えると、この密結合が失われ、Remlの差別化要素が薄れる。
- すべてをBNFで表現すると、効果システムやラベル付エラー生成を外付け注釈に頼る必要がある。言語の主訴である「型推論や効果安全と連動した解析」はBNFでは表現力不足。
- 仕様書用途での参照文法は有用だが、実装の一次ソースとして採用すると学習コストとメンテナンスが増大し、既存コンビネータAPIとの同期が課題となる。

## 導入する場合の実装方針案
- `Grammar`モジュールとして軽量EBNF DSLを定義し、解析後に`Parser<T>`へ展開するトランスパイル層を用意する。追加メタ情報（`cut`, `label`, `recover`など）は属性記法で注釈。
- 文法ファイルは仕様書用と実装用を同一ソースにし、生成器がRemlソース（コンビネーター列）へ落とし込む。生成物はバージョン管理を避け、毎回ビルドで作る運用とする。
- 公式仕様では「外部DSL互換レイヤ」と位置づけ、Reml本体のAPIは既存の`Core.Parse`を維持。利用者が既存BNF資産をRemlに移植する際の橋渡しとして提供する。

## 結論
- Remlの中核機能としてBNF/EBNF記法を標準搭載する必然性は低い。設計哲学（効果安全、詳細なエラー制御、Unicode第一）と整合させるには追加メタ情報が不可欠で、結果としてBNFの簡潔さが失われる。
- 一方で、ドキュメントや外部言語とのインターフェイスとして形式文法を表現できる補助レイヤを提供する価値はある。将来的にはオプション機能として軽量DSLとコンビネーター生成器を検討するのが現実的。

## 推奨アクション
- 仕様書内で今回の検討結果を記載し、BNF/EBNFサポートは「拡張候補」に留める。
- 試験的に小さなEBNF DSL→Remlコンビネーター変換プロトタイプを作成し、cutやエラー注釈をどのように埋め込むか検証する。
- Unicode処理とエラー追跡をDSLに乗せる際のメタ構文（属性記法）の草案をまとめ、導入可否を再評価する。
