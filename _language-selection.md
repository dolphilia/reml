# 言語選定メモ（Kestrel コンパイラ初期実装）

## 1. 評価観点
- 言語仕様の要求: 簡潔で安全なコード、HM 型推論とトレイト制約、Unicode NFC/書記素対応 (`0-1-overview.md`, `1-2-types-Inference.md`, `1-4-test-unicode-model.md`).
- パーサ実装: ゼロコピー入力ビュー、Packrat/左再帰、期待集合を伴う診断 (`2-1-perser-type.md`, `2-5-error.md`, `2-6-execution-strategy.md`).
- コード生成: LLVM IR 出力と RC ベースの最小ランタイム (`a-jit.md`).

## 2. 候補言語別検討

### Rust
- **強み**: 所有権・借用と `&str` による安全なゼロコピー処理、`enum` とパターンマッチで `Reply` や `ParseError` を表現しやすい。
- **仕様適合**: trait/ジェネリクスで HM 推論後の型・トレイト辞書を自然に表現。属性マクロで `@pure` 等の効果検査も拡張しやすい。
- **周辺環境**: `inkwell` 等で LLVM と連携可。`Arc<RwLock>` や Arena/`Rc` を組み合わせて Packrat メモ・リングバッファ実装が容易。
- **懸念**: ライフタイム設計が複雑化し得る。コンパイル時間やビルドキャッシュを考慮した開発プロセス設計が必要。

### OCaml
- **強み**: HM 型推論・トレイト制約の試作が高速。ADT・パターンマッチでフロントエンド設計が容易。
- **活用シナリオ**: 仕様検証用のプロトタイプとしてフロントエンドを短期実装し、Rust 版への移植指針を得る用途に適する。
- **制約**: GC 依存で Packrat の LRU 制御やリングバッファが書きにくい。Unicode 書記素処理は外部ライブラリ頼み。LLVM/RC 連携が C stubs で煩雑。

### C++
- **強み**: LLVM コアとの親和性が高く、JIT・低レベルランタイムを効率的に実装可能。
- **懸念**: HM 推論・エラー集約等の高レベル処理を安全に記述するためのユーティリティ整備が大きな負担。Unicode・ゼロコピー入力を安全に保つには自作インフラが必要。所有権管理ミスによる品質リスクが高い。

### その他
- Haskell/Idris: 型推論研究用途には好適だが LLVM 対応やゼロコピー I/O を性能面で満たすための追加レイヤが必要。
- Zig/Swift: 低レベル制御は可能だがエコシステムやセルフホスト移行時の互換性で優位性が薄い。

## 3. 推奨案
- **第一候補: Rust** — 仕様要求を安全に満たしつつ LLVM バックエンドまで一貫して構築できる。RC ベースのランタイムや Packrat 実装の細部まで型安全に制御できる点が決め手。
- **補助選択肢: OCaml によるプロトタイプ** — 解析・型推論・診断の振る舞い確認を短期間で行い、その知見を Rust 実装へ反映させる二段階アプローチが有効。
- **C++ は将来の最適化専用** — JIT ランタイムのホットパス最適化など特定領域に限定して検討する。

## 4. 次のアクション
1. Rust を前提としたモジュール分割（解析→推論→MIR→LLVM）と主要データ構造のドラフト作成。
2. 型推論・エラー整形のリファレンスが必要な場合、OCaml で最小構成を試作し検証ケースを蓄積。
3. LLVM バインディング・Unicode 処理・リングバッファ実装に使うクレート候補を調査し、必要な補助ツールの整備計画を立案。
